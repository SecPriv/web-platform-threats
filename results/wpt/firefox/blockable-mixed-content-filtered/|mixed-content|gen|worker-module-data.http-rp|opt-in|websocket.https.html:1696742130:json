{"network":{"requests":{"3":{"requestId":"3","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"main_frame","timeStamp":1696742123391,"tabId":1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8000"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate"},{"name":"Connection","value":"keep-alive"},{"name":"Upgrade-Insecure-Requests","value":"1"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"4":{"requestId":"4","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/testharness_runner.html","origin":"https://web-platform.test:8443","pathname":"/testharness_runner.html","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"main_frame","timeStamp":1696742123526,"tabId":1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Upgrade-Insecure-Requests","value":"1"},{"name":"Sec-Fetch-Dest","value":"document"},{"name":"Sec-Fetch-Mode","value":"navigate"},{"name":"Sec-Fetch-Site","value":"none"},{"name":"Sec-Fetch-User","value":"?1"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"5":{"requestId":"5","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"","hostname":"","href":"about:blank","origin":"null","pathname":"blank","port":"","protocol":"about:","site":""},"documentUrl":{"host":"","hostname":"","href":"about:blank","origin":"null","pathname":"blank","port":"","protocol":"about:","site":""},"method":"GET","type":"main_frame","timeStamp":1696742123786,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Upgrade-Insecure-Requests","value":"1"},{"name":"Sec-Fetch-Dest","value":"document"},{"name":"Sec-Fetch-Mode","value":"navigate"},{"name":"Sec-Fetch-Site","value":"none"},{"name":"Sec-Fetch-User","value":"?1"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"6":{"requestId":"6","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/resources/testharness.js","origin":"https://web-platform.test:8443","pathname":"/resources/testharness.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123824,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"script"},{"name":"Sec-Fetch-Mode","value":"no-cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"7":{"requestId":"7","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/resources/testharnessreport.js","origin":"https://web-platform.test:8443","pathname":"/resources/testharnessreport.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123825,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"script"},{"name":"Sec-Fetch-Mode","value":"no-cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"8":{"requestId":"8","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","origin":"https://web-platform.test:8443","pathname":"/common/security-features/resources/common.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123826,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"script"},{"name":"Sec-Fetch-Mode","value":"no-cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"9":{"requestId":"9","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/generic/test-case.sub.js","origin":"https://web-platform.test:8443","pathname":"/mixed-content/generic/test-case.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123826,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"script"},{"name":"Sec-Fetch-Mode","value":"no-cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"10":{"requestId":"10","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=put&value=8dd73b9d-3879-47ea-b60b-33460b5aa4d9","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742123930,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"11":{"requestId":"11","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","origin":"https://web-platform.test:8443","pathname":"/common/security-features/scope/worker.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742123951,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Connection","value":"keep-alive"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"12":{"requestId":"12","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","origin":"https://web-platform.test:8443","pathname":"/common/security-features/resources/common.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123966,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":true,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Sec-Fetch-Dest","value":"worker"},{"name":"Sec-Fetch-Mode","value":"no-cors"},{"name":"Sec-Fetch-Site","value":"cross-site"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0,"frameAncestors":[]},"13":{"requestId":"13","url":{"host":"web-platform.test:8889","hostname":"web-platform.test","href":"wss://web-platform.test:8889/stash_responder?redirection=no-redirect&action=purge&key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content","origin":"wss://web-platform.test:8889","pathname":"/stash_responder","port":"8889","protocol":"wss:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"websocket","timeStamp":1696742124019,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8889"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Sec-WebSocket-Version","value":"13"},{"name":"Origin","value":"https://web-platform.test:8443"},{"name":"Sec-WebSocket-Extensions","value":"permessage-deflate"},{"name":"Sec-WebSocket-Key","value":"xSXkZnGnlX+JrBkMrnpYbg=="},{"name":"Connection","value":"keep-alive"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"websocket"},{"name":"Sec-Fetch-Site","value":"same-site"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0,"frameAncestors":[]},"14":{"requestId":"14","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=take","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124114,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"15":{"requestId":"15","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=put&value=c94e3994-6ca0-4f36-b67a-da4a8e3e6be6","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124135,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"16":{"requestId":"16","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","origin":"https://web-platform.test:8443","pathname":"/common/security-features/scope/worker.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124178,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Connection","value":"keep-alive"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"17":{"requestId":"17","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","origin":"https://web-platform.test:8443","pathname":"/common/security-features/resources/common.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742124212,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":true,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Sec-Fetch-Dest","value":"worker"},{"name":"Sec-Fetch-Mode","value":"no-cors"},{"name":"Sec-Fetch-Site","value":"cross-site"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0,"frameAncestors":[]},"18":{"requestId":"18","url":{"host":"www1.web-platform.test:8888","hostname":"www1.web-platform.test","href":"ws://www1.web-platform.test:8888/stash_responder?redirection=no-redirect&action=purge&key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content","origin":"ws://www1.web-platform.test:8888","pathname":"/stash_responder","port":"8888","protocol":"ws:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"websocket","timeStamp":1696742124226,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"www1.web-platform.test:8888"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate"},{"name":"Sec-WebSocket-Version","value":"13"},{"name":"Origin","value":"https://web-platform.test:8443"},{"name":"Sec-WebSocket-Extensions","value":"permessage-deflate"},{"name":"Sec-WebSocket-Key","value":"L8eWrsg+X6a5frLKP8CX8A=="},{"name":"Connection","value":"keep-alive"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0,"frameAncestors":[]},"19":{"requestId":"19","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=take","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124246,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"20":{"requestId":"20","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=put&value=4f0be357-dbd8-4ad1-9604-244ae340208d","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124275,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"21":{"requestId":"21","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","origin":"https://web-platform.test:8443","pathname":"/common/security-features/scope/worker.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124305,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Connection","value":"keep-alive"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"22":{"requestId":"22","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","origin":"https://web-platform.test:8443","pathname":"/common/security-features/resources/common.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742124332,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":true,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Sec-Fetch-Dest","value":"worker"},{"name":"Sec-Fetch-Mode","value":"no-cors"},{"name":"Sec-Fetch-Site","value":"cross-site"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0,"frameAncestors":[]},"23":{"requestId":"23","url":{"host":"web-platform.test:8888","hostname":"web-platform.test","href":"ws://web-platform.test:8888/stash_responder?redirection=no-redirect&action=purge&key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content","origin":"ws://web-platform.test:8888","pathname":"/stash_responder","port":"8888","protocol":"ws:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"websocket","timeStamp":1696742124469,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8888"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate"},{"name":"Sec-WebSocket-Version","value":"13"},{"name":"Origin","value":"https://web-platform.test:8443"},{"name":"Sec-WebSocket-Extensions","value":"permessage-deflate"},{"name":"Sec-WebSocket-Key","value":"ird2B5T+NCfMcNX+shPrtA=="},{"name":"Connection","value":"keep-alive"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0,"frameAncestors":[]},"24":{"requestId":"24","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=take","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124532,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8443"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate, br"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html"},{"name":"Sec-Fetch-Dest","value":"empty"},{"name":"Sec-Fetch-Mode","value":"cors"},{"name":"Sec-Fetch-Site","value":"same-origin"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"25":{"requestId":"25","url":{"host":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","hostname":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","href":"http://b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it/download-trace","origin":"http://b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","pathname":"/download-trace","port":"","protocol":"http:","site":"mitm.it"},"originUrl":{"host":"969ae323-9019-4609-a882-51906695a674","hostname":"969ae323-9019-4609-a882-51906695a674","href":"moz-extension://969ae323-9019-4609-a882-51906695a674/_generated_background_page.html","origin":"moz-extension://969ae323-9019-4609-a882-51906695a674","pathname":"/_generated_background_page.html","port":"","protocol":"moz-extension:","site":"969ae323-9019-4609-a882-51906695a674"},"documentUrl":{"host":"969ae323-9019-4609-a882-51906695a674","hostname":"969ae323-9019-4609-a882-51906695a674","href":"moz-extension://969ae323-9019-4609-a882-51906695a674/_generated_background_page.html","origin":"moz-extension://969ae323-9019-4609-a882-51906695a674","pathname":"/_generated_background_page.html","port":"","protocol":"moz-extension:","site":"969ae323-9019-4609-a882-51906695a674"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742125569,"tabId":-1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate"},{"name":"Connection","value":"keep-alive"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0}},"responses":{"3":{"requestId":"3","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"main_frame","timeStamp":1696742123428,"tabId":1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/html"},{"name":"Cache-Control","value":"max-age=3600"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:23 GMT"},{"name":"Content-Length","value":"95"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":398,"responseSize":261},"4":{"requestId":"4","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/testharness_runner.html","origin":"https://web-platform.test:8443","pathname":"/testharness_runner.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"main_frame","timeStamp":1696742123662,"tabId":1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/html"},{"name":"Cache-Control","value":"max-age=3600"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:23 GMT"},{"name":"Content-Length","value":"95"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":467,"responseSize":300},"5":{"requestId":"5","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"main_frame","timeStamp":1696742123810,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/html"},{"name":"Content-Security-Policy","value":"block-all-mixed-content"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:23 GMT"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":516,"responseSize":2573},"6":{"requestId":"6","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/resources/testharness.js","origin":"https://web-platform.test:8443","pathname":"/resources/testharness.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123876,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/javascript; charset=utf-8"},{"name":"Cache-Control","value":"max-age=3600"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:23 GMT"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":454,"responseSize":186949},"7":{"requestId":"7","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/resources/testharnessreport.js","origin":"https://web-platform.test:8443","pathname":"/resources/testharnessreport.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123914,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/javascript;charset=utf8"},{"name":"Cache-Control","value":"max-age=3600"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:23 GMT"},{"name":"Content-Length","value":"2385"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":460,"responseSize":2611},"8":{"requestId":"8","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","origin":"https://web-platform.test:8443","pathname":"/common/security-features/resources/common.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123880,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/javascript"},{"name":"Access-Control-Allow-Origin","value":"*"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:23 GMT"},{"name":"Content-Length","value":"46465"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":478,"responseSize":46682},"9":{"requestId":"9","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/generic/test-case.sub.js","origin":"https://web-platform.test:8443","pathname":"/mixed-content/generic/test-case.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123925,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/javascript"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:23 GMT"},{"name":"Content-Length","value":"2391"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":468,"responseSize":2575},"10":{"requestId":"10","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=put&value=8dd73b9d-3879-47ea-b60b-33460b5aa4d9","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742123948,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"content-type","value":"text/javascript"},{"name":"cache-control","value":"no-cache; must-revalidate"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":586,"responseSize":163},"11":{"requestId":"11","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","origin":"https://web-platform.test:8443","pathname":"/common/security-features/scope/worker.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742123958,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"access-control-allow-origin","value":"*"},{"name":"content-type","value":"text/javascript"},{"name":"cache-control","value":"no-cache; must-revalidate"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":502,"responseSize":1119},"12":{"requestId":"12","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","origin":"https://web-platform.test:8443","pathname":"/common/security-features/resources/common.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742123999,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":true,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/javascript"},{"name":"Access-Control-Allow-Origin","value":"*"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:23 GMT"},{"name":"Content-Length","value":"46465"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":363,"responseSize":46682},"13":{"requestId":"13","url":{"host":"web-platform.test:8889","hostname":"web-platform.test","href":"wss://web-platform.test:8889/stash_responder?redirection=no-redirect&action=purge&key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content","origin":"wss://web-platform.test:8889","pathname":"/stash_responder","port":"8889","protocol":"wss:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"websocket","timeStamp":1696742124092,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Upgrade","value":"websocket"},{"name":"Connection","value":"Upgrade"},{"name":"Sec-WebSocket-Accept","value":"d4ha4KdEUe3kNsLGJJrOdB2h2JI="},{"name":"Sec-WebSocket-Extensions","value":"permessage-deflate"}],"statusCode":101,"statusLine":"HTTP/1.1 101 Switching Protocols","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":660,"responseSize":214},"14":{"requestId":"14","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=take","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124129,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"content-type","value":"text/javascript"},{"name":"cache-control","value":"no-cache; must-revalidate"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":544,"responseSize":129},"15":{"requestId":"15","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=put&value=c94e3994-6ca0-4f36-b67a-da4a8e3e6be6","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124175,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"content-type","value":"text/javascript"},{"name":"cache-control","value":"no-cache; must-revalidate"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":586,"responseSize":202},"16":{"requestId":"16","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","origin":"https://web-platform.test:8443","pathname":"/common/security-features/scope/worker.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124204,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"access-control-allow-origin","value":"*"},{"name":"content-type","value":"text/javascript"},{"name":"cache-control","value":"no-cache; must-revalidate"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":502,"responseSize":1158},"17":{"requestId":"17","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","origin":"https://web-platform.test:8443","pathname":"/common/security-features/resources/common.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742124221,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":true,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/javascript"},{"name":"Access-Control-Allow-Origin","value":"*"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:24 GMT"},{"name":"Content-Length","value":"46465"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":363,"responseSize":46643},"18":{"requestId":"18","url":{"host":"www1.web-platform.test:8888","hostname":"www1.web-platform.test","href":"ws://www1.web-platform.test:8888/stash_responder?redirection=no-redirect&action=purge&key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content","origin":"ws://www1.web-platform.test:8888","pathname":"/stash_responder","port":"8888","protocol":"ws:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"websocket","timeStamp":1696742124236,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Upgrade","value":"websocket"},{"name":"Connection","value":"Upgrade"},{"name":"Sec-WebSocket-Accept","value":"S/OnLwPL0USarvpyu6YlX3SnH2M="},{"name":"Sec-WebSocket-Extensions","value":"permessage-deflate"}],"statusCode":101,"statusLine":"HTTP/1.1 101 Switching Protocols","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":584,"responseSize":214},"19":{"requestId":"19","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=take","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124270,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"content-type","value":"text/javascript"},{"name":"cache-control","value":"no-cache; must-revalidate"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":544,"responseSize":168},"20":{"requestId":"20","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=put&value=4f0be357-dbd8-4ad1-9604-244ae340208d","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124302,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"content-type","value":"text/javascript"},{"name":"cache-control","value":"no-cache; must-revalidate"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":586,"responseSize":202},"21":{"requestId":"21","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","origin":"https://web-platform.test:8443","pathname":"/common/security-features/scope/worker.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124325,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"access-control-allow-origin","value":"*"},{"name":"content-type","value":"text/javascript"},{"name":"cache-control","value":"no-cache; must-revalidate"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":502,"responseSize":1158},"22":{"requestId":"22","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","origin":"https://web-platform.test:8443","pathname":"/common/security-features/resources/common.sub.js","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696742124340,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":true,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/javascript"},{"name":"Access-Control-Allow-Origin","value":"*"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 05:15:24 GMT"},{"name":"Content-Length","value":"46465"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":363,"responseSize":46643},"23":{"requestId":"23","url":{"host":"web-platform.test:8888","hostname":"web-platform.test","href":"ws://web-platform.test:8888/stash_responder?redirection=no-redirect&action=purge&key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content","origin":"ws://web-platform.test:8888","pathname":"/stash_responder","port":"8888","protocol":"ws:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"websocket","timeStamp":1696742124514,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Upgrade","value":"websocket"},{"name":"Connection","value":"Upgrade"},{"name":"Sec-WebSocket-Accept","value":"BlBQ/mtO2Z4fcsihwmv5t00Dhus="},{"name":"Sec-WebSocket-Extensions","value":"permessage-deflate"}],"statusCode":101,"statusLine":"HTTP/1.1 101 Switching Protocols","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":579,"responseSize":214},"24":{"requestId":"24","url":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=take","origin":"https://web-platform.test:8443","pathname":"/common/security-features/subresource/xhr.py","port":"8443","protocol":"https:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742124560,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"content-type","value":"text/javascript"},{"name":"cache-control","value":"no-cache; must-revalidate"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":544,"responseSize":168},"25":{"requestId":"25","url":{"host":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","hostname":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","href":"http://b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it/download-trace","origin":"http://b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","pathname":"/download-trace","port":"","protocol":"http:","site":"mitm.it"},"originUrl":{"host":"969ae323-9019-4609-a882-51906695a674","hostname":"969ae323-9019-4609-a882-51906695a674","href":"moz-extension://969ae323-9019-4609-a882-51906695a674/_generated_background_page.html","origin":"moz-extension://969ae323-9019-4609-a882-51906695a674","pathname":"/_generated_background_page.html","port":"","protocol":"moz-extension:","site":"969ae323-9019-4609-a882-51906695a674"},"documentUrl":{"host":"969ae323-9019-4609-a882-51906695a674","hostname":"969ae323-9019-4609-a882-51906695a674","href":"moz-extension://969ae323-9019-4609-a882-51906695a674/_generated_background_page.html","origin":"moz-extension://969ae323-9019-4609-a882-51906695a674","pathname":"/_generated_background_page.html","port":"","protocol":"moz-extension:","site":"969ae323-9019-4609-a882-51906695a674"},"method":"GET","type":"xmlhttprequest","timeStamp":1696742125581,"tabId":-1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"application/json"},{"name":"Access-Control-Allow-Origin","value":"*"},{"name":"content-length","value":"523084"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":313,"responseSize":523191}},"redirects":{}},"events":[{"isSecure":true,"wid":"a07a0fbe-3d89-43e5-96f2-74c0e3a194f4","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/testharness_runner.html","origin":"https://web-platform.test:8443","pathname":"/testharness_runner.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"WindowOpen","args":["about:blank","ddd5f5b8-e5b3-4e91-9e7b-5fe6d18186bd","noopener"],"ret":null,"timeStamp":1696742123736},{"isSecure":true,"wid":"1228eda6-7e78-4e82-90fb-73847bd9224d","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"XHR","args":["GET","/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=put&value=8dd73b9d-3879-47ea-b60b-33460b5aa4d9"],"ret":null,"timeStamp":1696742123929},{"isSecure":true,"wid":"1228eda6-7e78-4e82-90fb-73847bd9224d","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"Fetch","args":["/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module",null],"ret":null,"timeStamp":1696742123949},{"isSecure":true,"wid":"1228eda6-7e78-4e82-90fb-73847bd9224d","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"XHR","args":["GET","/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=take"],"ret":null,"timeStamp":1696742124112},{"isSecure":true,"wid":"1228eda6-7e78-4e82-90fb-73847bd9224d","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"XHR","args":["GET","/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=put&value=c94e3994-6ca0-4f36-b67a-da4a8e3e6be6"],"ret":null,"timeStamp":1696742124134},{"isSecure":true,"wid":"1228eda6-7e78-4e82-90fb-73847bd9224d","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"Fetch","args":["/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module",null],"ret":null,"timeStamp":1696742124176},{"isSecure":true,"wid":"1228eda6-7e78-4e82-90fb-73847bd9224d","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"XHR","args":["GET","/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=take"],"ret":null,"timeStamp":1696742124243},{"isSecure":true,"wid":"1228eda6-7e78-4e82-90fb-73847bd9224d","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"XHR","args":["GET","/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=put&value=4f0be357-dbd8-4ad1-9604-244ae340208d"],"ret":null,"timeStamp":1696742124273},{"isSecure":true,"wid":"1228eda6-7e78-4e82-90fb-73847bd9224d","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"Fetch","args":["/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module",null],"ret":null,"timeStamp":1696742124302},{"isSecure":true,"wid":"1228eda6-7e78-4e82-90fb-73847bd9224d","orig":{"host":"web-platform.test:8443","hostname":"web-platform.test","href":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","origin":"https://web-platform.test:8443","pathname":"/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","port":"8443","protocol":"https:","site":"web-platform.test"},"type":"XHR","args":["GET","/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=take"],"ret":null,"timeStamp":1696742124528}],"cookies":{},"tests":{"Mixed-Content: Expects allowed for websocket to same-wss origin and no-redirect redirection from https context.":{"start":1696742123928,"end":1696742124133},"Mixed-Content: Expects blocked for websocket to cross-ws origin and no-redirect redirection from https context.":{"start":1696742124134,"end":1696742124273},"Mixed-Content: Expects blocked for websocket to same-ws origin and no-redirect redirection from https context.":{"start":1696742124273,"end":1696742124563}},"proxy":{"requests":[{"url":"http://web-platform.test:8000/testharness_runner.html","request_start":1696742123.3991287,"request_end":1696742123.3998308,"ts":1696742123.4000874,"body":""},{"url":"https://web-platform.test:8443/testharness_runner.html","request_start":1696742123.6044097,"request_end":1696742123.605386,"ts":1696742123.6056778,"body":""},{"url":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","request_start":1696742123.7908103,"request_end":1696742123.7917643,"ts":1696742123.7922544,"body":""},{"url":"https://web-platform.test:8443/resources/testharness.js","request_start":1696742123.8568175,"request_end":1696742123.858217,"ts":1696742123.8587232,"body":""},{"url":"https://web-platform.test:8443/resources/testharnessreport.js","request_start":1696742123.863972,"request_end":1696742123.8656645,"ts":1696742123.8668337,"body":""},{"url":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","request_start":1696742123.872195,"request_end":1696742123.8746445,"ts":1696742123.875479,"body":""},{"url":"https://web-platform.test:8443/mixed-content/generic/test-case.sub.js","request_start":1696742123.8772042,"request_end":1696742123.8777628,"ts":1696742123.8779738,"body":""},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=put&value=8dd73b9d-3879-47ea-b60b-33460b5aa4d9","request_start":1696742123.9324617,"request_end":1696742123.9331613,"ts":1696742123.9334269,"body":""},{"url":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","request_start":1696742123.951665,"request_end":1696742123.9522352,"ts":1696742123.9524546,"body":""},{"url":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","request_start":1696742123.992888,"request_end":1696742123.9935048,"ts":1696742123.9937437,"body":""},{"url":"https://web-platform.test:8889/stash_responder?redirection=no-redirect&action=purge&key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content","request_start":1696742124.0402422,"request_end":1696742124.0410311,"ts":1696742124.041377,"body":""},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=take","request_start":1696742124.1159527,"request_end":1696742124.1171193,"ts":1696742124.1175246,"body":""},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=put&value=c94e3994-6ca0-4f36-b67a-da4a8e3e6be6","request_start":1696742124.1680906,"request_end":1696742124.1686738,"ts":1696742124.168912,"body":""},{"url":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","request_start":1696742124.1985848,"request_end":1696742124.1992779,"ts":1696742124.1995485,"body":""},{"url":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","request_start":1696742124.213901,"request_end":1696742124.2145894,"ts":1696742124.2151117,"body":""},{"url":"http://www1.web-platform.test:8888/stash_responder?redirection=no-redirect&action=purge&key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content","request_start":1696742124.2309911,"request_end":1696742124.2314894,"ts":1696742124.2317042,"body":""},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=take","request_start":1696742124.2626638,"request_end":1696742124.263268,"ts":1696742124.26352,"body":""},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=put&value=4f0be357-dbd8-4ad1-9604-244ae340208d","request_start":1696742124.2947466,"request_end":1696742124.2954023,"ts":1696742124.2956595,"body":""},{"url":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","request_start":1696742124.3198075,"request_end":1696742124.3203251,"ts":1696742124.3205585,"body":""},{"url":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","request_start":1696742124.3327816,"request_end":1696742124.3334064,"ts":1696742124.3336325,"body":""},{"url":"http://web-platform.test:8888/stash_responder?redirection=no-redirect&action=purge&key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content","request_start":1696742124.4765775,"request_end":1696742124.4770842,"ts":1696742124.4772995,"body":""},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=take","request_start":1696742124.55216,"request_end":1696742124.5531754,"ts":1696742124.553503,"body":""}],"responses":[{"url":"http://web-platform.test:8000/testharness_runner.html","request_start":1696742123.3991287,"response_start":1696742123.4075718,"request_end":1696742123.3998308,"response_end":1696742123.4082,"ts":1696742123.40837,"body":"<!doctype html>\n<title></title>\n<script>\nvar timeout_multiplier = 1;\nvar win = null;\n</script>\n"},{"url":"https://web-platform.test:8443/testharness_runner.html","request_start":1696742123.6044097,"response_start":1696742123.6477406,"request_end":1696742123.605386,"response_end":1696742123.6485882,"ts":1696742123.648819,"body":"<!doctype html>\n<title></title>\n<script>\nvar timeout_multiplier = 1;\nvar win = null;\n</script>\n"},{"url":"https://web-platform.test:8443/mixed-content/gen/worker-module-data.http-rp/opt-in/websocket.https.html","request_start":1696742123.7908103,"response_start":1696742123.794431,"request_end":1696742123.7917643,"response_end":1696742123.7950826,"ts":1696742123.7953548,"body":"<!DOCTYPE html>\n<!-- DO NOT EDIT! Generated by `common/security-features/tools/generate.py --spec mixed-content/` -->\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"timeout\" content=\"long\">\n    <script src=\"/resources/testharness.js\"></script>\n    <script src=\"/resources/testharnessreport.js\"></script>\n    <script src=\"/common/security-features/resources/common.sub.js\"></script>\n    <script src=\"../../../generic/test-case.sub.js\"></script>\n  </head>\n  <body>\n    <script>\n      TestCase(\n        [\n          {\n            \"expectation\": \"allowed\",\n            \"origin\": \"same-wss\",\n            \"redirection\": \"no-redirect\",\n            \"source_context_list\": [\n              {\n                \"policyDeliveries\": [],\n                \"sourceContextType\": \"worker-module-data\"\n              }\n            ],\n            \"source_scheme\": \"https\",\n            \"subresource\": \"websocket\",\n            \"subresource_policy_deliveries\": [],\n            \"test_description\": \"Mixed-Content: Expects allowed for websocket to same-wss origin and no-redirect redirection from https context.\"\n          },\n          {\n            \"expectation\": \"blocked\",\n            \"origin\": \"cross-ws\",\n            \"redirection\": \"no-redirect\",\n            \"source_context_list\": [\n              {\n                \"policyDeliveries\": [],\n                \"sourceContextType\": \"worker-module-data\"\n              }\n            ],\n            \"source_scheme\": \"https\",\n            \"subresource\": \"websocket\",\n            \"subresource_policy_deliveries\": [],\n            \"test_description\": \"Mixed-Content: Expects blocked for websocket to cross-ws origin and no-redirect redirection from https context.\"\n          },\n          {\n            \"expectation\": \"blocked\",\n            \"origin\": \"same-ws\",\n            \"redirection\": \"no-redirect\",\n            \"source_context_list\": [\n              {\n                \"policyDeliveries\": [],\n                \"sourceContextType\": \"worker-module-data\"\n              }\n            ],\n            \"source_scheme\": \"https\",\n            \"subresource\": \"websocket\",\n            \"subresource_policy_deliveries\": [],\n            \"test_description\": \"Mixed-Content: Expects blocked for websocket to same-ws origin and no-redirect redirection from https context.\"\n          }\n        ],\n        new SanityChecker()\n      ).start();\n    </script>\n    <div id=\"log\"></div>\n  </body>\n</html>\n"},{"url":"https://web-platform.test:8443/resources/testharness.js","request_start":1696742123.8568175,"response_start":1696742123.864416,"request_end":1696742123.858217,"response_end":1696742123.8717153,"ts":1696742123.8727136,"body":"/*global self*/\n/*jshint latedef: nofunc*/\n\n/* Documentation: https://web-platform-tests.org/writing-tests/testharness-api.html\n * (../docs/_writing-tests/testharness-api.md) */\n\n(function (global_scope)\n{\n    // default timeout is 10 seconds, test can override if needed\n    var settings = {\n        output:true,\n        harness_timeout:{\n            \"normal\":10000,\n            \"long\":60000\n        },\n        test_timeout:null,\n        message_events: [\"start\", \"test_state\", \"result\", \"completion\"],\n        debug: false,\n    };\n\n    var xhtml_ns = \"http://www.w3.org/1999/xhtml\";\n\n    /*\n     * TestEnvironment is an abstraction for the environment in which the test\n     * harness is used. Each implementation of a test environment has to provide\n     * the following interface:\n     *\n     * interface TestEnvironment {\n     *   // Invoked after the global 'tests' object has been created and it's\n     *   // safe to call add_*_callback() to register event handlers.\n     *   void on_tests_ready();\n     *\n     *   // Invoked after setup() has been called to notify the test environment\n     *   // of changes to the test harness properties.\n     *   void on_new_harness_properties(object properties);\n     *\n     *   // Should return a new unique default test name.\n     *   DOMString next_default_test_name();\n     *\n     *   // Should return the test harness timeout duration in milliseconds.\n     *   float test_timeout();\n     * };\n     */\n\n    /*\n     * A test environment with a DOM. The global object is 'window'. By default\n     * test results are displayed in a table. Any parent windows receive\n     * callbacks or messages via postMessage() when test events occur. See\n     * apisample11.html and apisample12.html.\n     */\n    function WindowTestEnvironment() {\n        this.name_counter = 0;\n        this.window_cache = null;\n        this.output_handler = null;\n        this.all_loaded = false;\n        var this_obj = this;\n        this.message_events = [];\n        this.dispatched_messages = [];\n\n        this.message_functions = {\n            start: [add_start_callback, remove_start_callback,\n                    function (properties) {\n                        this_obj._dispatch(\"start_callback\", [properties],\n                                           {type: \"start\", properties: properties});\n                    }],\n\n            test_state: [add_test_state_callback, remove_test_state_callback,\n                         function(test) {\n                             this_obj._dispatch(\"test_state_callback\", [test],\n                                                {type: \"test_state\",\n                                                 test: test.structured_clone()});\n                         }],\n            result: [add_result_callback, remove_result_callback,\n                     function (test) {\n                         this_obj.output_handler.show_status();\n                         this_obj._dispatch(\"result_callback\", [test],\n                                            {type: \"result\",\n                                             test: test.structured_clone()});\n                     }],\n            completion: [add_completion_callback, remove_completion_callback,\n                         function (tests, harness_status, asserts) {\n                             var cloned_tests = map(tests, function(test) {\n                                 return test.structured_clone();\n                             });\n                             this_obj._dispatch(\"completion_callback\", [tests, harness_status],\n                                                {type: \"complete\",\n                                                 tests: cloned_tests,\n                                                 status: harness_status.structured_clone(),\n                                                 asserts: asserts.map(assert => assert.structured_clone())});\n                         }]\n        }\n\n        on_event(window, 'load', function() {\n            this_obj.all_loaded = true;\n        });\n\n        on_event(window, 'message', function(event) {\n            if (event.data && event.data.type === \"getmessages\" && event.source) {\n                // A window can post \"getmessages\" to receive a duplicate of every\n                // message posted by this environment so far. This allows subscribers\n                // from fetch_tests_from_window to 'catch up' to the current state of\n                // this environment.\n                for (var i = 0; i < this_obj.dispatched_messages.length; ++i)\n                {\n                    event.source.postMessage(this_obj.dispatched_messages[i], \"*\");\n                }\n            }\n        });\n    }\n\n    WindowTestEnvironment.prototype._dispatch = function(selector, callback_args, message_arg) {\n        this.dispatched_messages.push(message_arg);\n        this._forEach_windows(\n                function(w, same_origin) {\n                    if (same_origin) {\n                        try {\n                            var has_selector = selector in w;\n                        } catch(e) {\n                            // If document.domain was set at some point same_origin can be\n                            // wrong and the above will fail.\n                            has_selector = false;\n                        }\n                        if (has_selector) {\n                            try {\n                                w[selector].apply(undefined, callback_args);\n                            } catch (e) {}\n                        }\n                    }\n                    if (w !== self) {\n                        w.postMessage(message_arg, \"*\");\n                    }\n                });\n    };\n\n    WindowTestEnvironment.prototype._forEach_windows = function(callback) {\n        // Iterate over the windows [self ... top, opener]. The callback is passed\n        // two objects, the first one is the window object itself, the second one\n        // is a boolean indicating whether or not it's on the same origin as the\n        // current window.\n        var cache = this.window_cache;\n        if (!cache) {\n            cache = [[self, true]];\n            var w = self;\n            var i = 0;\n            var so;\n            while (w != w.parent) {\n                w = w.parent;\n                so = is_same_origin(w);\n                cache.push([w, so]);\n                i++;\n            }\n            w = window.opener;\n            if (w) {\n                cache.push([w, is_same_origin(w)]);\n            }\n            this.window_cache = cache;\n        }\n\n        forEach(cache,\n                function(a) {\n                    callback.apply(null, a);\n                });\n    };\n\n    WindowTestEnvironment.prototype.on_tests_ready = function() {\n        var output = new Output();\n        this.output_handler = output;\n\n        var this_obj = this;\n\n        add_start_callback(function (properties) {\n            this_obj.output_handler.init(properties);\n        });\n\n        add_test_state_callback(function(test) {\n            this_obj.output_handler.show_status();\n        });\n\n        add_result_callback(function (test) {\n            this_obj.output_handler.show_status();\n        });\n\n        add_completion_callback(function (tests, harness_status, asserts_run) {\n            this_obj.output_handler.show_results(tests, harness_status, asserts_run);\n        });\n        this.setup_messages(settings.message_events);\n    };\n\n    WindowTestEnvironment.prototype.setup_messages = function(new_events) {\n        var this_obj = this;\n        forEach(settings.message_events, function(x) {\n            var current_dispatch = this_obj.message_events.indexOf(x) !== -1;\n            var new_dispatch = new_events.indexOf(x) !== -1;\n            if (!current_dispatch && new_dispatch) {\n                this_obj.message_functions[x][0](this_obj.message_functions[x][2]);\n            } else if (current_dispatch && !new_dispatch) {\n                this_obj.message_functions[x][1](this_obj.message_functions[x][2]);\n            }\n        });\n        this.message_events = new_events;\n    }\n\n    WindowTestEnvironment.prototype.next_default_test_name = function() {\n        var suffix = this.name_counter > 0 ? \" \" + this.name_counter : \"\";\n        this.name_counter++;\n        return get_title() + suffix;\n    };\n\n    WindowTestEnvironment.prototype.on_new_harness_properties = function(properties) {\n        this.output_handler.setup(properties);\n        if (properties.hasOwnProperty(\"message_events\")) {\n            this.setup_messages(properties.message_events);\n        }\n    };\n\n    WindowTestEnvironment.prototype.add_on_loaded_callback = function(callback) {\n        on_event(window, 'load', callback);\n    };\n\n    WindowTestEnvironment.prototype.test_timeout = function() {\n        var metas = document.getElementsByTagName(\"meta\");\n        for (var i = 0; i < metas.length; i++) {\n            if (metas[i].name == \"timeout\") {\n                if (metas[i].content == \"long\") {\n                    return settings.harness_timeout.long;\n                }\n                break;\n            }\n        }\n        return settings.harness_timeout.normal;\n    };\n\n    /*\n     * Base TestEnvironment implementation for a generic web worker.\n     *\n     * Workers accumulate test results. One or more clients can connect and\n     * retrieve results from a worker at any time.\n     *\n     * WorkerTestEnvironment supports communicating with a client via a\n     * MessagePort.  The mechanism for determining the appropriate MessagePort\n     * for communicating with a client depends on the type of worker and is\n     * implemented by the various specializations of WorkerTestEnvironment\n     * below.\n     *\n     * A client document using testharness can use fetch_tests_from_worker() to\n     * retrieve results from a worker. See apisample16.html.\n     */\n    function WorkerTestEnvironment() {\n        this.name_counter = 0;\n        this.all_loaded = true;\n        this.message_list = [];\n        this.message_ports = [];\n    }\n\n    WorkerTestEnvironment.prototype._dispatch = function(message) {\n        this.message_list.push(message);\n        for (var i = 0; i < this.message_ports.length; ++i)\n        {\n            this.message_ports[i].postMessage(message);\n        }\n    };\n\n    // The only requirement is that port has a postMessage() method. It doesn't\n    // have to be an instance of a MessagePort, and often isn't.\n    WorkerTestEnvironment.prototype._add_message_port = function(port) {\n        this.message_ports.push(port);\n        for (var i = 0; i < this.message_list.length; ++i)\n        {\n            port.postMessage(this.message_list[i]);\n        }\n    };\n\n    WorkerTestEnvironment.prototype.next_default_test_name = function() {\n        var suffix = this.name_counter > 0 ? \" \" + this.name_counter : \"\";\n        this.name_counter++;\n        return get_title() + suffix;\n    };\n\n    WorkerTestEnvironment.prototype.on_new_harness_properties = function() {};\n\n    WorkerTestEnvironment.prototype.on_tests_ready = function() {\n        var this_obj = this;\n        add_start_callback(\n                function(properties) {\n                    this_obj._dispatch({\n                        type: \"start\",\n                        properties: properties,\n                    });\n                });\n        add_test_state_callback(\n                function(test) {\n                    this_obj._dispatch({\n                        type: \"test_state\",\n                        test: test.structured_clone()\n                    });\n                });\n        add_result_callback(\n                function(test) {\n                    this_obj._dispatch({\n                        type: \"result\",\n                        test: test.structured_clone()\n                    });\n                });\n        add_completion_callback(\n                function(tests, harness_status, asserts) {\n                    this_obj._dispatch({\n                        type: \"complete\",\n                        tests: map(tests,\n                            function(test) {\n                                return test.structured_clone();\n                            }),\n                        status: harness_status.structured_clone(),\n                        asserts: asserts.map(assert => assert.structured_clone()),\n                    });\n                });\n    };\n\n    WorkerTestEnvironment.prototype.add_on_loaded_callback = function() {};\n\n    WorkerTestEnvironment.prototype.test_timeout = function() {\n        // Tests running in a worker don't have a default timeout. I.e. all\n        // worker tests behave as if settings.explicit_timeout is true.\n        return null;\n    };\n\n    /*\n     * Dedicated web workers.\n     * https://html.spec.whatwg.org/multipage/workers.html#dedicatedworkerglobalscope\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a dedicated worker.\n     */\n    function DedicatedWorkerTestEnvironment() {\n        WorkerTestEnvironment.call(this);\n        // self is an instance of DedicatedWorkerGlobalScope which exposes\n        // a postMessage() method for communicating via the message channel\n        // established when the worker is created.\n        this._add_message_port(self);\n    }\n    DedicatedWorkerTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);\n\n    DedicatedWorkerTestEnvironment.prototype.on_tests_ready = function() {\n        WorkerTestEnvironment.prototype.on_tests_ready.call(this);\n        // In the absence of an onload notification, we a require dedicated\n        // workers to explicitly signal when the tests are done.\n        tests.wait_for_finish = true;\n    };\n\n    /*\n     * Shared web workers.\n     * https://html.spec.whatwg.org/multipage/workers.html#sharedworkerglobalscope\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a shared web worker.\n     */\n    function SharedWorkerTestEnvironment() {\n        WorkerTestEnvironment.call(this);\n        var this_obj = this;\n        // Shared workers receive message ports via the 'onconnect' event for\n        // each connection.\n        self.addEventListener(\"connect\",\n                function(message_event) {\n                    this_obj._add_message_port(message_event.source);\n                }, false);\n    }\n    SharedWorkerTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);\n\n    SharedWorkerTestEnvironment.prototype.on_tests_ready = function() {\n        WorkerTestEnvironment.prototype.on_tests_ready.call(this);\n        // In the absence of an onload notification, we a require shared\n        // workers to explicitly signal when the tests are done.\n        tests.wait_for_finish = true;\n    };\n\n    /*\n     * Service workers.\n     * http://www.w3.org/TR/service-workers/\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a service worker.\n     */\n    function ServiceWorkerTestEnvironment() {\n        WorkerTestEnvironment.call(this);\n        this.all_loaded = false;\n        this.on_loaded_callback = null;\n        var this_obj = this;\n        self.addEventListener(\"message\",\n                function(event) {\n                    if (event.data && event.data.type && event.data.type === \"connect\") {\n                        this_obj._add_message_port(event.source);\n                    }\n                }, false);\n\n        // The oninstall event is received after the service worker script and\n        // all imported scripts have been fetched and executed. It's the\n        // equivalent of an onload event for a document. All tests should have\n        // been added by the time this event is received, thus it's not\n        // necessary to wait until the onactivate event. However, tests for\n        // installed service workers need another event which is equivalent to\n        // the onload event because oninstall is fired only on installation. The\n        // onmessage event is used for that purpose since tests using\n        // testharness.js should ask the result to its service worker by\n        // PostMessage. If the onmessage event is triggered on the service\n        // worker's context, that means the worker's script has been evaluated.\n        on_event(self, \"install\", on_all_loaded);\n        on_event(self, \"message\", on_all_loaded);\n        function on_all_loaded() {\n            if (this_obj.all_loaded)\n                return;\n            this_obj.all_loaded = true;\n            if (this_obj.on_loaded_callback) {\n              this_obj.on_loaded_callback();\n            }\n        }\n    }\n\n    ServiceWorkerTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);\n\n    ServiceWorkerTestEnvironment.prototype.add_on_loaded_callback = function(callback) {\n        if (this.all_loaded) {\n            callback();\n        } else {\n            this.on_loaded_callback = callback;\n        }\n    };\n\n    /*\n     * Shadow realms.\n     * https://github.com/tc39/proposal-shadowrealm\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a shadow realm.\n     */\n    function ShadowRealmTestEnvironment() {\n        WorkerTestEnvironment.call(this);\n        this.all_loaded = false;\n        this.on_loaded_callback = null;\n    }\n\n    ShadowRealmTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);\n\n    /**\n     * Signal to the test environment that the tests are ready and the on-loaded\n     * callback should be run.\n     *\n     * Shadow realms are not *really* a DOM context: they have no `onload` or similar\n     * event for us to use to set up the test environment; so, instead, this method\n     * is manually triggered from the incubating realm\n     *\n     * @param {Function} message_destination - a function that receives JSON-serializable\n     * data to send to the incubating realm, in the same format as used by RemoteContext\n     */\n    ShadowRealmTestEnvironment.prototype.begin = function(message_destination) {\n        if (this.all_loaded) {\n            throw new Error(\"Tried to start a shadow realm test environment after it has already started\");\n        }\n        var fakeMessagePort = {};\n        fakeMessagePort.postMessage = message_destination;\n        this._add_message_port(fakeMessagePort);\n        this.all_loaded = true;\n        if (this.on_loaded_callback) {\n            this.on_loaded_callback();\n        }\n    };\n\n    ShadowRealmTestEnvironment.prototype.add_on_loaded_callback = function(callback) {\n        if (this.all_loaded) {\n            callback();\n        } else {\n            this.on_loaded_callback = callback;\n        }\n    };\n\n    /*\n     * JavaScript shells.\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a JavaScript shell.\n     */\n    function ShellTestEnvironment() {\n        this.name_counter = 0;\n        this.all_loaded = false;\n        this.on_loaded_callback = null;\n        Promise.resolve().then(function() {\n            this.all_loaded = true\n            if (this.on_loaded_callback) {\n                this.on_loaded_callback();\n            }\n        }.bind(this));\n        this.message_list = [];\n        this.message_ports = [];\n    }\n\n    ShellTestEnvironment.prototype.next_default_test_name = function() {\n        var suffix = this.name_counter > 0 ? \" \" + this.name_counter : \"\";\n        this.name_counter++;\n        return get_title() + suffix;\n    };\n\n    ShellTestEnvironment.prototype.on_new_harness_properties = function() {};\n\n    ShellTestEnvironment.prototype.on_tests_ready = function() {};\n\n    ShellTestEnvironment.prototype.add_on_loaded_callback = function(callback) {\n        if (this.all_loaded) {\n            callback();\n        } else {\n            this.on_loaded_callback = callback;\n        }\n    };\n\n    ShellTestEnvironment.prototype.test_timeout = function() {\n        // Tests running in a shell don't have a default timeout, so behave as\n        // if settings.explicit_timeout is true.\n        return null;\n    };\n\n    function create_test_environment() {\n        if ('document' in global_scope) {\n            return new WindowTestEnvironment();\n        }\n        if ('DedicatedWorkerGlobalScope' in global_scope &&\n            global_scope instanceof DedicatedWorkerGlobalScope) {\n            return new DedicatedWorkerTestEnvironment();\n        }\n        if ('SharedWorkerGlobalScope' in global_scope &&\n            global_scope instanceof SharedWorkerGlobalScope) {\n            return new SharedWorkerTestEnvironment();\n        }\n        if ('ServiceWorkerGlobalScope' in global_scope &&\n            global_scope instanceof ServiceWorkerGlobalScope) {\n            return new ServiceWorkerTestEnvironment();\n        }\n        if ('WorkerGlobalScope' in global_scope &&\n            global_scope instanceof WorkerGlobalScope) {\n            return new DedicatedWorkerTestEnvironment();\n        }\n        /* Shadow realm global objects are _ordinary_ objects (i.e. their prototype is\n         * Object) so we don't have a nice `instanceof` test to use; instead, we\n         * check if the there is a GLOBAL.isShadowRealm() property\n         * on the global object. that was set by the test harness when it\n         * created the ShadowRealm.\n         */\n        if (global_scope.GLOBAL && global_scope.GLOBAL.isShadowRealm()) {\n            return new ShadowRealmTestEnvironment();\n        }\n\n        return new ShellTestEnvironment();\n    }\n\n    var test_environment = create_test_environment();\n\n    function is_shared_worker(worker) {\n        return 'SharedWorker' in global_scope && worker instanceof SharedWorker;\n    }\n\n    function is_service_worker(worker) {\n        // The worker object may be from another execution context,\n        // so do not use instanceof here.\n        return 'ServiceWorker' in global_scope &&\n            Object.prototype.toString.call(worker) == '[object ServiceWorker]';\n    }\n\n    var seen_func_name = Object.create(null);\n\n    function get_test_name(func, name)\n    {\n        if (name) {\n            return name;\n        }\n\n        if (func) {\n            var func_code = func.toString();\n\n            // Try and match with brackets, but fallback to matching without\n            var arrow = func_code.match(/^\\(\\)\\s*=>\\s*(?:{(.*)}\\s*|(.*))$/);\n\n            // Check for JS line separators\n            if (arrow !== null && !/[\\u000A\\u000D\\u2028\\u2029]/.test(func_code)) {\n                var trimmed = (arrow[1] !== undefined ? arrow[1] : arrow[2]).trim();\n                // drop trailing ; if there's no earlier ones\n                trimmed = trimmed.replace(/^([^;]*)(;\\s*)+$/, \"$1\");\n\n                if (trimmed) {\n                    let name = trimmed;\n                    if (seen_func_name[trimmed]) {\n                        // This subtest name already exists, so add a suffix.\n                        name += \" \" + seen_func_name[trimmed];\n                    } else {\n                        seen_func_name[trimmed] = 0;\n                    }\n                    seen_func_name[trimmed] += 1;\n                    return name;\n                }\n            }\n        }\n\n        return test_environment.next_default_test_name();\n    }\n\n    /**\n     * @callback TestFunction\n     * @param {Test} test - The test currnetly being run.\n     * @param {Any[]} args - Additional args to pass to function.\n     *\n     */\n\n    /**\n     * Create a synchronous test\n     *\n     * @param {TestFunction} func - Test function. This is executed\n     * immediately. If it returns without error, the test status is\n     * set to ``PASS``. If it throws an :js:class:`AssertionError`, or\n     * any other exception, the test status is set to ``FAIL``\n     * (typically from an `assert` function).\n     * @param {String} name - Test name. This must be unique in a\n     * given file and must be invariant between runs.\n     */\n    function test(func, name, properties)\n    {\n        if (tests.promise_setup_called) {\n            tests.status.status = tests.status.ERROR;\n            tests.status.message = '`test` invoked after `promise_setup`';\n            tests.complete();\n        }\n        var test_name = get_test_name(func, name);\n        var test_obj = new Test(test_name, properties);\n        var value = test_obj.step(func, test_obj, test_obj);\n\n        if (value !== undefined) {\n            var msg = 'Test named \"' + test_name +\n                '\" passed a function to `test` that returned a value.';\n\n            try {\n                if (value && typeof value.then === 'function') {\n                    msg += ' Consider using `promise_test` instead when ' +\n                        'using Promises or async/await.';\n                }\n            } catch (err) {}\n\n            tests.status.status = tests.status.ERROR;\n            tests.status.message = msg;\n        }\n\n        if (test_obj.phase === test_obj.phases.STARTED) {\n            test_obj.done();\n        }\n    }\n\n    /**\n     * Create an asynchronous test\n     *\n     * @param {TestFunction|string} funcOrName - Initial step function\n     * to call immediately with the test name as an argument (if any),\n     * or name of the test.\n     * @param {String} name - Test name (if a test function was\n     * provided). This must be unique in a given file and must be\n     * invariant between runs.\n     * @returns {Test} An object representing the ongoing test.\n     */\n    function async_test(func, name, properties)\n    {\n        if (tests.promise_setup_called) {\n            tests.status.status = tests.status.ERROR;\n            tests.status.message = '`async_test` invoked after `promise_setup`';\n            tests.complete();\n        }\n        if (typeof func !== \"function\") {\n            properties = name;\n            name = func;\n            func = null;\n        }\n        var test_name = get_test_name(func, name);\n        var test_obj = new Test(test_name, properties);\n        if (func) {\n            var value = test_obj.step(func, test_obj, test_obj);\n\n            // Test authors sometimes return values to async_test, expecting us\n            // to handle the value somehow. Make doing so a harness error to be\n            // clear this is invalid, and point authors to promise_test if it\n            // may be appropriate.\n            //\n            // Note that we only perform this check on the initial function\n            // passed to async_test, not on any later steps - we haven't seen a\n            // consistent problem with those (and it's harder to check).\n            if (value !== undefined) {\n                var msg = 'Test named \"' + test_name +\n                    '\" passed a function to `async_test` that returned a value.';\n\n                try {\n                    if (value && typeof value.then === 'function') {\n                        msg += ' Consider using `promise_test` instead when ' +\n                            'using Promises or async/await.';\n                    }\n                } catch (err) {}\n\n                tests.set_status(tests.status.ERROR, msg);\n                tests.complete();\n            }\n        } else {\n            // In his case, the test might not be stepped at all, and it even if it is, only the first START event counts for each test\n            window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"START\", content: {'isSecure': window.isSecureContext, 'wid': window.__id__, 'name': test_name}, ts: Date.now()}}))\n        }\n        return test_obj;\n    }\n\n    /**\n     * Create a promise test.\n     *\n     * Promise tests are tests which are represented by a promise\n     * object. If the promise is fulfilled the test passes, if it's\n     * rejected the test fails, otherwise the test passes.\n     *\n     * @param {TestFunction} func - Test function. This must return a\n     * promise. The test is automatically marked as complete once the\n     * promise settles.\n     * @param {String} name - Test name. This must be unique in a\n     * given file and must be invariant between runs.\n     */\n    function promise_test(func, name, properties) {\n        if (typeof func !== \"function\") {\n            properties = name;\n            name = func;\n            func = null;\n        }\n        var test_name = get_test_name(func, name);\n        var test = new Test(test_name, properties);\n        test._is_promise_test = true;\n\n        // If there is no promise tests queue make one.\n        if (!tests.promise_tests) {\n            tests.promise_tests = Promise.resolve();\n        }\n        tests.promise_tests = tests.promise_tests.then(function() {\n            return new Promise(function(resolve) {\n                var promise = test.step(func, test, test);\n\n                test.step(function() {\n                    assert(!!promise, \"promise_test\", null,\n                           \"test body must return a 'thenable' object (received ${value})\",\n                           {value:promise});\n                    assert(typeof promise.then === \"function\", \"promise_test\", null,\n                           \"test body must return a 'thenable' object (received an object with no `then` method)\",\n                           null);\n                });\n\n                // Test authors may use the `step` method within a\n                // `promise_test` even though this reflects a mixture of\n                // asynchronous control flow paradigms. The \"done\" callback\n                // should be registered prior to the resolution of the\n                // user-provided Promise to avoid timeouts in cases where the\n                // Promise does not settle but a `step` function has thrown an\n                // error.\n                add_test_done_callback(test, resolve);\n\n                Promise.resolve(promise)\n                    .catch(test.step_func(\n                        function(value) {\n                            if (value instanceof AssertionError) {\n                                throw value;\n                            }\n                            assert(false, \"promise_test\", null,\n                                   \"Unhandled rejection with value: ${value}\", {value:value});\n                        }))\n                    .then(function() {\n                        test.done();\n                    });\n                });\n        });\n    }\n\n    /**\n     * Make a copy of a Promise in the current realm.\n     *\n     * @param {Promise} promise the given promise that may be from a different\n     *                          realm\n     * @returns {Promise}\n     *\n     * An arbitrary promise provided by the caller may have originated\n     * in another frame that have since navigated away, rendering the\n     * frame's document inactive. Such a promise cannot be used with\n     * `await` or Promise.resolve(), as microtasks associated with it\n     * may be prevented from being run. See `issue\n     * 5319<https://github.com/whatwg/html/issues/5319>`_ for a\n     * particular case.\n     *\n     * In functions we define here, there is an expectation from the caller\n     * that the promise is from the current realm, that can always be used with\n     * `await`, etc. We therefore create a new promise in this realm that\n     * inherit the value and status from the given promise.\n     */\n\n    function bring_promise_to_current_realm(promise) {\n        return new Promise(promise.then.bind(promise));\n    }\n\n    /**\n     * Assert that a Promise is rejected with the right ECMAScript exception.\n     *\n     * @param {Test} test - the `Test` to use for the assertion.\n     * @param {Function} constructor - The expected exception constructor.\n     * @param {Promise} promise - The promise that's expected to\n     * reject with the given exception.\n     * @param {string} [description] Error message to add to assert in case of\n     *                               failure.\n     */\n    function promise_rejects_js(test, constructor, promise, description) {\n        return bring_promise_to_current_realm(promise)\n            .then(test.unreached_func(\"Should have rejected: \" + description))\n            .catch(function(e) {\n                assert_throws_js_impl(constructor, function() { throw e },\n                                      description, \"promise_rejects_js\");\n            });\n    }\n\n    /**\n     * Assert that a Promise is rejected with the right DOMException.\n     *\n     * For the remaining arguments, there are two ways of calling\n     * promise_rejects_dom:\n     *\n     * 1) If the DOMException is expected to come from the current global, the\n     * third argument should be the promise expected to reject, and a fourth,\n     * optional, argument is the assertion description.\n     *\n     * 2) If the DOMException is expected to come from some other global, the\n     * third argument should be the DOMException constructor from that global,\n     * the fourth argument the promise expected to reject, and the fifth,\n     * optional, argument the assertion description.\n     *\n     * @param {Test} test - the `Test` to use for the assertion.\n     * @param {number|string} type - See documentation for\n     * `assert_throws_dom <#assert_throws_dom>`_.\n     * @param {Function} promiseOrConstructor - Either the constructor\n     * for the expected exception (if the exception comes from another\n     * global), or the promise that's expected to reject (if the\n     * exception comes from the current global).\n     * @param {Function|string} descriptionOrPromise - Either the\n     * promise that's expected to reject (if the exception comes from\n     * another global), or the optional description of the condition\n     * being tested (if the exception comes from the current global).\n     * @param {string} [description] - Description of the condition\n     * being tested (if the exception comes from another global).\n     *\n     */\n    function promise_rejects_dom(test, type, promiseOrConstructor, descriptionOrPromise, maybeDescription) {\n        let constructor, promise, description;\n        if (typeof promiseOrConstructor === \"function\" &&\n            promiseOrConstructor.name === \"DOMException\") {\n            constructor = promiseOrConstructor;\n            promise = descriptionOrPromise;\n            description = maybeDescription;\n        } else {\n            constructor = self.DOMException;\n            promise = promiseOrConstructor;\n            description = descriptionOrPromise;\n            assert(maybeDescription === undefined,\n                   \"Too many args pased to no-constructor version of promise_rejects_dom\");\n        }\n        return bring_promise_to_current_realm(promise)\n            .then(test.unreached_func(\"Should have rejected: \" + description))\n            .catch(function(e) {\n                assert_throws_dom_impl(type, function() { throw e }, description,\n                                       \"promise_rejects_dom\", constructor);\n            });\n    }\n\n    /**\n     * Assert that a Promise is rejected with the provided value.\n     *\n     * @param {Test} test - the `Test` to use for the assertion.\n     * @param {Any} exception - The expected value of the rejected promise.\n     * @param {Promise} promise - The promise that's expected to\n     * reject.\n     * @param {string} [description] Error message to add to assert in case of\n     *                               failure.\n     */\n    function promise_rejects_exactly(test, exception, promise, description) {\n        return bring_promise_to_current_realm(promise)\n            .then(test.unreached_func(\"Should have rejected: \" + description))\n            .catch(function(e) {\n                assert_throws_exactly_impl(exception, function() { throw e },\n                                           description, \"promise_rejects_exactly\");\n            });\n    }\n\n    /**\n     * Allow DOM events to be handled using Promises.\n     *\n     * This can make it a lot easier to test a very specific series of events,\n     * including ensuring that unexpected events are not fired at any point.\n     *\n     * `EventWatcher` will assert if an event occurs while there is no `wait_for`\n     * created Promise waiting to be fulfilled, or if the event is of a different type\n     * to the type currently expected. This ensures that only the events that are\n     * expected occur, in the correct order, and with the correct timing.\n     *\n     * @constructor\n     * @param {Test} test - The `Test` to use for the assertion.\n     * @param {EventTarget} watchedNode - The target expected to receive the events.\n     * @param {string[]} eventTypes - List of events to watch for.\n     * @param {Promise} timeoutPromise - Promise that will cause the\n     * test to be set to `TIMEOUT` once fulfilled.\n     *\n     */\n    function EventWatcher(test, watchedNode, eventTypes, timeoutPromise)\n    {\n        if (typeof eventTypes == 'string') {\n            eventTypes = [eventTypes];\n        }\n\n        var waitingFor = null;\n\n        // This is null unless we are recording all events, in which case it\n        // will be an Array object.\n        var recordedEvents = null;\n\n        var eventHandler = test.step_func(function(evt) {\n            assert_true(!!waitingFor,\n                        'Not expecting event, but got ' + evt.type + ' event');\n            assert_equals(evt.type, waitingFor.types[0],\n                          'Expected ' + waitingFor.types[0] + ' event, but got ' +\n                          evt.type + ' event instead');\n\n            if (Array.isArray(recordedEvents)) {\n                recordedEvents.push(evt);\n            }\n\n            if (waitingFor.types.length > 1) {\n                // Pop first event from array\n                waitingFor.types.shift();\n                return;\n            }\n            // We need to null out waitingFor before calling the resolve function\n            // since the Promise's resolve handlers may call wait_for() which will\n            // need to set waitingFor.\n            var resolveFunc = waitingFor.resolve;\n            waitingFor = null;\n            // Likewise, we should reset the state of recordedEvents.\n            var result = recordedEvents || evt;\n            recordedEvents = null;\n            resolveFunc(result);\n        });\n\n        for (var i = 0; i < eventTypes.length; i++) {\n            watchedNode.addEventListener(eventTypes[i], eventHandler, false);\n        }\n\n        /**\n         * Returns a Promise that will resolve after the specified event or\n         * series of events has occurred.\n         *\n         * @param {Object} options An optional options object. If the 'record' property\n         *                 on this object has the value 'all', when the Promise\n         *                 returned by this function is resolved,  *all* Event\n         *                 objects that were waited for will be returned as an\n         *                 array.\n         *\n         * @example\n         * const watcher = new EventWatcher(t, div, [ 'animationstart',\n         *                                            'animationiteration',\n         *                                            'animationend' ]);\n         * return watcher.wait_for([ 'animationstart', 'animationend' ],\n         *                         { record: 'all' }).then(evts => {\n         *   assert_equals(evts[0].elapsedTime, 0.0);\n         *   assert_equals(evts[1].elapsedTime, 2.0);\n         * });\n         */\n        this.wait_for = function(types, options) {\n            if (waitingFor) {\n                return Promise.reject('Already waiting for an event or events');\n            }\n            if (typeof types == 'string') {\n                types = [types];\n            }\n            if (options && options.record && options.record === 'all') {\n                recordedEvents = [];\n            }\n            return new Promise(function(resolve, reject) {\n                var timeout = test.step_func(function() {\n                    // If the timeout fires after the events have been received\n                    // or during a subsequent call to wait_for, ignore it.\n                    if (!waitingFor || waitingFor.resolve !== resolve)\n                        return;\n\n                    // This should always fail, otherwise we should have\n                    // resolved the promise.\n                    assert_true(waitingFor.types.length == 0,\n                                'Timed out waiting for ' + waitingFor.types.join(', '));\n                    var result = recordedEvents;\n                    recordedEvents = null;\n                    var resolveFunc = waitingFor.resolve;\n                    waitingFor = null;\n                    resolveFunc(result);\n                });\n\n                if (timeoutPromise) {\n                    timeoutPromise().then(timeout);\n                }\n\n                waitingFor = {\n                    types: types,\n                    resolve: resolve,\n                    reject: reject\n                };\n            });\n        };\n\n        /**\n         * Stop listening for events\n         */\n        function stop_watching() {\n            for (var i = 0; i < eventTypes.length; i++) {\n                watchedNode.removeEventListener(eventTypes[i], eventHandler, false);\n            }\n        };\n\n        test._add_cleanup(stop_watching);\n\n        return this;\n    }\n    expose(EventWatcher, 'EventWatcher');\n\n    /**\n     * @typedef {Object} SettingsObject\n     * @property {bool} single_test - Use the single-page-test\n     * mode. In this mode the Document represents a single\n     * `async_test`. Asserts may be used directly without requiring\n     * `Test.step` or similar wrappers, and any exceptions set the\n     * status of the test rather than the status of the harness.\n     * @property {bool} allow_uncaught_exception - don't treat an\n     * uncaught exception as an error; needed when e.g. testing the\n     * `window.onerror` handler.\n     * @property {boolean} explicit_done - Wait for a call to `done()`\n     * before declaring all tests complete (this is always true for\n     * single-page tests).\n     * @property hide_test_state - hide the test state output while\n     * the test is running; This is helpful when the output of the test state\n     * may interfere the test results.\n     * @property {bool} explicit_timeout - disable file timeout; only\n     * stop waiting for results when the `timeout()` function is\n     * called This should typically only be set for manual tests, or\n     * by a test runner that providees its own timeout mechanism.\n     * @property {number} timeout_multiplier - Multiplier to apply to\n     * per-test timeouts. This should only be set by a test runner.\n     * @property {Document} output_document - The document to which\n     * results should be logged. By default this is the current\n     * document but could be an ancestor document in some cases e.g. a\n     * SVG test loaded in an HTML wrapper\n     *\n     */\n\n    /**\n     * Configure the harness\n     *\n     * @param {Function|SettingsObject} funcOrProperties - Either a\n     * setup function to run, or a set of properties. If this is a\n     * function that function is run synchronously. Any exception in\n     * the function will set the overall harness status to `ERROR`.\n     * @param {SettingsObject} maybeProperties - An object containing\n     * the settings to use, if the first argument is a function.\n     *\n     */\n    function setup(func_or_properties, maybe_properties)\n    {\n        var func = null;\n        var properties = {};\n        if (arguments.length === 2) {\n            func = func_or_properties;\n            properties = maybe_properties;\n        } else if (func_or_properties instanceof Function) {\n            func = func_or_properties;\n        } else {\n            properties = func_or_properties;\n        }\n        tests.setup(func, properties);\n        test_environment.on_new_harness_properties(properties);\n    }\n\n    /**\n     * Configure the harness, waiting for a promise to resolve\n     * before running any `promise_test` tests.\n     *\n     * @param {Function} func - Function returning a promise that's\n     * run synchronously. Promise tests are not run until after this\n     * function has resolved.\n     * @param {SettingsObject} [properties] - An object containing\n     * the harness settings to use.\n     *\n     */\n    function promise_setup(func, properties={})\n    {\n        if (typeof func !== \"function\") {\n            tests.set_status(tests.status.ERROR,\n                             \"promise_test invoked without a function\");\n            tests.complete();\n            return;\n        }\n        tests.promise_setup_called = true;\n\n        if (!tests.promise_tests) {\n            tests.promise_tests = Promise.resolve();\n        }\n\n        tests.promise_tests = tests.promise_tests\n            .then(function()\n                  {\n                      var result;\n\n                      tests.setup(null, properties);\n                      result = func();\n                      test_environment.on_new_harness_properties(properties);\n\n                      if (!result || typeof result.then !== \"function\") {\n                          throw \"Non-thenable returned by function passed to `promise_setup`\";\n                      }\n                      return result;\n                  })\n            .catch(function(e)\n                   {\n                       tests.set_status(tests.status.ERROR,\n                                        String(e),\n                                        e && e.stack);\n                       tests.complete();\n                   });\n    }\n\n    /**\n     * Mark test loading as complete.\n     *\n     * Typically this function is called implicitly on page load; it's\n     * only necessary for users to call this when either the\n     * ``explicit_done`` or ``single_page`` properties have been set\n     * via the :js:func:`setup` function.\n     *\n     * For single page tests this marks the test as complete and sets its status.\n     * For other tests, this marks test loading as complete, but doesn't affect ongoing tests.\n     */\n    function done() {\n        if (tests.tests.length === 0) {\n            // `done` is invoked after handling uncaught exceptions, so if the\n            // harness status is already set, the corresponding message is more\n            // descriptive than the generic message defined here.\n            if (tests.status.status === null) {\n                tests.status.status = tests.status.ERROR;\n                tests.status.message = \"done() was called without first defining any tests\";\n            }\n\n            tests.complete();\n            return;\n        }\n        if (tests.file_is_test) {\n            // file is test files never have asynchronous cleanup logic,\n            // meaning the fully-synchronous `done` function can be used here.\n            tests.tests[0].done();\n        }\n        tests.end_wait();\n    }\n\n    /**\n     * @deprecated generate a list of tests from a function and list of arguments\n     *\n     * This is deprecated because it runs all the tests outside of the test functions\n     * and as a result any test throwing an exception will result in no tests being\n     * run. In almost all cases, you should simply call test within the loop you would\n     * use to generate the parameter list array.\n     *\n     * @param {Function} func - The function that will be called for each generated tests.\n     * @param {Any[][]} args - An array of arrays. Each nested array\n     * has the structure `[testName, ...testArgs]`. For each of these nested arrays\n     * array, a test is generated with name `testName` and test function equivalent to\n     * `func(..testArgs)`.\n     */\n    function generate_tests(func, args, properties) {\n        forEach(args, function(x, i)\n                {\n                    var name = x[0];\n                    test(function()\n                         {\n                             func.apply(this, x.slice(1));\n                         },\n                         name,\n                         Array.isArray(properties) ? properties[i] : properties);\n                });\n    }\n\n    /**\n     * @deprecated\n     *\n     * Register a function as a DOM event listener to the\n     * given object for the event bubbling phase.\n     *\n     * @param {EventTarget} object - Event target\n     * @param {string} event - Event name\n     * @param {Function} callback - Event handler.\n     */\n    function on_event(object, event, callback)\n    {\n        object.addEventListener(event, callback, false);\n    }\n\n    /**\n     * Global version of :js:func:`Test.step_timeout` for use in single page tests.\n     *\n     * @param {Function} func - Function to run after the timeout\n     * @param {number} timeout - Time in ms to wait before running the\n     * test step. The actual wait time is ``timeout`` x\n     * ``timeout_multiplier``.\n     */\n    function step_timeout(func, timeout) {\n        var outer_this = this;\n        var args = Array.prototype.slice.call(arguments, 2);\n        return setTimeout(function() {\n            func.apply(outer_this, args);\n        }, timeout * tests.timeout_multiplier);\n    }\n\n    expose(test, 'test');\n    expose(async_test, 'async_test');\n    expose(promise_test, 'promise_test');\n    expose(promise_rejects_js, 'promise_rejects_js');\n    expose(promise_rejects_dom, 'promise_rejects_dom');\n    expose(promise_rejects_exactly, 'promise_rejects_exactly');\n    expose(generate_tests, 'generate_tests');\n    expose(setup, 'setup');\n    expose(promise_setup, 'promise_setup');\n    expose(done, 'done');\n    expose(on_event, 'on_event');\n    expose(step_timeout, 'step_timeout');\n\n    /*\n     * Return a string truncated to the given length, with ... added at the end\n     * if it was longer.\n     */\n    function truncate(s, len)\n    {\n        if (s.length > len) {\n            return s.substring(0, len - 3) + \"...\";\n        }\n        return s;\n    }\n\n    /*\n     * Return true if object is probably a Node object.\n     */\n    function is_node(object)\n    {\n        // I use duck-typing instead of instanceof, because\n        // instanceof doesn't work if the node is from another window (like an\n        // iframe's contentWindow):\n        // http://www.w3.org/Bugs/Public/show_bug.cgi?id=12295\n        try {\n            var has_node_properties = (\"nodeType\" in object &&\n                                       \"nodeName\" in object &&\n                                       \"nodeValue\" in object &&\n                                       \"childNodes\" in object);\n        } catch (e) {\n            // We're probably cross-origin, which means we aren't a node\n            return false;\n        }\n\n        if (has_node_properties) {\n            try {\n                object.nodeType;\n            } catch (e) {\n                // The object is probably Node.prototype or another prototype\n                // object that inherits from it, and not a Node instance.\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    var replacements = {\n        \"0\": \"0\",\n        \"1\": \"x01\",\n        \"2\": \"x02\",\n        \"3\": \"x03\",\n        \"4\": \"x04\",\n        \"5\": \"x05\",\n        \"6\": \"x06\",\n        \"7\": \"x07\",\n        \"8\": \"b\",\n        \"9\": \"t\",\n        \"10\": \"n\",\n        \"11\": \"v\",\n        \"12\": \"f\",\n        \"13\": \"r\",\n        \"14\": \"x0e\",\n        \"15\": \"x0f\",\n        \"16\": \"x10\",\n        \"17\": \"x11\",\n        \"18\": \"x12\",\n        \"19\": \"x13\",\n        \"20\": \"x14\",\n        \"21\": \"x15\",\n        \"22\": \"x16\",\n        \"23\": \"x17\",\n        \"24\": \"x18\",\n        \"25\": \"x19\",\n        \"26\": \"x1a\",\n        \"27\": \"x1b\",\n        \"28\": \"x1c\",\n        \"29\": \"x1d\",\n        \"30\": \"x1e\",\n        \"31\": \"x1f\",\n        \"0xfffd\": \"ufffd\",\n        \"0xfffe\": \"ufffe\",\n        \"0xffff\": \"uffff\",\n    };\n\n    /**\n     * Convert a value to a nice, human-readable string\n     *\n     * When many JavaScript Object values are coerced to a String, the\n     * resulting value will be ``\"[object Object]\"``. This obscures\n     * helpful information, making the coerced value unsuitable for\n     * use in assertion messages, test names, and debugging\n     * statements. `format_value` produces more distinctive string\n     * representations of many kinds of objects, including arrays and\n     * the more important DOM Node types. It also translates String\n     * values containing control characters to include human-readable\n     * representations.\n     *\n     * @example\n     * // \"Document node with 2 children\"\n     * format_value(document);\n     * @example\n     * // \"\\\"foo\\\\uffffbar\\\"\"\n     * format_value(\"foo\\uffffbar\");\n     * @example\n     * // \"[-0, Infinity]\"\n     * format_value([-0, Infinity]);\n     * @param {Any} val - The value to convert to a string.\n     * @returns {string} - A string representation of ``val``, optimised for human readability.\n     */\n    function format_value(val, seen)\n    {\n        if (!seen) {\n            seen = [];\n        }\n        if (typeof val === \"object\" && val !== null) {\n            if (seen.indexOf(val) >= 0) {\n                return \"[...]\";\n            }\n            seen.push(val);\n        }\n        if (Array.isArray(val)) {\n            let output = \"[\";\n            if (val.beginEllipsis !== undefined) {\n                output += \"â¦, \";\n            }\n            output += val.map(function(x) {return format_value(x, seen);}).join(\", \");\n            if (val.endEllipsis !== undefined) {\n                output += \", â¦\";\n            }\n            return output + \"]\";\n        }\n\n        switch (typeof val) {\n        case \"string\":\n            val = val.replace(/\\\\/g, \"\\\\\\\\\");\n            for (var p in replacements) {\n                var replace = \"\\\\\" + replacements[p];\n                val = val.replace(RegExp(String.fromCharCode(p), \"g\"), replace);\n            }\n            return '\"' + val.replace(/\"/g, '\\\\\"') + '\"';\n        case \"boolean\":\n        case \"undefined\":\n            return String(val);\n        case \"number\":\n            // In JavaScript, -0 === 0 and String(-0) == \"0\", so we have to\n            // special-case.\n            if (val === -0 && 1/val === -Infinity) {\n                return \"-0\";\n            }\n            return String(val);\n        case \"object\":\n            if (val === null) {\n                return \"null\";\n            }\n\n            // Special-case Node objects, since those come up a lot in my tests.  I\n            // ignore namespaces.\n            if (is_node(val)) {\n                switch (val.nodeType) {\n                case Node.ELEMENT_NODE:\n                    var ret = \"<\" + val.localName;\n                    for (var i = 0; i < val.attributes.length; i++) {\n                        ret += \" \" + val.attributes[i].name + '=\"' + val.attributes[i].value + '\"';\n                    }\n                    ret += \">\" + val.innerHTML + \"</\" + val.localName + \">\";\n                    return \"Element node \" + truncate(ret, 60);\n                case Node.TEXT_NODE:\n                    return 'Text node \"' + truncate(val.data, 60) + '\"';\n                case Node.PROCESSING_INSTRUCTION_NODE:\n                    return \"ProcessingInstruction node with target \" + format_value(truncate(val.target, 60)) + \" and data \" + format_value(truncate(val.data, 60));\n                case Node.COMMENT_NODE:\n                    return \"Comment node <!--\" + truncate(val.data, 60) + \"-->\";\n                case Node.DOCUMENT_NODE:\n                    return \"Document node with \" + val.childNodes.length + (val.childNodes.length == 1 ? \" child\" : \" children\");\n                case Node.DOCUMENT_TYPE_NODE:\n                    return \"DocumentType node\";\n                case Node.DOCUMENT_FRAGMENT_NODE:\n                    return \"DocumentFragment node with \" + val.childNodes.length + (val.childNodes.length == 1 ? \" child\" : \" children\");\n                default:\n                    return \"Node object of unknown type\";\n                }\n            }\n\n        /* falls through */\n        default:\n            try {\n                return typeof val + ' \"' + truncate(String(val), 1000) + '\"';\n            } catch(e) {\n                return (\"[stringifying object threw \" + String(e) +\n                        \" with type \" + String(typeof e) + \"]\");\n            }\n        }\n    }\n    expose(format_value, \"format_value\");\n\n    /*\n     * Assertions\n     */\n\n    function expose_assert(f, name) {\n        function assert_wrapper(...args) {\n            let status = Test.statuses.TIMEOUT;\n            let stack = null;\n            try {\n                if (settings.debug) {\n                    console.debug(\"ASSERT\", name, tests.current_test && tests.current_test.name, args);\n                }\n                if (tests.output) {\n                    tests.set_assert(name, args);\n                }\n                const rv = f.apply(undefined, args);\n                status = Test.statuses.PASS;\n                return rv;\n            } catch(e) {\n                status = Test.statuses.FAIL;\n                stack = e.stack ? e.stack : null;\n                throw e;\n            } finally {\n                if (tests.output && !stack) {\n                    stack = get_stack();\n                }\n                if (tests.output) {\n                    tests.set_assert_status(status, stack);\n                }\n            }\n        }\n        expose(assert_wrapper, name);\n    }\n\n    /**\n     * Assert that ``actual`` is strictly true\n     *\n     * @param {Any} actual - Value that is asserted to be true\n     * @param {string} [description] - Description of the condition being tested\n     */\n    function assert_true(actual, description)\n    {\n        assert(actual === true, \"assert_true\", description,\n                                \"expected true got ${actual}\", {actual:actual});\n    }\n    expose_assert(assert_true, \"assert_true\");\n\n    /**\n     * Assert that ``actual`` is strictly false\n     *\n     * @param {Any} actual - Value that is asserted to be false\n     * @param {string} [description] - Description of the condition being tested\n     */\n    function assert_false(actual, description)\n    {\n        assert(actual === false, \"assert_false\", description,\n                                 \"expected false got ${actual}\", {actual:actual});\n    }\n    expose_assert(assert_false, \"assert_false\");\n\n    function same_value(x, y) {\n        if (y !== y) {\n            //NaN case\n            return x !== x;\n        }\n        if (x === 0 && y === 0) {\n            //Distinguish +0 and -0\n            return 1/x === 1/y;\n        }\n        return x === y;\n    }\n\n    /**\n     * Assert that ``actual`` is the same value as ``expected``.\n     *\n     * For objects this compares by cobject identity; for primitives\n     * this distinguishes between 0 and -0, and has correct handling\n     * of NaN.\n     *\n     * @param {Any} actual - Test value.\n     * @param {Any} expected - Expected value.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_equals(actual, expected, description)\n    {\n         /*\n          * Test if two primitives are equal or two objects\n          * are the same object\n          */\n        if (typeof actual != typeof expected) {\n            assert(false, \"assert_equals\", description,\n                          \"expected (\" + typeof expected + \") ${expected} but got (\" + typeof actual + \") ${actual}\",\n                          {expected:expected, actual:actual});\n            return;\n        }\n        assert(same_value(actual, expected), \"assert_equals\", description,\n                                             \"expected ${expected} but got ${actual}\",\n                                             {expected:expected, actual:actual});\n    }\n    expose_assert(assert_equals, \"assert_equals\");\n\n    /**\n     * Assert that ``actual`` is not the same value as ``expected``.\n     *\n     * Comparison is as for :js:func:`assert_equals`.\n     *\n     * @param {Any} actual - Test value.\n     * @param {Any} expected - The value ``actual`` is expected to be different to.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_not_equals(actual, expected, description)\n    {\n        assert(!same_value(actual, expected), \"assert_not_equals\", description,\n                                              \"got disallowed value ${actual}\",\n                                              {actual:actual});\n    }\n    expose_assert(assert_not_equals, \"assert_not_equals\");\n\n    /**\n     * Assert that ``expected`` is an array and ``actual`` is one of the members.\n     * This is implemented using ``indexOf``, so doesn't handle NaN or Â±0 correctly.\n     *\n     * @param {Any} actual - Test value.\n     * @param {Array} expected - An array that ``actual`` is expected to\n     * be a member of.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_in_array(actual, expected, description)\n    {\n        assert(expected.indexOf(actual) != -1, \"assert_in_array\", description,\n                                               \"value ${actual} not in array ${expected}\",\n                                               {actual:actual, expected:expected});\n    }\n    expose_assert(assert_in_array, \"assert_in_array\");\n\n    // This function was deprecated in July of 2015.\n    // See https://github.com/web-platform-tests/wpt/issues/2033\n    /**\n     * @deprecated\n     * Recursively compare two objects for equality.\n     *\n     * See `Issue 2033\n     * <https://github.com/web-platform-tests/wpt/issues/2033>`_ for\n     * more information.\n     *\n     * @param {Object} actual - Test value.\n     * @param {Object} expected - Expected value.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_object_equals(actual, expected, description)\n    {\n         assert(typeof actual === \"object\" && actual !== null, \"assert_object_equals\", description,\n                                                               \"value is ${actual}, expected object\",\n                                                               {actual: actual});\n         //This needs to be improved a great deal\n         function check_equal(actual, expected, stack)\n         {\n             stack.push(actual);\n\n             var p;\n             for (p in actual) {\n                 assert(expected.hasOwnProperty(p), \"assert_object_equals\", description,\n                                                    \"unexpected property ${p}\", {p:p});\n\n                 if (typeof actual[p] === \"object\" && actual[p] !== null) {\n                     if (stack.indexOf(actual[p]) === -1) {\n                         check_equal(actual[p], expected[p], stack);\n                     }\n                 } else {\n                     assert(same_value(actual[p], expected[p]), \"assert_object_equals\", description,\n                                                       \"property ${p} expected ${expected} got ${actual}\",\n                                                       {p:p, expected:expected[p], actual:actual[p]});\n                 }\n             }\n             for (p in expected) {\n                 assert(actual.hasOwnProperty(p),\n                        \"assert_object_equals\", description,\n                        \"expected property ${p} missing\", {p:p});\n             }\n             stack.pop();\n         }\n         check_equal(actual, expected, []);\n    }\n    expose_assert(assert_object_equals, \"assert_object_equals\");\n\n    /**\n     * Assert that ``actual`` and ``expected`` are both arrays, and that the array properties of\n     * ``actual`` and ``expected`` are all the same value (as for :js:func:`assert_equals`).\n     *\n     * @param {Array} actual - Test array.\n     * @param {Array} expected - Array that is expected to contain the same values as ``actual``.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_array_equals(actual, expected, description)\n    {\n        const max_array_length = 20;\n        function shorten_array(arr, offset = 0) {\n            // Make \", â¦\" only show up when it would likely reduce the length, not accounting for\n            // fonts.\n            if (arr.length < max_array_length + 2) {\n                return arr;\n            }\n            // By default we want half the elements after the offset and half before\n            // But if that takes us past the end of the array, we have more before, and\n            // if it takes us before the start we have more after.\n            const length_after_offset = Math.floor(max_array_length / 2);\n            let upper_bound = Math.min(length_after_offset + offset, arr.length);\n            const lower_bound = Math.max(upper_bound - max_array_length, 0);\n\n            if (lower_bound === 0) {\n                upper_bound = max_array_length;\n            }\n\n            const output = arr.slice(lower_bound, upper_bound);\n            if (lower_bound > 0) {\n                output.beginEllipsis = true;\n            }\n            if (upper_bound < arr.length) {\n                output.endEllipsis = true;\n            }\n            return output;\n        }\n\n        assert(typeof actual === \"object\" && actual !== null && \"length\" in actual,\n               \"assert_array_equals\", description,\n               \"value is ${actual}, expected array\",\n               {actual:actual});\n        assert(actual.length === expected.length,\n               \"assert_array_equals\", description,\n               \"lengths differ, expected array ${expected} length ${expectedLength}, got ${actual} length ${actualLength}\",\n               {expected:shorten_array(expected, expected.length - 1), expectedLength:expected.length,\n                actual:shorten_array(actual, actual.length - 1), actualLength:actual.length\n               });\n\n        for (var i = 0; i < actual.length; i++) {\n            assert(actual.hasOwnProperty(i) === expected.hasOwnProperty(i),\n                   \"assert_array_equals\", description,\n                   \"expected property ${i} to be ${expected} but was ${actual} (expected array ${arrayExpected} got ${arrayActual})\",\n                   {i:i, expected:expected.hasOwnProperty(i) ? \"present\" : \"missing\",\n                    actual:actual.hasOwnProperty(i) ? \"present\" : \"missing\",\n                    arrayExpected:shorten_array(expected, i), arrayActual:shorten_array(actual, i)});\n            assert(same_value(expected[i], actual[i]),\n                   \"assert_array_equals\", description,\n                   \"expected property ${i} to be ${expected} but got ${actual} (expected array ${arrayExpected} got ${arrayActual})\",\n                   {i:i, expected:expected[i], actual:actual[i],\n                    arrayExpected:shorten_array(expected, i), arrayActual:shorten_array(actual, i)});\n        }\n    }\n    expose_assert(assert_array_equals, \"assert_array_equals\");\n\n    /**\n     * Assert that each array property in ``actual`` is a number within\n     * Â± `epsilon` of the corresponding property in `expected`.\n     *\n     * @param {Array} actual - Array of test values.\n     * @param {Array} expected - Array of values expected to be close to the values in ``actual``.\n     * @param {number} epsilon - Magnitude of allowed difference\n     * between each value in ``actual`` and ``expected``.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_array_approx_equals(actual, expected, epsilon, description)\n    {\n        /*\n         * Test if two primitive arrays are equal within +/- epsilon\n         */\n        assert(actual.length === expected.length,\n               \"assert_array_approx_equals\", description,\n               \"lengths differ, expected ${expected} got ${actual}\",\n               {expected:expected.length, actual:actual.length});\n\n        for (var i = 0; i < actual.length; i++) {\n            assert(actual.hasOwnProperty(i) === expected.hasOwnProperty(i),\n                   \"assert_array_approx_equals\", description,\n                   \"property ${i}, property expected to be ${expected} but was ${actual}\",\n                   {i:i, expected:expected.hasOwnProperty(i) ? \"present\" : \"missing\",\n                    actual:actual.hasOwnProperty(i) ? \"present\" : \"missing\"});\n            assert(typeof actual[i] === \"number\",\n                   \"assert_array_approx_equals\", description,\n                   \"property ${i}, expected a number but got a ${type_actual}\",\n                   {i:i, type_actual:typeof actual[i]});\n            assert(Math.abs(actual[i] - expected[i]) <= epsilon,\n                   \"assert_array_approx_equals\", description,\n                   \"property ${i}, expected ${expected} +/- ${epsilon}, expected ${expected} but got ${actual}\",\n                   {i:i, expected:expected[i], actual:actual[i], epsilon:epsilon});\n        }\n    }\n    expose_assert(assert_array_approx_equals, \"assert_array_approx_equals\");\n\n    /**\n     * Assert that ``actual`` is within Â± ``epsilon`` of ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Value number is expected to be close to.\n     * @param {number} epsilon - Magnitude of allowed difference between ``actual`` and ``expected``.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_approx_equals(actual, expected, epsilon, description)\n    {\n        /*\n         * Test if two primitive numbers are equal within +/- epsilon\n         */\n        assert(typeof actual === \"number\",\n               \"assert_approx_equals\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        // The epsilon math below does not place nice with NaN and Infinity\n        // But in this case Infinity = Infinity and NaN = NaN\n        if (isFinite(actual) || isFinite(expected)) {\n            assert(Math.abs(actual - expected) <= epsilon,\n                   \"assert_approx_equals\", description,\n                   \"expected ${expected} +/- ${epsilon} but got ${actual}\",\n                   {expected:expected, actual:actual, epsilon:epsilon});\n        } else {\n            assert_equals(actual, expected);\n        }\n    }\n    expose_assert(assert_approx_equals, \"assert_approx_equals\");\n\n    /**\n     * Assert that ``actual`` is a number less than ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Number that ``actual`` must be less than.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_less_than(actual, expected, description)\n    {\n        /*\n         * Test if a primitive number is less than another\n         */\n        assert(typeof actual === \"number\",\n               \"assert_less_than\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual < expected,\n               \"assert_less_than\", description,\n               \"expected a number less than ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_less_than, \"assert_less_than\");\n\n    /**\n     * Assert that ``actual`` is a number greater than ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Number that ``actual`` must be greater than.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_greater_than(actual, expected, description)\n    {\n        /*\n         * Test if a primitive number is greater than another\n         */\n        assert(typeof actual === \"number\",\n               \"assert_greater_than\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual > expected,\n               \"assert_greater_than\", description,\n               \"expected a number greater than ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_greater_than, \"assert_greater_than\");\n\n    /**\n     * Assert that ``actual`` is a number greater than ``lower`` and less\n     * than ``upper`` but not equal to either.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} lower - Number that ``actual`` must be greater than.\n     * @param {number} upper - Number that ``actual`` must be less than.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_between_exclusive(actual, lower, upper, description)\n    {\n        /*\n         * Test if a primitive number is between two others\n         */\n        assert(typeof actual === \"number\",\n               \"assert_between_exclusive\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual > lower && actual < upper,\n               \"assert_between_exclusive\", description,\n               \"expected a number greater than ${lower} \" +\n               \"and less than ${upper} but got ${actual}\",\n               {lower:lower, upper:upper, actual:actual});\n    }\n    expose_assert(assert_between_exclusive, \"assert_between_exclusive\");\n\n    /**\n     * Assert that ``actual`` is a number less than or equal to ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Number that ``actual`` must be less\n     * than or equal to.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_less_than_equal(actual, expected, description)\n    {\n        /*\n         * Test if a primitive number is less than or equal to another\n         */\n        assert(typeof actual === \"number\",\n               \"assert_less_than_equal\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual <= expected,\n               \"assert_less_than_equal\", description,\n               \"expected a number less than or equal to ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_less_than_equal, \"assert_less_than_equal\");\n\n    /**\n     * Assert that ``actual`` is a number greater than or equal to ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Number that ``actual`` must be greater\n     * than or equal to.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_greater_than_equal(actual, expected, description)\n    {\n        /*\n         * Test if a primitive number is greater than or equal to another\n         */\n        assert(typeof actual === \"number\",\n               \"assert_greater_than_equal\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual >= expected,\n               \"assert_greater_than_equal\", description,\n               \"expected a number greater than or equal to ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_greater_than_equal, \"assert_greater_than_equal\");\n\n    /**\n     * Assert that ``actual`` is a number greater than or equal to ``lower`` and less\n     * than or equal to ``upper``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} lower - Number that ``actual`` must be greater than or equal to.\n     * @param {number} upper - Number that ``actual`` must be less than or equal to.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_between_inclusive(actual, lower, upper, description)\n    {\n        /*\n         * Test if a primitive number is between to two others or equal to either of them\n         */\n        assert(typeof actual === \"number\",\n               \"assert_between_inclusive\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual >= lower && actual <= upper,\n               \"assert_between_inclusive\", description,\n               \"expected a number greater than or equal to ${lower} \" +\n               \"and less than or equal to ${upper} but got ${actual}\",\n               {lower:lower, upper:upper, actual:actual});\n    }\n    expose_assert(assert_between_inclusive, \"assert_between_inclusive\");\n\n    /**\n     * Assert that ``actual`` matches the RegExp ``expected``.\n     *\n     * @param {String} actual - Test string.\n     * @param {RegExp} expected - RegExp ``actual`` must match.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_regexp_match(actual, expected, description) {\n        /*\n         * Test if a string (actual) matches a regexp (expected)\n         */\n        assert(expected.test(actual),\n               \"assert_regexp_match\", description,\n               \"expected ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_regexp_match, \"assert_regexp_match\");\n\n    /**\n     * Assert that the class string of ``object`` as returned in\n     * ``Object.prototype.toString`` is equal to ``class_name``.\n     *\n     * @param {Object} object - Object to stringify.\n     * @param {string} class_string - Expected class string for ``object``.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_class_string(object, class_string, description) {\n        var actual = {}.toString.call(object);\n        var expected = \"[object \" + class_string + \"]\";\n        assert(same_value(actual, expected), \"assert_class_string\", description,\n                                             \"expected ${expected} but got ${actual}\",\n                                             {expected:expected, actual:actual});\n    }\n    expose_assert(assert_class_string, \"assert_class_string\");\n\n    /**\n     * Assert that ``object`` has an own property with name ``property_name``.\n     *\n     * @param {Object} object - Object that should have the given property.\n     * @param {string} property_name - Expected property name.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_own_property(object, property_name, description) {\n        assert(object.hasOwnProperty(property_name),\n               \"assert_own_property\", description,\n               \"expected property ${p} missing\", {p:property_name});\n    }\n    expose_assert(assert_own_property, \"assert_own_property\");\n\n    /**\n     * Assert that ``object`` does not have an own property with name ``property_name``.\n     *\n     * @param {Object} object - Object that should not have the given property.\n     * @param {string} property_name - Property name to test.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_not_own_property(object, property_name, description) {\n        assert(!object.hasOwnProperty(property_name),\n               \"assert_not_own_property\", description,\n               \"unexpected property ${p} is found on object\", {p:property_name});\n    }\n    expose_assert(assert_not_own_property, \"assert_not_own_property\");\n\n    function _assert_inherits(name) {\n        return function (object, property_name, description)\n        {\n            assert((typeof object === \"object\" && object !== null) ||\n                   typeof object === \"function\" ||\n                   // Or has [[IsHTMLDDA]] slot\n                   String(object) === \"[object HTMLAllCollection]\",\n                   name, description,\n                   \"provided value is not an object\");\n\n            assert(\"hasOwnProperty\" in object,\n                   name, description,\n                   \"provided value is an object but has no hasOwnProperty method\");\n\n            assert(!object.hasOwnProperty(property_name),\n                   name, description,\n                   \"property ${p} found on object expected in prototype chain\",\n                   {p:property_name});\n\n            assert(property_name in object,\n                   name, description,\n                   \"property ${p} not found in prototype chain\",\n                   {p:property_name});\n        };\n    }\n\n    /**\n     * Assert that ``object`` does not have an own property with name\n     * ``property_name``, but inherits one through the prototype chain.\n     *\n     * @param {Object} object - Object that should have the given property in its prototype chain.\n     * @param {string} property_name - Expected property name.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_inherits(object, property_name, description) {\n        return _assert_inherits(\"assert_inherits\")(object, property_name, description);\n    }\n    expose_assert(assert_inherits, \"assert_inherits\");\n\n    /**\n     * Alias for :js:func:`insert_inherits`.\n     *\n     * @param {Object} object - Object that should have the given property in its prototype chain.\n     * @param {string} property_name - Expected property name.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_idl_attribute(object, property_name, description) {\n        return _assert_inherits(\"assert_idl_attribute\")(object, property_name, description);\n    }\n    expose_assert(assert_idl_attribute, \"assert_idl_attribute\");\n\n\n    /**\n     * Assert that ``object`` has a property named ``property_name`` and that the property is readonly.\n     *\n     * Note: The implementation tries to update the named property, so\n     * any side effects of updating will be triggered. Users are\n     * encouraged to instead inspect the property descriptor of ``property_name`` on ``object``.\n     *\n     * @param {Object} object - Object that should have the given property in its prototype chain.\n     * @param {string} property_name - Expected property name.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_readonly(object, property_name, description)\n    {\n         var initial_value = object[property_name];\n         try {\n             //Note that this can have side effects in the case where\n             //the property has PutForwards\n             object[property_name] = initial_value + \"a\"; //XXX use some other value here?\n             assert(same_value(object[property_name], initial_value),\n                    \"assert_readonly\", description,\n                    \"changing property ${p} succeeded\",\n                    {p:property_name});\n         } finally {\n             object[property_name] = initial_value;\n         }\n    }\n    expose_assert(assert_readonly, \"assert_readonly\");\n\n    /**\n     * Assert a JS Error with the expected constructor is thrown.\n     *\n     * @param {object} constructor The expected exception constructor.\n     * @param {Function} func Function which should throw.\n     * @param {string} [description] Error description for the case that the error is not thrown.\n     */\n    function assert_throws_js(constructor, func, description)\n    {\n        assert_throws_js_impl(constructor, func, description,\n                              \"assert_throws_js\");\n    }\n    expose_assert(assert_throws_js, \"assert_throws_js\");\n\n    /**\n     * Like assert_throws_js but allows specifying the assertion type\n     * (assert_throws_js or promise_rejects_js, in practice).\n     */\n    function assert_throws_js_impl(constructor, func, description,\n                                   assertion_type)\n    {\n        try {\n            func.call(this);\n            assert(false, assertion_type, description,\n                   \"${func} did not throw\", {func:func});\n        } catch (e) {\n            if (e instanceof AssertionError) {\n                throw e;\n            }\n\n            // Basic sanity-checks on the thrown exception.\n            assert(typeof e === \"object\",\n                   assertion_type, description,\n                   \"${func} threw ${e} with type ${type}, not an object\",\n                   {func:func, e:e, type:typeof e});\n\n            assert(e !== null,\n                   assertion_type, description,\n                   \"${func} threw null, not an object\",\n                   {func:func});\n\n            // Basic sanity-check on the passed-in constructor\n            assert(typeof constructor == \"function\",\n                   assertion_type, description,\n                   \"${constructor} is not a constructor\",\n                   {constructor:constructor});\n            var obj = constructor;\n            while (obj) {\n                if (typeof obj === \"function\" &&\n                    obj.name === \"Error\") {\n                    break;\n                }\n                obj = Object.getPrototypeOf(obj);\n            }\n            assert(obj != null,\n                   assertion_type, description,\n                   \"${constructor} is not an Error subtype\",\n                   {constructor:constructor});\n\n            // And checking that our exception is reasonable\n            assert(e.constructor === constructor &&\n                   e.name === constructor.name,\n                   assertion_type, description,\n                   \"${func} threw ${actual} (${actual_name}) expected instance of ${expected} (${expected_name})\",\n                   {func:func, actual:e, actual_name:e.name,\n                    expected:constructor,\n                    expected_name:constructor.name});\n        }\n    }\n\n    // TODO: Figure out how to document the overloads better.\n    // sphinx-js doesn't seem to handle @variation correctly,\n    // and only expects a single JSDoc entry per function.\n    /**\n     * Assert a DOMException with the expected type is thrown.\n     *\n     * There are two ways of calling assert_throws_dom:\n     *\n     * 1) If the DOMException is expected to come from the current global, the\n     * second argument should be the function expected to throw and a third,\n     * optional, argument is the assertion description.\n     *\n     * 2) If the DOMException is expected to come from some other global, the\n     * second argument should be the DOMException constructor from that global,\n     * the third argument the function expected to throw, and the fourth, optional,\n     * argument the assertion description.\n     *\n     * @param {number|string} type - The expected exception name or\n     * code.  See the `table of names and codes\n     * <https://webidl.spec.whatwg.org/#dfn-error-names-table>`_. If a\n     * number is passed it should be one of the numeric code values in\n     * that table (e.g. 3, 4, etc).  If a string is passed it can\n     * either be an exception name (e.g. \"HierarchyRequestError\",\n     * \"WrongDocumentError\") or the name of the corresponding error\n     * code (e.g. \"``HIERARCHY_REQUEST_ERR``\", \"``WRONG_DOCUMENT_ERR``\").\n     * @param {Function} descriptionOrFunc - The function expected to\n     * throw (if the exception comes from another global), or the\n     * optional description of the condition being tested (if the\n     * exception comes from the current global).\n     * @param {string} [description] - Description of the condition\n     * being tested (if the exception comes from another global).\n     *\n     */\n    function assert_throws_dom(type, funcOrConstructor, descriptionOrFunc, maybeDescription)\n    {\n        let constructor, func, description;\n        if (funcOrConstructor.name === \"DOMException\") {\n            constructor = funcOrConstructor;\n            func = descriptionOrFunc;\n            description = maybeDescription;\n        } else {\n            constructor = self.DOMException;\n            func = funcOrConstructor;\n            description = descriptionOrFunc;\n            assert(maybeDescription === undefined,\n                   \"Too many args pased to no-constructor version of assert_throws_dom\");\n        }\n        assert_throws_dom_impl(type, func, description, \"assert_throws_dom\", constructor)\n    }\n    expose_assert(assert_throws_dom, \"assert_throws_dom\");\n\n    /**\n     * Similar to assert_throws_dom but allows specifying the assertion type\n     * (assert_throws_dom or promise_rejects_dom, in practice).  The\n     * \"constructor\" argument must be the DOMException constructor from the\n     * global we expect the exception to come from.\n     */\n    function assert_throws_dom_impl(type, func, description, assertion_type, constructor)\n    {\n        try {\n            func.call(this);\n            assert(false, assertion_type, description,\n                   \"${func} did not throw\", {func:func});\n        } catch (e) {\n            if (e instanceof AssertionError) {\n                throw e;\n            }\n\n            // Basic sanity-checks on the thrown exception.\n            assert(typeof e === \"object\",\n                   assertion_type, description,\n                   \"${func} threw ${e} with type ${type}, not an object\",\n                   {func:func, e:e, type:typeof e});\n\n            assert(e !== null,\n                   assertion_type, description,\n                   \"${func} threw null, not an object\",\n                   {func:func});\n\n            // Sanity-check our type\n            assert(typeof type == \"number\" ||\n                   typeof type == \"string\",\n                   assertion_type, description,\n                   \"${type} is not a number or string\",\n                   {type:type});\n\n            var codename_name_map = {\n                INDEX_SIZE_ERR: 'IndexSizeError',\n                HIERARCHY_REQUEST_ERR: 'HierarchyRequestError',\n                WRONG_DOCUMENT_ERR: 'WrongDocumentError',\n                INVALID_CHARACTER_ERR: 'InvalidCharacterError',\n                NO_MODIFICATION_ALLOWED_ERR: 'NoModificationAllowedError',\n                NOT_FOUND_ERR: 'NotFoundError',\n                NOT_SUPPORTED_ERR: 'NotSupportedError',\n                INUSE_ATTRIBUTE_ERR: 'InUseAttributeError',\n                INVALID_STATE_ERR: 'InvalidStateError',\n                SYNTAX_ERR: 'SyntaxError',\n                INVALID_MODIFICATION_ERR: 'InvalidModificationError',\n                NAMESPACE_ERR: 'NamespaceError',\n                INVALID_ACCESS_ERR: 'InvalidAccessError',\n                TYPE_MISMATCH_ERR: 'TypeMismatchError',\n                SECURITY_ERR: 'SecurityError',\n                NETWORK_ERR: 'NetworkError',\n                ABORT_ERR: 'AbortError',\n                URL_MISMATCH_ERR: 'URLMismatchError',\n                QUOTA_EXCEEDED_ERR: 'QuotaExceededError',\n                TIMEOUT_ERR: 'TimeoutError',\n                INVALID_NODE_TYPE_ERR: 'InvalidNodeTypeError',\n                DATA_CLONE_ERR: 'DataCloneError'\n            };\n\n            var name_code_map = {\n                IndexSizeError: 1,\n                HierarchyRequestError: 3,\n                WrongDocumentError: 4,\n                InvalidCharacterError: 5,\n                NoModificationAllowedError: 7,\n                NotFoundError: 8,\n                NotSupportedError: 9,\n                InUseAttributeError: 10,\n                InvalidStateError: 11,\n                SyntaxError: 12,\n                InvalidModificationError: 13,\n                NamespaceError: 14,\n                InvalidAccessError: 15,\n                TypeMismatchError: 17,\n                SecurityError: 18,\n                NetworkError: 19,\n                AbortError: 20,\n                URLMismatchError: 21,\n                QuotaExceededError: 22,\n                TimeoutError: 23,\n                InvalidNodeTypeError: 24,\n                DataCloneError: 25,\n\n                EncodingError: 0,\n                NotReadableError: 0,\n                UnknownError: 0,\n                ConstraintError: 0,\n                DataError: 0,\n                TransactionInactiveError: 0,\n                ReadOnlyError: 0,\n                VersionError: 0,\n                OperationError: 0,\n                NotAllowedError: 0,\n                OptOutError: 0\n            };\n\n            var code_name_map = {};\n            for (var key in name_code_map) {\n                if (name_code_map[key] > 0) {\n                    code_name_map[name_code_map[key]] = key;\n                }\n            }\n\n            var required_props = {};\n            var name;\n\n            if (typeof type === \"number\") {\n                if (type === 0) {\n                    throw new AssertionError('Test bug: ambiguous DOMException code 0 passed to assert_throws_dom()');\n                } else if (!(type in code_name_map)) {\n                    throw new AssertionError('Test bug: unrecognized DOMException code \"' + type + '\" passed to assert_throws_dom()');\n                }\n                name = code_name_map[type];\n                required_props.code = type;\n            } else if (typeof type === \"string\") {\n                name = type in codename_name_map ? codename_name_map[type] : type;\n                if (!(name in name_code_map)) {\n                    throw new AssertionError('Test bug: unrecognized DOMException code name or name \"' + type + '\" passed to assert_throws_dom()');\n                }\n\n                required_props.code = name_code_map[name];\n            }\n\n            if (required_props.code === 0 ||\n               (\"name\" in e &&\n                e.name !== e.name.toUpperCase() &&\n                e.name !== \"DOMException\")) {\n                // New style exception: also test the name property.\n                required_props.name = name;\n            }\n\n            for (var prop in required_props) {\n                assert(prop in e && e[prop] == required_props[prop],\n                       assertion_type, description,\n                       \"${func} threw ${e} that is not a DOMException \" + type + \": property ${prop} is equal to ${actual}, expected ${expected}\",\n                       {func:func, e:e, prop:prop, actual:e[prop], expected:required_props[prop]});\n            }\n\n            // Check that the exception is from the right global.  This check is last\n            // so more specific, and more informative, checks on the properties can\n            // happen in case a totally incorrect exception is thrown.\n            assert(e.constructor === constructor,\n                   assertion_type, description,\n                   \"${func} threw an exception from the wrong global\",\n                   {func});\n\n        }\n    }\n\n    /**\n     * Assert the provided value is thrown.\n     *\n     * @param {value} exception The expected exception.\n     * @param {Function} func Function which should throw.\n     * @param {string} [description] Error description for the case that the error is not thrown.\n     */\n    function assert_throws_exactly(exception, func, description)\n    {\n        assert_throws_exactly_impl(exception, func, description,\n                                   \"assert_throws_exactly\");\n    }\n    expose_assert(assert_throws_exactly, \"assert_throws_exactly\");\n\n    /**\n     * Like assert_throws_exactly but allows specifying the assertion type\n     * (assert_throws_exactly or promise_rejects_exactly, in practice).\n     */\n    function assert_throws_exactly_impl(exception, func, description,\n                                        assertion_type)\n    {\n        try {\n            func.call(this);\n            assert(false, assertion_type, description,\n                   \"${func} did not throw\", {func:func});\n        } catch (e) {\n            if (e instanceof AssertionError) {\n                throw e;\n            }\n\n            assert(same_value(e, exception), assertion_type, description,\n                   \"${func} threw ${e} but we expected it to throw ${exception}\",\n                   {func:func, e:e, exception:exception});\n        }\n    }\n\n    /**\n     * Asserts if called. Used to ensure that a specific codepath is\n     * not taken e.g. that an error event isn't fired.\n     *\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_unreached(description) {\n         assert(false, \"assert_unreached\", description,\n                \"Reached unreachable code\");\n    }\n    expose_assert(assert_unreached, \"assert_unreached\");\n\n    /**\n     * @callback AssertFunc\n     * @param {Any} actual\n     * @param {Any} expected\n     * @param {Any[]} args\n     */\n\n    /**\n     * Asserts that ``actual`` matches at least one value of ``expected``\n     * according to a comparison defined by ``assert_func``.\n     *\n     * Note that tests with multiple allowed pass conditions are bad\n     * practice unless the spec specifically allows multiple\n     * behaviours. Test authors should not use this method simply to\n     * hide UA bugs.\n     *\n     * @param {AssertFunc} assert_func - Function to compare actual\n     * and expected. It must throw when the comparison fails and\n     * return when the comparison passes.\n     * @param {Any} actual - Test value.\n     * @param {Array} expected_array - Array of possible expected values.\n     * @param {Any[]} args - Additional arguments to pass to ``assert_func``.\n     */\n    function assert_any(assert_func, actual, expected_array, ...args)\n    {\n        var errors = [];\n        var passed = false;\n        forEach(expected_array,\n                function(expected)\n                {\n                    try {\n                        assert_func.apply(this, [actual, expected].concat(args));\n                        passed = true;\n                    } catch (e) {\n                        errors.push(e.message);\n                    }\n                });\n        if (!passed) {\n            throw new AssertionError(errors.join(\"\\n\\n\"));\n        }\n    }\n    // FIXME: assert_any cannot use expose_assert, because assert_wrapper does\n    // not support nested assert calls (e.g. to assert_func). We need to\n    // support bypassing assert_wrapper for the inner asserts here.\n    expose(assert_any, \"assert_any\");\n\n    /**\n     * Assert that a feature is implemented, based on a 'truthy' condition.\n     *\n     * This function should be used to early-exit from tests in which there is\n     * no point continuing without support for a non-optional spec or spec\n     * feature. For example:\n     *\n     *     assert_implements(window.Foo, 'Foo is not supported');\n     *\n     * @param {object} condition The truthy value to test\n     * @param {string} [description] Error description for the case that the condition is not truthy.\n     */\n    function assert_implements(condition, description) {\n        assert(!!condition, \"assert_implements\", description);\n    }\n    expose_assert(assert_implements, \"assert_implements\")\n\n    /**\n     * Assert that an optional feature is implemented, based on a 'truthy' condition.\n     *\n     * This function should be used to early-exit from tests in which there is\n     * no point continuing without support for an explicitly optional spec or\n     * spec feature. For example:\n     *\n     *     assert_implements_optional(video.canPlayType(\"video/webm\"),\n     *                                \"webm video playback not supported\");\n     *\n     * @param {object} condition The truthy value to test\n     * @param {string} [description] Error description for the case that the condition is not truthy.\n     */\n    function assert_implements_optional(condition, description) {\n        if (!condition) {\n            throw new OptionalFeatureUnsupportedError(description);\n        }\n    }\n    expose_assert(assert_implements_optional, \"assert_implements_optional\");\n\n    /**\n     * @class\n     *\n     * A single subtest. A Test is not constructed directly but via the\n     * :js:func:`test`, :js:func:`async_test` or :js:func:`promise_test` functions.\n     *\n     * @param {string} name - This must be unique in a given file and must be\n     * invariant between runs.\n     *\n     */\n    function Test(name, properties)\n    {\n        if (tests.file_is_test && tests.tests.length) {\n            throw new Error(\"Tried to create a test with file_is_test\");\n        }\n        /** The test name. */\n        this.name = name;\n\n        this.phase = (tests.is_aborted || tests.phase === tests.phases.COMPLETE) ?\n            this.phases.COMPLETE : this.phases.INITIAL;\n\n        /** The test status code.*/\n        this.status = this.NOTRUN;\n        this.timeout_id = null;\n        this.index = null;\n\n        this.properties = properties || {};\n        this.timeout_length = settings.test_timeout;\n        if (this.timeout_length !== null) {\n            this.timeout_length *= tests.timeout_multiplier;\n        }\n\n        /** A message indicating the reason for test failure. */\n        this.message = null;\n        /** Stack trace in case of failure. */\n        this.stack = null;\n\n        this.steps = [];\n        this._is_promise_test = false;\n\n        this.cleanup_callbacks = [];\n        this._user_defined_cleanup_count = 0;\n        this._done_callbacks = [];\n\n        if (typeof AbortController === \"function\") {\n            this._abortController = new AbortController();\n        }\n\n        // Tests declared following harness completion are likely an indication\n        // of a programming error, but they cannot be reported\n        // deterministically.\n        if (tests.phase === tests.phases.COMPLETE) {\n            return;\n        }\n\n        tests.push(this);\n    }\n\n    /**\n     * Enum of possible test statuses.\n     *\n     * :values:\n     *   - ``PASS``\n     *   - ``FAIL``\n     *   - ``TIMEOUT``\n     *   - ``NOTRUN``\n     *   - ``PRECONDITION_FAILED``\n     */\n    Test.statuses = {\n        PASS:0,\n        FAIL:1,\n        TIMEOUT:2,\n        NOTRUN:3,\n        PRECONDITION_FAILED:4\n    };\n\n    Test.prototype = merge({}, Test.statuses);\n\n    Test.prototype.phases = {\n        INITIAL:0,\n        STARTED:1,\n        HAS_RESULT:2,\n        CLEANING:3,\n        COMPLETE:4\n    };\n\n    Test.prototype.status_formats = {\n        0: \"Pass\",\n        1: \"Fail\",\n        2: \"Timeout\",\n        3: \"Not Run\",\n        4: \"Optional Feature Unsupported\",\n    }\n\n    Test.prototype.format_status = function() {\n        return this.status_formats[this.status];\n    }\n\n    Test.prototype.structured_clone = function()\n    {\n        if (!this._structured_clone) {\n            var msg = this.message;\n            msg = msg ? String(msg) : msg;\n            this._structured_clone = merge({\n                name:String(this.name),\n                properties:merge({}, this.properties),\n                phases:merge({}, this.phases)\n            }, Test.statuses);\n        }\n        this._structured_clone.status = this.status;\n        this._structured_clone.message = this.message;\n        this._structured_clone.stack = this.stack;\n        this._structured_clone.index = this.index;\n        this._structured_clone.phase = this.phase;\n        return this._structured_clone;\n    };\n\n    /**\n     * Run a single step of an ongoing test.\n     *\n     * @param {string} func - Callback function to run as a step. If\n     * this throws an :js:func:`AssertionError`, or any other\n     * exception, the :js:class:`Test` status is set to ``FAIL``.\n     * @param {Object} [this_obj] - The object to use as the this\n     * value when calling ``func``. Defaults to the  :js:class:`Test` object.\n     */\n    Test.prototype.step = function(func, this_obj)\n    {\n        if (this.phase > this.phases.STARTED) {\n            return;\n        }\n\n        if (this.phase !== this.phases.STARTED) {\n            console.log(`[${Date.now()}] prototype.step START`)\n            window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"START\", content: {'isSecure': window.isSecureContext, 'wid': window.__id__, 'name': this.name}, ts: Date.now()}}))\n            console.log(\"LOG\", window)\n        }\n\n        if (settings.debug && this.phase !== this.phases.STARTED) {\n            console.log(\"TEST START\", this.name);\n        }\n        this.phase = this.phases.STARTED;\n        //If we don't get a result before the harness times out that will be a test timeout\n        this.set_status(this.TIMEOUT, \"Test timed out\");\n\n        tests.started = true;\n        tests.current_test = this;\n        tests.notify_test_state(this);\n\n        if (this.timeout_id === null) {\n            this.set_timeout();\n        }\n\n        this.steps.push(func);\n\n        if (arguments.length === 1) {\n            this_obj = this;\n        }\n\n        if (settings.debug) {\n            console.debug(\"TEST STEP\", this.name);\n        }\n\n        try {\n            return func.apply(this_obj, Array.prototype.slice.call(arguments, 2));\n        } catch (e) {\n            if (this.phase >= this.phases.HAS_RESULT) {\n                return;\n            }\n            var status = e instanceof OptionalFeatureUnsupportedError ? this.PRECONDITION_FAILED : this.FAIL;\n            var message = String((typeof e === \"object\" && e !== null) ? e.message : e);\n            var stack = e.stack ? e.stack : null;\n\n            this.set_status(status, message, stack);\n            this.phase = this.phases.HAS_RESULT;\n            this.done();\n        } finally {\n            this.current_test = null;\n        }\n    };\n\n    /**\n     * Wrap a function so that it runs as a step of the current test.\n     *\n     * This allows creating a callback function that will run as a\n     * test step.\n     *\n     * @example\n     * let t = async_test(\"Example\");\n     * onload = t.step_func(e => {\n     *   assert_equals(e.name, \"load\");\n     *   // Mark the test as complete.\n     *   t.done();\n     * })\n     *\n     * @param {string} func - Function to run as a step. If this\n     * throws an :js:func:`AssertionError`, or any other exception,\n     * the :js:class:`Test` status is set to ``FAIL``.\n     * @param {Object} [this_obj] - The object to use as the this\n     * value when calling ``func``. Defaults to the :js:class:`Test` object.\n     */\n    Test.prototype.step_func = function(func, this_obj)\n    {\n        var test_this = this;\n\n        if (arguments.length === 1) {\n            this_obj = test_this;\n        }\n\n        return function()\n        {\n            // console.log(\"ARGS\", arguments[0])Vjj\n            // console.log(\"ARGS2\", arguments)\n            // console.log(\"ARGS\", func.toString())\n            \n            var msg = {'isSecure': window.isSecureContext ,'orig': document.url, 'frame': frameElement, 'type': `Step`, 'args': [func.toString(), \"RESPONSE PLACEHOLDER\"]}\n            window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"EVENT\", content: msg, ts: Date.now()}}))\n\n            return test_this.step.apply(test_this, [func, this_obj].concat(\n                Array.prototype.slice.call(arguments)));\n        };\n    };\n\n    /**\n     * Wrap a function so that it runs as a step of the current test,\n     * and automatically marks the test as complete if the function\n     * returns without error.\n     *\n     * @param {string} func - Function to run as a step. If this\n     * throws an :js:func:`AssertionError`, or any other exception,\n     * the :js:class:`Test` status is set to ``FAIL``. If it returns\n     * without error the status is set to ``PASS``.\n     * @param {Object} [this_obj] - The object to use as the this\n     * value when calling `func`. Defaults to the :js:class:`Test` object.\n     */\n    Test.prototype.step_func_done = function(func, this_obj)\n    {\n        var test_this = this;\n\n        if (arguments.length === 1) {\n            this_obj = test_this;\n        }\n\n        return function()\n        {\n            if (func) {\n                test_this.step.apply(test_this, [func, this_obj].concat(\n                    Array.prototype.slice.call(arguments)));\n            }\n            test_this.done();\n        };\n    };\n\n    /**\n     * Return a function that automatically sets the current test to\n     * ``FAIL`` if it's called.\n     *\n     * @param {string} [description] - Error message to add to assert\n     * in case of failure.\n     *\n     */\n    Test.prototype.unreached_func = function(description)\n    {\n        return this.step_func(function() {\n            assert_unreached(description);\n        });\n    };\n\n    /**\n     * Run a function as a step of the test after a given timeout.\n     *\n     * This multiplies the timeout by the global timeout multiplier to\n     * account for the expected execution speed of the current test\n     * environment. For example ``test.step_timeout(f, 2000)`` with a\n     * timeout multiplier of 2 will wait for 4000ms before calling ``f``.\n     *\n     * In general it's encouraged to use :js:func:`Test.step_wait` or\n     * :js:func:`step_wait_func` in preference to this function where possible,\n     * as they provide better test performance.\n     *\n     * @param {Function} func - Function to run as a test\n     * step.\n     * @param {number} timeout - Time in ms to wait before running the\n     * test step. The actual wait time is ``timeout`` x\n     * ``timeout_multiplier``.\n     *\n     */\n    Test.prototype.step_timeout = function(func, timeout) {\n        var test_this = this;\n        var args = Array.prototype.slice.call(arguments, 2);\n        return setTimeout(this.step_func(function() {\n            return func.apply(test_this, args);\n        }), timeout * tests.timeout_multiplier);\n    };\n\n    /**\n     * Poll for a function to return true, and call a callback\n     * function once it does, or assert if a timeout is\n     * reached. This is preferred over a simple step_timeout\n     * whenever possible since it allows the timeout to be longer\n     * to reduce intermittents without compromising test execution\n     * speed when the condition is quickly met.\n     *\n     * @param {Function} cond A function taking no arguments and\n     *                        returning a boolean. The callback is called\n     *                        when this function returns true.\n     * @param {Function} func A function taking no arguments to call once\n     *                        the condition is met.\n     * @param {string} [description] Error message to add to assert in case of\n     *                               failure.\n     * @param {number} timeout Timeout in ms. This is multiplied by the global\n     *                         timeout_multiplier\n     * @param {number} interval Polling interval in ms\n     *\n     */\n    Test.prototype.step_wait_func = function(cond, func, description,\n                                             timeout=3000, interval=100) {\n        var timeout_full = timeout * tests.timeout_multiplier;\n        var remaining = Math.ceil(timeout_full / interval);\n        var test_this = this;\n\n        var wait_for_inner = test_this.step_func(() => {\n            if (cond()) {\n                func();\n            } else {\n                if(remaining === 0) {\n                    assert(false, \"step_wait_func\", description,\n                           \"Timed out waiting on condition\");\n                }\n                remaining--;\n                setTimeout(wait_for_inner, interval);\n            }\n        });\n\n        wait_for_inner();\n    };\n\n    /**\n     * Poll for a function to return true, and invoke a callback\n     * followed by this.done() once it does, or assert if a timeout\n     * is reached. This is preferred over a simple step_timeout\n     * whenever possible since it allows the timeout to be longer\n     * to reduce intermittents without compromising test execution speed\n     * when the condition is quickly met.\n     *\n     * @example\n     * async_test(t => {\n     *  const popup = window.open(\"resources/coop-coep.py?coop=same-origin&coep=&navigate=about:blank\");\n     *  t.add_cleanup(() => popup.close());\n     *  assert_equals(window, popup.opener);\n     *\n     *  popup.onload = t.step_func(() => {\n     *    assert_true(popup.location.href.endsWith(\"&navigate=about:blank\"));\n     *    // Use step_wait_func_done as about:blank cannot message back.\n     *    t.step_wait_func_done(() => popup.location.href === \"about:blank\");\n     *  });\n     * }, \"Navigating a popup to about:blank\");\n     *\n     * @param {Function} cond A function taking no arguments and\n     *                        returning a boolean. The callback is called\n     *                        when this function returns true.\n     * @param {Function} func A function taking no arguments to call once\n     *                        the condition is met.\n     * @param {string} [description] Error message to add to assert in case of\n     *                               failure.\n     * @param {number} timeout Timeout in ms. This is multiplied by the global\n     *                         timeout_multiplier\n     * @param {number} interval Polling interval in ms\n     *\n     */\n    Test.prototype.step_wait_func_done = function(cond, func, description,\n                                                  timeout=3000, interval=100) {\n         this.step_wait_func(cond, () => {\n            if (func) {\n                func();\n            }\n            this.done();\n         }, description, timeout, interval);\n    };\n\n    /**\n     * Poll for a function to return true, and resolve a promise\n     * once it does, or assert if a timeout is reached. This is\n     * preferred over a simple step_timeout whenever possible\n     * since it allows the timeout to be longer to reduce\n     * intermittents without compromising test execution speed\n     * when the condition is quickly met.\n     *\n     * @example\n     * promise_test(async t => {\n     *  // â¦\n     * await t.step_wait(() => frame.contentDocument === null, \"Frame navigated to a cross-origin document\");\n     * // â¦\n     * }, \"\");\n     *\n     * @param {Function} cond A function taking no arguments and\n     *                        returning a boolean.\n     * @param {string} [description] Error message to add to assert in case of\n     *                              failure.\n     * @param {number} timeout Timeout in ms. This is multiplied by the global\n     *                         timeout_multiplier\n     * @param {number} interval Polling interval in ms\n     * @returns {Promise} Promise resolved once cond is met.\n     *\n     */\n    Test.prototype.step_wait = function(cond, description, timeout=3000, interval=100) {\n        return new Promise(resolve => {\n            this.step_wait_func(cond, resolve, description, timeout, interval);\n        });\n    }\n\n    /*\n     * Private method for registering cleanup functions. `testharness.js`\n     * internals should use this method instead of the public `add_cleanup`\n     * method in order to hide implementation details from the harness status\n     * message in the case errors.\n     */\n    Test.prototype._add_cleanup = function(callback) {\n        this.cleanup_callbacks.push(callback);\n    };\n\n    /**\n     * Schedule a function to be run after the test result is known, regardless\n     * of passing or failing state.\n     *\n     * The behavior of this function will not\n     * influence the result of the test, but if an exception is thrown, the\n     * test harness will report an error.\n     *\n     * @param {Function} callback - The cleanup function to run. This\n     * is called with no arguments.\n     */\n    Test.prototype.add_cleanup = function(callback) {\n        this._user_defined_cleanup_count += 1;\n        this._add_cleanup(callback);\n    };\n\n    Test.prototype.set_timeout = function()\n    {\n        if (this.timeout_length !== null) {\n            var this_obj = this;\n            this.timeout_id = setTimeout(function()\n                                         {\n                                             this_obj.timeout();\n                                         }, this.timeout_length);\n        }\n    };\n\n    Test.prototype.set_status = function(status, message, stack)\n    {\n        this.status = status;\n        this.message = message;\n        this.stack = stack ? stack : null;\n    };\n\n    /**\n     * Manually set the test status to ``TIMEOUT``.\n     */\n    Test.prototype.timeout = function()\n    {\n        this.timeout_id = null;\n        this.set_status(this.TIMEOUT, \"Test timed out\");\n        this.phase = this.phases.HAS_RESULT;\n        this.done();\n    };\n\n    /**\n     * Manually set the test status to ``TIMEOUT``.\n     *\n     * Alias for `Test.timeout <#Test.timeout>`_.\n     */\n    Test.prototype.force_timeout = function() {\n        return this.timeout();\n    };\n\n    /**\n     * Mark the test as complete.\n     *\n     * This sets the test status to ``PASS`` if no other status was\n     * already recorded. Any subsequent attempts to run additional\n     * test steps will be ignored.\n     *\n     * After setting the test status any test cleanup functions will\n     * be run.\n     */\n    Test.prototype.done = function()\n    {\n        if (this.phase >= this.phases.CLEANING) {\n            return;\n        }\n\n        if (this.phase <= this.phases.STARTED) {\n            this.set_status(this.PASS, null);\n        }\n\n        if (global_scope.clearTimeout) {\n            clearTimeout(this.timeout_id);\n        }\n\n        if (settings.debug) {\n            console.log(\"TEST DONE\",\n                        this.status,\n                        this.name);\n        }\n\n        this.cleanup();\n    };\n\n    function add_test_done_callback(test, callback)\n    {\n        if (test.phase === test.phases.COMPLETE) {\n            callback();\n            return;\n        }\n\n        test._done_callbacks.push(callback);\n    }\n\n    /*\n     * Invoke all specified cleanup functions. If one or more produce an error,\n     * the context is in an unpredictable state, so all further testing should\n     * be cancelled.\n     */\n    Test.prototype.cleanup = function() {\n        for(let i = 0; i < 1000000; i++);\n        window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"END\", content: {'isSecure': window.isSecureContext, 'wid': window.__id__, 'name': this.name, 'status': !this.status}, ts: Date.now()}}))\n        var errors = [];\n        var bad_value_count = 0;\n        function on_error(e) {\n            errors.push(e);\n            // Abort tests immediately so that tests declared within subsequent\n            // cleanup functions are not run.\n            tests.abort();\n        }\n        var this_obj = this;\n        var results = [];\n\n        this.phase = this.phases.CLEANING;\n\n        if (this._abortController) {\n            this._abortController.abort(\"Test cleanup\");\n        }\n\n        forEach(this.cleanup_callbacks,\n                function(cleanup_callback) {\n                    var result;\n\n                    try {\n                        result = cleanup_callback();\n                    } catch (e) {\n                        on_error(e);\n                        return;\n                    }\n\n                    if (!is_valid_cleanup_result(this_obj, result)) {\n                        bad_value_count += 1;\n                        // Abort tests immediately so that tests declared\n                        // within subsequent cleanup functions are not run.\n                        tests.abort();\n                    }\n\n                    results.push(result);\n                });\n\n        if (!this._is_promise_test) {\n            cleanup_done(this_obj, errors, bad_value_count);\n        } else {\n            all_async(results,\n                      function(result, done) {\n                          if (result && typeof result.then === \"function\") {\n                              result\n                                  .then(null, on_error)\n                                  .then(done);\n                          } else {\n                              done();\n                          }\n                      },\n                      function() {\n                          cleanup_done(this_obj, errors, bad_value_count);\n                      });\n        }\n    };\n\n    /*\n     * Determine if the return value of a cleanup function is valid for a given\n     * test. Any test may return the value `undefined`. Tests created with\n     * `promise_test` may alternatively return \"thenable\" object values.\n     */\n    function is_valid_cleanup_result(test, result) {\n        if (result === undefined) {\n            return true;\n        }\n\n        if (test._is_promise_test) {\n            return result && typeof result.then === \"function\";\n        }\n\n        return false;\n    }\n\n    function cleanup_done(test, errors, bad_value_count) {\n        if (errors.length || bad_value_count) {\n            var total = test._user_defined_cleanup_count;\n\n            tests.status.status = tests.status.ERROR;\n            tests.status.stack = null;\n            tests.status.message = \"Test named '\" + test.name +\n                \"' specified \" + total +\n                \" 'cleanup' function\" + (total > 1 ? \"s\" : \"\");\n\n            if (errors.length) {\n                tests.status.message += \", and \" + errors.length + \" failed\";\n                tests.status.stack = ((typeof errors[0] === \"object\" &&\n                                       errors[0].hasOwnProperty(\"stack\")) ?\n                                      errors[0].stack : null);\n            }\n\n            if (bad_value_count) {\n                var type = test._is_promise_test ?\n                   \"non-thenable\" : \"non-undefined\";\n                tests.status.message += \", and \" + bad_value_count +\n                    \" returned a \" + type + \" value\";\n            }\n\n            tests.status.message += \".\";\n        }\n\n        test.phase = test.phases.COMPLETE;\n        tests.result(test);\n        forEach(test._done_callbacks,\n                function(callback) {\n                    callback();\n                });\n        test._done_callbacks.length = 0;\n    }\n\n    /**\n     * Gives an AbortSignal that will be aborted when the test finishes.\n     */\n    Test.prototype.get_signal = function() {\n        if (!this._abortController) {\n            throw new Error(\"AbortController is not supported in this browser\");\n        }\n        return this._abortController.signal;\n    }\n\n    /**\n     * A RemoteTest object mirrors a Test object on a remote worker. The\n     * associated RemoteWorker updates the RemoteTest object in response to\n     * received events. In turn, the RemoteTest object replicates these events\n     * on the local document. This allows listeners (test result reporting\n     * etc..) to transparently handle local and remote events.\n     */\n    function RemoteTest(clone) {\n        var this_obj = this;\n        Object.keys(clone).forEach(\n                function(key) {\n                    this_obj[key] = clone[key];\n                });\n        this.index = null;\n        this.phase = this.phases.INITIAL;\n        this.update_state_from(clone);\n        this._done_callbacks = [];\n        tests.push(this);\n    }\n\n    RemoteTest.prototype.structured_clone = function() {\n        var clone = {};\n        Object.keys(this).forEach(\n                (function(key) {\n                    var value = this[key];\n                    // `RemoteTest` instances are responsible for managing\n                    // their own \"done\" callback functions, so those functions\n                    // are not relevant in other execution contexts. Because of\n                    // this (and because Function values cannot be serialized\n                    // for cross-realm transmittance), the property should not\n                    // be considered when cloning instances.\n                    if (key === '_done_callbacks' ) {\n                        return;\n                    }\n\n                    if (typeof value === \"object\" && value !== null) {\n                        clone[key] = merge({}, value);\n                    } else {\n                        clone[key] = value;\n                    }\n                }).bind(this));\n        clone.phases = merge({}, this.phases);\n        return clone;\n    };\n\n    /**\n     * `RemoteTest` instances are objects which represent tests running in\n     * another realm. They do not define \"cleanup\" functions (if necessary,\n     * such functions are defined on the associated `Test` instance within the\n     * external realm). However, `RemoteTests` may have \"done\" callbacks (e.g.\n     * as attached by the `Tests` instance responsible for tracking the overall\n     * test status in the parent realm). The `cleanup` method delegates to\n     * `done` in order to ensure that such callbacks are invoked following the\n     * completion of the `RemoteTest`.\n     */\n    RemoteTest.prototype.cleanup = function() {\n        this.done();\n    };\n    RemoteTest.prototype.phases = Test.prototype.phases;\n    RemoteTest.prototype.update_state_from = function(clone) {\n        this.status = clone.status;\n        this.message = clone.message;\n        this.stack = clone.stack;\n        if (this.phase === this.phases.INITIAL) {\n            this.phase = this.phases.STARTED;\n        }\n    };\n    RemoteTest.prototype.done = function() {\n        this.phase = this.phases.COMPLETE;\n\n        forEach(this._done_callbacks,\n                function(callback) {\n                    callback();\n                });\n    }\n\n    RemoteTest.prototype.format_status = function() {\n        return Test.prototype.status_formats[this.status];\n    }\n\n    /*\n     * A RemoteContext listens for test events from a remote test context, such\n     * as another window or a worker. These events are then used to construct\n     * and maintain RemoteTest objects that mirror the tests running in the\n     * remote context.\n     *\n     * An optional third parameter can be used as a predicate to filter incoming\n     * MessageEvents.\n     */\n    function RemoteContext(remote, message_target, message_filter) {\n        this.running = true;\n        this.started = false;\n        this.tests = new Array();\n        this.early_exception = null;\n\n        var this_obj = this;\n        // If remote context is cross origin assigning to onerror is not\n        // possible, so silently catch those errors.\n        try {\n          remote.onerror = function(error) { this_obj.remote_error(error); };\n        } catch (e) {\n          // Ignore.\n        }\n\n        // Keeping a reference to the remote object and the message handler until\n        // remote_done() is seen prevents the remote object and its message channel\n        // from going away before all the messages are dispatched.\n        this.remote = remote;\n        this.message_target = message_target;\n        this.message_handler = function(message) {\n            var passesFilter = !message_filter || message_filter(message);\n            // The reference to the `running` property in the following\n            // condition is unnecessary because that value is only set to\n            // `false` after the `message_handler` function has been\n            // unsubscribed.\n            // TODO: Simplify the condition by removing the reference.\n            if (this_obj.running && message.data && passesFilter &&\n                (message.data.type in this_obj.message_handlers)) {\n                this_obj.message_handlers[message.data.type].call(this_obj, message.data);\n            }\n        };\n\n        if (self.Promise) {\n            this.done = new Promise(function(resolve) {\n                this_obj.doneResolve = resolve;\n            });\n        }\n\n        this.message_target.addEventListener(\"message\", this.message_handler);\n    }\n\n    RemoteContext.prototype.remote_error = function(error) {\n        if (error.preventDefault) {\n            error.preventDefault();\n        }\n\n        // Defer interpretation of errors until the testing protocol has\n        // started and the remote test's `allow_uncaught_exception` property\n        // is available.\n        if (!this.started) {\n            this.early_exception = error;\n        } else if (!this.allow_uncaught_exception) {\n            this.report_uncaught(error);\n        }\n    };\n\n    RemoteContext.prototype.report_uncaught = function(error) {\n        var message = error.message || String(error);\n        var filename = (error.filename ? \" \" + error.filename: \"\");\n        // FIXME: Display remote error states separately from main document\n        // error state.\n        tests.set_status(tests.status.ERROR,\n                         \"Error in remote\" + filename + \": \" + message,\n                         error.stack);\n    };\n\n    RemoteContext.prototype.start = function(data) {\n        this.started = true;\n        this.allow_uncaught_exception = data.properties.allow_uncaught_exception;\n\n        if (this.early_exception && !this.allow_uncaught_exception) {\n            this.report_uncaught(this.early_exception);\n        }\n    };\n\n    RemoteContext.prototype.test_state = function(data) {\n        var remote_test = this.tests[data.test.index];\n        if (!remote_test) {\n            remote_test = new RemoteTest(data.test);\n            this.tests[data.test.index] = remote_test;\n        }\n        remote_test.update_state_from(data.test);\n        tests.notify_test_state(remote_test);\n    };\n\n    RemoteContext.prototype.test_done = function(data) {\n        var remote_test = this.tests[data.test.index];\n        remote_test.update_state_from(data.test);\n        remote_test.done();\n        tests.result(remote_test);\n    };\n\n    RemoteContext.prototype.remote_done = function(data) {\n        if (tests.status.status === null &&\n            data.status.status !== data.status.OK) {\n            tests.set_status(data.status.status, data.status.message, data.status.stack);\n        }\n\n        for (let assert of data.asserts) {\n            var record = new AssertRecord();\n            record.assert_name = assert.assert_name;\n            record.args = assert.args;\n            record.test = assert.test != null ? this.tests[assert.test.index] : null;\n            record.status = assert.status;\n            record.stack = assert.stack;\n            tests.asserts_run.push(record);\n        }\n\n        this.message_target.removeEventListener(\"message\", this.message_handler);\n        this.running = false;\n\n        // If remote context is cross origin assigning to onerror is not\n        // possible, so silently catch those errors.\n        try {\n          this.remote.onerror = null;\n        } catch (e) {\n          // Ignore.\n        }\n\n        this.remote = null;\n        this.message_target = null;\n        if (this.doneResolve) {\n            this.doneResolve();\n        }\n\n        if (tests.all_done()) {\n            tests.complete();\n        }\n    };\n\n    RemoteContext.prototype.message_handlers = {\n        start: RemoteContext.prototype.start,\n        test_state: RemoteContext.prototype.test_state,\n        result: RemoteContext.prototype.test_done,\n        complete: RemoteContext.prototype.remote_done\n    };\n\n    /**\n     * @class\n     * Status of the overall harness\n     */\n    function TestsStatus()\n    {\n        /** The status code */\n        this.status = null;\n        /** Message in case of failure */\n        this.message = null;\n        /** Stack trace in case of an exception. */\n        this.stack = null;\n    }\n\n    /**\n     * Enum of possible harness statuses.\n     *\n     * :values:\n     *   - ``OK``\n     *   - ``ERROR``\n     *   - ``TIMEOUT``\n     *   - ``PRECONDITION_FAILED``\n     */\n    TestsStatus.statuses = {\n        OK:0,\n        ERROR:1,\n        TIMEOUT:2,\n        PRECONDITION_FAILED:3\n    };\n\n    TestsStatus.prototype = merge({}, TestsStatus.statuses);\n\n    TestsStatus.prototype.formats = {\n        0: \"OK\",\n        1: \"Error\",\n        2: \"Timeout\",\n        3: \"Optional Feature Unsupported\"\n    };\n\n    TestsStatus.prototype.structured_clone = function()\n    {\n        if (!this._structured_clone) {\n            var msg = this.message;\n            msg = msg ? String(msg) : msg;\n            this._structured_clone = merge({\n                status:this.status,\n                message:msg,\n                stack:this.stack\n            }, TestsStatus.statuses);\n        }\n        return this._structured_clone;\n    };\n\n    TestsStatus.prototype.format_status = function() {\n        return this.formats[this.status];\n    };\n\n    /**\n     * @class\n     * Record of an assert that ran.\n     *\n     * @param {Test} test - The test which ran the assert.\n     * @param {string} assert_name - The function name of the assert.\n     * @param {Any} args - The arguments passed to the assert function.\n     */\n    function AssertRecord(test, assert_name, args = []) {\n        /** Name of the assert that ran */\n        this.assert_name = assert_name;\n        /** Test that ran the assert */\n        this.test = test;\n        // Avoid keeping complex objects alive\n        /** Stringification of the arguments that were passed to the assert function */\n        this.args = args.map(x => format_value(x).replace(/\\n/g, \" \"));\n        /** Status of the assert */\n        this.status = null;\n    }\n\n    AssertRecord.prototype.structured_clone = function() {\n        return {\n            assert_name: this.assert_name,\n            test: this.test ? this.test.structured_clone() : null,\n            args: this.args,\n            status: this.status,\n        };\n    };\n\n    function Tests()\n    {\n        this.tests = [];\n        this.num_pending = 0;\n\n        this.phases = {\n            INITIAL:0,\n            SETUP:1,\n            HAVE_TESTS:2,\n            HAVE_RESULTS:3,\n            COMPLETE:4\n        };\n        this.phase = this.phases.INITIAL;\n\n        this.properties = {};\n\n        this.wait_for_finish = false;\n        this.processing_callbacks = false;\n\n        this.allow_uncaught_exception = false;\n\n        this.file_is_test = false;\n        // This value is lazily initialized in order to avoid introducing a\n        // dependency on ECMAScript 2015 Promises to all tests.\n        this.promise_tests = null;\n        this.promise_setup_called = false;\n\n        this.timeout_multiplier = 1;\n        this.timeout_length = test_environment.test_timeout();\n        this.timeout_id = null;\n\n        this.start_callbacks = [];\n        this.test_state_callbacks = [];\n        this.test_done_callbacks = [];\n        this.all_done_callbacks = [];\n\n        this.hide_test_state = false;\n        this.pending_remotes = [];\n\n        this.current_test = null;\n        this.asserts_run = [];\n\n        // Track whether output is enabled, and thus whether or not we should\n        // track asserts.\n        //\n        // On workers we don't get properties set from testharnessreport.js, so\n        // we don't know whether or not to track asserts. To avoid the\n        // resulting performance hit, we assume we are not meant to. This means\n        // that assert tracking does not function on workers.\n        this.output = settings.output && 'document' in global_scope;\n\n        this.status = new TestsStatus();\n\n        var this_obj = this;\n\n        test_environment.add_on_loaded_callback(function() {\n            if (this_obj.all_done()) {\n                this_obj.complete();\n            }\n        });\n\n        this.set_timeout();\n    }\n\n    Tests.prototype.setup = function(func, properties)\n    {\n        if (this.phase >= this.phases.HAVE_RESULTS) {\n            return;\n        }\n\n        if (this.phase < this.phases.SETUP) {\n            this.phase = this.phases.SETUP;\n        }\n\n        this.properties = properties;\n\n        for (var p in properties) {\n            if (properties.hasOwnProperty(p)) {\n                var value = properties[p];\n                if (p == \"allow_uncaught_exception\") {\n                    this.allow_uncaught_exception = value;\n                } else if (p == \"explicit_done\" && value) {\n                    this.wait_for_finish = true;\n                } else if (p == \"explicit_timeout\" && value) {\n                    this.timeout_length = null;\n                    if (this.timeout_id)\n                    {\n                        clearTimeout(this.timeout_id);\n                    }\n                } else if (p == \"single_test\" && value) {\n                    this.set_file_is_test();\n                } else if (p == \"timeout_multiplier\") {\n                    this.timeout_multiplier = value;\n                    if (this.timeout_length) {\n                         this.timeout_length *= this.timeout_multiplier;\n                    }\n                } else if (p == \"hide_test_state\") {\n                    this.hide_test_state = value;\n                } else if (p == \"output\") {\n                    this.output = value;\n                } else if (p === \"debug\") {\n                    settings.debug = value;\n                }\n            }\n        }\n\n        if (func) {\n            try {\n                func();\n            } catch (e) {\n                this.status.status = e instanceof OptionalFeatureUnsupportedError ? this.status.PRECONDITION_FAILED : this.status.ERROR;\n                this.status.message = String(e);\n                this.status.stack = e.stack ? e.stack : null;\n                this.complete();\n            }\n        }\n        this.set_timeout();\n    };\n\n    Tests.prototype.set_file_is_test = function() {\n        if (this.tests.length > 0) {\n            throw new Error(\"Tried to set file as test after creating a test\");\n        }\n        this.wait_for_finish = true;\n        this.file_is_test = true;\n        // Create the test, which will add it to the list of tests\n        tests.current_test = async_test();\n    };\n\n    Tests.prototype.set_status = function(status, message, stack)\n    {\n        this.status.status = status;\n        this.status.message = message;\n        this.status.stack = stack ? stack : null;\n    };\n\n    Tests.prototype.set_timeout = function() {\n        if (global_scope.clearTimeout) {\n            var this_obj = this;\n            clearTimeout(this.timeout_id);\n            if (this.timeout_length !== null) {\n                this.timeout_id = setTimeout(function() {\n                                                 this_obj.timeout();\n                                             }, this.timeout_length);\n            }\n        }\n    };\n\n    Tests.prototype.timeout = function() {\n        var test_in_cleanup = null;\n\n        if (this.status.status === null) {\n            forEach(this.tests,\n                    function(test) {\n                        // No more than one test is expected to be in the\n                        // \"CLEANUP\" phase at any time\n                        if (test.phase === test.phases.CLEANING) {\n                            test_in_cleanup = test;\n                        }\n\n                        test.phase = test.phases.COMPLETE;\n                    });\n\n            // Timeouts that occur while a test is in the \"cleanup\" phase\n            // indicate that some global state was not properly reverted. This\n            // invalidates the overall test execution, so the timeout should be\n            // reported as an error and cancel the execution of any remaining\n            // tests.\n            if (test_in_cleanup) {\n                this.status.status = this.status.ERROR;\n                this.status.message = \"Timeout while running cleanup for \" +\n                    \"test named \\\"\" + test_in_cleanup.name + \"\\\".\";\n                tests.status.stack = null;\n            } else {\n                this.status.status = this.status.TIMEOUT;\n            }\n        }\n\n        this.complete();\n    };\n\n    Tests.prototype.end_wait = function()\n    {\n        this.wait_for_finish = false;\n        if (this.all_done()) {\n            this.complete();\n        }\n    };\n\n    Tests.prototype.push = function(test)\n    {\n        if (this.phase < this.phases.HAVE_TESTS) {\n            this.start();\n        }\n        this.num_pending++;\n        test.index = this.tests.push(test);\n        this.notify_test_state(test);\n    };\n\n    Tests.prototype.notify_test_state = function(test) {\n        var this_obj = this;\n        forEach(this.test_state_callbacks,\n                function(callback) {\n                    callback(test, this_obj);\n                });\n    };\n\n    Tests.prototype.all_done = function() {\n        return (this.tests.length > 0 || this.pending_remotes.length > 0) &&\n                test_environment.all_loaded &&\n                (this.num_pending === 0 || this.is_aborted) && !this.wait_for_finish &&\n                !this.processing_callbacks &&\n                !this.pending_remotes.some(function(w) { return w.running; });\n    };\n\n    Tests.prototype.start = function() {\n        this.phase = this.phases.HAVE_TESTS;\n        this.notify_start();\n    };\n\n    Tests.prototype.notify_start = function() {\n        var this_obj = this;\n        forEach (this.start_callbacks,\n                 function(callback)\n                 {\n                     callback(this_obj.properties);\n                 });\n    };\n\n    Tests.prototype.result = function(test)\n    {\n        // If the harness has already transitioned beyond the `HAVE_RESULTS`\n        // phase, subsequent tests should not cause it to revert.\n        if (this.phase <= this.phases.HAVE_RESULTS) {\n            this.phase = this.phases.HAVE_RESULTS;\n        }\n        this.num_pending--;\n        this.notify_result(test);\n    };\n\n    Tests.prototype.notify_result = function(test) {\n        var this_obj = this;\n        this.processing_callbacks = true;\n        forEach(this.test_done_callbacks,\n                function(callback)\n                {\n                    callback(test, this_obj);\n                });\n        this.processing_callbacks = false;\n        if (this_obj.all_done()) {\n            this_obj.complete();\n        }\n    };\n\n    Tests.prototype.complete = function() {\n        if (this.phase === this.phases.COMPLETE) {\n            return;\n        }\n        var this_obj = this;\n        var all_complete = function() {\n            this_obj.phase = this_obj.phases.COMPLETE;\n            this_obj.notify_complete();\n        };\n        var incomplete = filter(this.tests,\n                                function(test) {\n                                    return test.phase < test.phases.COMPLETE;\n                                });\n\n        /**\n         * To preserve legacy behavior, overall test completion must be\n         * signaled synchronously.\n         */\n        if (incomplete.length === 0) {\n            all_complete();\n            return;\n        }\n\n        all_async(incomplete,\n                  function(test, testDone)\n                  {\n                      if (test.phase === test.phases.INITIAL) {\n                          test.phase = test.phases.COMPLETE;\n                          testDone();\n                      } else {\n                          add_test_done_callback(test, testDone);\n                          test.cleanup();\n                      }\n                  },\n                  all_complete);\n    };\n\n    Tests.prototype.set_assert = function(assert_name, args) {\n        this.asserts_run.push(new AssertRecord(this.current_test, assert_name, args))\n    }\n\n    Tests.prototype.set_assert_status = function(status, stack) {\n        let assert_record = this.asserts_run[this.asserts_run.length - 1];\n        assert_record.status = status;\n        assert_record.stack = stack;\n    }\n\n    /**\n     * Update the harness status to reflect an unrecoverable harness error that\n     * should cancel all further testing. Update all previously-defined tests\n     * which have not yet started to indicate that they will not be executed.\n     */\n    Tests.prototype.abort = function() {\n        this.status.status = this.status.ERROR;\n        this.is_aborted = true;\n\n        forEach(this.tests,\n                function(test) {\n                    if (test.phase === test.phases.INITIAL) {\n                        test.phase = test.phases.COMPLETE;\n                    }\n                });\n    };\n\n    /*\n     * Determine if any tests share the same `name` property. Return an array\n     * containing the names of any such duplicates.\n     */\n    Tests.prototype.find_duplicates = function() {\n        var names = Object.create(null);\n        var duplicates = [];\n\n        forEach (this.tests,\n                 function(test)\n                 {\n                     if (test.name in names && duplicates.indexOf(test.name) === -1) {\n                        duplicates.push(test.name);\n                     }\n                     names[test.name] = true;\n                 });\n\n        return duplicates;\n    };\n\n    function code_unit_str(char) {\n        return 'U+' + char.charCodeAt(0).toString(16);\n    }\n\n    function sanitize_unpaired_surrogates(str) {\n        return str.replace(\n            /([\\ud800-\\udbff]+)(?![\\udc00-\\udfff])|(^|[^\\ud800-\\udbff])([\\udc00-\\udfff]+)/g,\n            function(_, low, prefix, high) {\n                var output = prefix || \"\";  // prefix may be undefined\n                var string = low || high;  // only one of these alternates can match\n                for (var i = 0; i < string.length; i++) {\n                    output += code_unit_str(string[i]);\n                }\n                return output;\n            });\n    }\n\n    function sanitize_all_unpaired_surrogates(tests) {\n        forEach (tests,\n                 function (test)\n                 {\n                     var sanitized = sanitize_unpaired_surrogates(test.name);\n\n                     if (test.name !== sanitized) {\n                         test.name = sanitized;\n                         delete test._structured_clone;\n                     }\n                 });\n    }\n\n    Tests.prototype.notify_complete = function() {\n        var this_obj = this;\n        var duplicates;\n\n        if (this.status.status === null) {\n            duplicates = this.find_duplicates();\n\n            // Some transports adhere to UTF-8's restriction on unpaired\n            // surrogates. Sanitize the titles so that the results can be\n            // consistently sent via all transports.\n            sanitize_all_unpaired_surrogates(this.tests);\n\n            // Test names are presumed to be unique within test files--this\n            // allows consumers to use them for identification purposes.\n            // Duplicated names violate this expectation and should therefore\n            // be reported as an error.\n            if (duplicates.length) {\n                this.status.status = this.status.ERROR;\n                this.status.message =\n                   duplicates.length + ' duplicate test name' +\n                   (duplicates.length > 1 ? 's' : '') + ': \"' +\n                   duplicates.join('\", \"') + '\"';\n            } else {\n                this.status.status = this.status.OK;\n            }\n        }\n\n        forEach (this.all_done_callbacks,\n                 function(callback)\n                 {\n                     callback(this_obj.tests, this_obj.status, this_obj.asserts_run);\n                 });\n    };\n\n    /*\n     * Constructs a RemoteContext that tracks tests from a specific worker.\n     */\n    Tests.prototype.create_remote_worker = function(worker) {\n        var message_port;\n\n        if (is_service_worker(worker)) {\n            message_port = navigator.serviceWorker;\n            worker.postMessage({type: \"connect\"});\n        } else if (is_shared_worker(worker)) {\n            message_port = worker.port;\n            message_port.start();\n        } else {\n            message_port = worker;\n        }\n\n        return new RemoteContext(worker, message_port);\n    };\n\n    /*\n     * Constructs a RemoteContext that tracks tests from a specific window.\n     */\n    Tests.prototype.create_remote_window = function(remote) {\n        remote.postMessage({type: \"getmessages\"}, \"*\");\n        return new RemoteContext(\n            remote,\n            window,\n            function(msg) {\n                return msg.source === remote;\n            }\n        );\n    };\n\n    Tests.prototype.fetch_tests_from_worker = function(worker) {\n        if (this.phase >= this.phases.COMPLETE) {\n            return;\n        }\n\n        var remoteContext = this.create_remote_worker(worker);\n        this.pending_remotes.push(remoteContext);\n        return remoteContext.done;\n    };\n\n    /**\n     * Get test results from a worker and include them in the current test.\n     *\n     * @param {Worker|SharedWorker|ServiceWorker|MessagePort} port -\n     * Either a worker object or a port connected to a worker which is\n     * running tests..\n     * @returns {Promise} - A promise that's resolved once all the remote tests are complete.\n     */\n    function fetch_tests_from_worker(port) {\n        return tests.fetch_tests_from_worker(port);\n    }\n    expose(fetch_tests_from_worker, 'fetch_tests_from_worker');\n\n    Tests.prototype.fetch_tests_from_window = function(remote) {\n        if (this.phase >= this.phases.COMPLETE) {\n            return;\n        }\n\n        var remoteContext = this.create_remote_window(remote);\n        this.pending_remotes.push(remoteContext);\n        return remoteContext.done;\n    };\n\n    /**\n     * Aggregate tests from separate windows or iframes\n     * into the current document as if they were all part of the same test file.\n     *\n     * The document of the second window (or iframe) should include\n     * ``testharness.js``, but not ``testharnessreport.js``, and use\n     * :js:func:`test`, :js:func:`async_test`, and :js:func:`promise_test` in\n     * the usual manner.\n     *\n     * @param {Window} window - The window to fetch tests from.\n     */\n    function fetch_tests_from_window(window) {\n        return tests.fetch_tests_from_window(window);\n    }\n    expose(fetch_tests_from_window, 'fetch_tests_from_window');\n\n    /**\n     * Get test results from a shadow realm and include them in the current test.\n     *\n     * @param {ShadowRealm} realm - A shadow realm also running the test harness\n     * @returns {Promise} - A promise that's resolved once all the remote tests are complete.\n     */\n    function fetch_tests_from_shadow_realm(realm) {\n        var chan = new MessageChannel();\n        function receiveMessage(msg_json) {\n            chan.port1.postMessage(JSON.parse(msg_json));\n        }\n        var done = tests.fetch_tests_from_worker(chan.port2);\n        realm.evaluate(\"begin_shadow_realm_tests\")(receiveMessage);\n        chan.port2.start();\n        return done;\n    }\n    expose(fetch_tests_from_shadow_realm, 'fetch_tests_from_shadow_realm');\n\n    /**\n     * Begin running tests in this shadow realm test harness.\n     *\n     * To be called after all tests have been loaded; it is an error to call\n     * this more than once or in a non-Shadow Realm environment\n     *\n     * @param {Function} postMessage - A function to send test updates to the\n     * incubating realm-- accepts JSON-encoded messages in the format used by\n     * RemoteContext\n     */\n    function begin_shadow_realm_tests(postMessage) {\n        if (!(test_environment instanceof ShadowRealmTestEnvironment)) {\n            throw new Error(\"begin_shadow_realm_tests called in non-Shadow Realm environment\");\n        }\n\n        test_environment.begin(function (msg) {\n            postMessage(JSON.stringify(msg));\n        });\n    }\n    expose(begin_shadow_realm_tests, 'begin_shadow_realm_tests');\n\n    /**\n     * Timeout the tests.\n     *\n     * This only has an effect when ``explicit_timeout`` has been set\n     * in :js:func:`setup`. In other cases any call is a no-op.\n     *\n     */\n    function timeout() {\n        if (tests.timeout_length === null) {\n            tests.timeout();\n        }\n    }\n    expose(timeout, 'timeout');\n\n    /**\n     * Add a callback that's triggered when the first :js:class:`Test` is created.\n     *\n     * @param {Function} callback - Callback function. This is called\n     * without arguments.\n     */\n    function add_start_callback(callback) {\n        tests.start_callbacks.push(callback);\n    }\n\n    /**\n     * Add a callback that's triggered when a test state changes.\n     *\n     * @param {Function} callback - Callback function, called with the\n     * :js:class:`Test` as the only argument.\n     */\n    function add_test_state_callback(callback) {\n        tests.test_state_callbacks.push(callback);\n    }\n\n    /**\n     * Add a callback that's triggered when a test result is received.\n     *\n     * @param {Function} callback - Callback function, called with the\n     * :js:class:`Test` as the only argument.\n     */\n    function add_result_callback(callback) {\n        tests.test_done_callbacks.push(callback);\n    }\n\n    /**\n     * Add a callback that's triggered when all tests are complete.\n     *\n     * @param {Function} callback - Callback function, called with an\n     * array of :js:class:`Test` objects, a :js:class:`TestsStatus`\n     * object and an array of :js:class:`AssertRecord` objects. If the\n     * debug setting is ``false`` the final argument will be an empty\n     * array.\n     *\n     * For performance reasons asserts are only tracked when the debug\n     * setting is ``true``. In other cases the array of asserts will be\n     * empty.\n     */\n    function add_completion_callback(callback) {\n        tests.all_done_callbacks.push(callback);\n    }\n\n    expose(add_start_callback, 'add_start_callback');\n    expose(add_test_state_callback, 'add_test_state_callback');\n    expose(add_result_callback, 'add_result_callback');\n    expose(add_completion_callback, 'add_completion_callback');\n\n    function remove(array, item) {\n        var index = array.indexOf(item);\n        if (index > -1) {\n            array.splice(index, 1);\n        }\n    }\n\n    function remove_start_callback(callback) {\n        remove(tests.start_callbacks, callback);\n    }\n\n    function remove_test_state_callback(callback) {\n        remove(tests.test_state_callbacks, callback);\n    }\n\n    function remove_result_callback(callback) {\n        remove(tests.test_done_callbacks, callback);\n    }\n\n    function remove_completion_callback(callback) {\n       remove(tests.all_done_callbacks, callback);\n    }\n\n    /*\n     * Output listener\n    */\n\n    function Output() {\n        this.output_document = document;\n        this.output_node = null;\n        this.enabled = settings.output;\n        this.phase = this.INITIAL;\n    }\n\n    Output.prototype.INITIAL = 0;\n    Output.prototype.STARTED = 1;\n    Output.prototype.HAVE_RESULTS = 2;\n    Output.prototype.COMPLETE = 3;\n\n    Output.prototype.setup = function(properties) {\n        if (this.phase > this.INITIAL) {\n            return;\n        }\n\n        //If output is disabled in testharnessreport.js the test shouldn't be\n        //able to override that\n        this.enabled = this.enabled && (properties.hasOwnProperty(\"output\") ?\n                                        properties.output : settings.output);\n    };\n\n    Output.prototype.init = function(properties) {\n        if (this.phase >= this.STARTED) {\n            return;\n        }\n        if (properties.output_document) {\n            this.output_document = properties.output_document;\n        } else {\n            this.output_document = document;\n        }\n        this.phase = this.STARTED;\n    };\n\n    Output.prototype.resolve_log = function() {\n        var output_document;\n        if (this.output_node) {\n            return;\n        }\n        if (typeof this.output_document === \"function\") {\n            output_document = this.output_document.apply(undefined);\n        } else {\n            output_document = this.output_document;\n        }\n        if (!output_document) {\n            return;\n        }\n        var node = output_document.getElementById(\"log\");\n        if (!node) {\n            if (output_document.readyState === \"loading\") {\n                return;\n            }\n            node = output_document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"div\");\n            node.id = \"log\";\n            if (output_document.body) {\n                output_document.body.appendChild(node);\n            } else {\n                var root = output_document.documentElement;\n                var is_html = (root &&\n                               root.namespaceURI == \"http://www.w3.org/1999/xhtml\" &&\n                               root.localName == \"html\");\n                var is_svg = (output_document.defaultView &&\n                              \"SVGSVGElement\" in output_document.defaultView &&\n                              root instanceof output_document.defaultView.SVGSVGElement);\n                if (is_svg) {\n                    var foreignObject = output_document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\n                    foreignObject.setAttribute(\"width\", \"100%\");\n                    foreignObject.setAttribute(\"height\", \"100%\");\n                    root.appendChild(foreignObject);\n                    foreignObject.appendChild(node);\n                } else if (is_html) {\n                    root.appendChild(output_document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"body\"))\n                        .appendChild(node);\n                } else {\n                    root.appendChild(node);\n                }\n            }\n        }\n        this.output_document = output_document;\n        this.output_node = node;\n    };\n\n    Output.prototype.show_status = function() {\n        if (this.phase < this.STARTED) {\n            this.init({});\n        }\n        if (!this.enabled || this.phase === this.COMPLETE) {\n            return;\n        }\n        this.resolve_log();\n        if (this.phase < this.HAVE_RESULTS) {\n            this.phase = this.HAVE_RESULTS;\n        }\n        var done_count = tests.tests.length - tests.num_pending;\n        if (this.output_node && !tests.hide_test_state) {\n            if (done_count < 100 ||\n                (done_count < 1000 && done_count % 100 === 0) ||\n                done_count % 1000 === 0) {\n                this.output_node.textContent = \"Running, \" +\n                    done_count + \" complete, \" +\n                    tests.num_pending + \" remain\";\n            }\n        }\n    };\n\n    Output.prototype.show_results = function (tests, harness_status, asserts_run) {\n        if (this.phase >= this.COMPLETE) {\n            return;\n        }\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.output_node) {\n            this.resolve_log();\n        }\n        this.phase = this.COMPLETE;\n\n        var log = this.output_node;\n        if (!log) {\n            return;\n        }\n        var output_document = this.output_document;\n\n        while (log.lastChild) {\n            log.removeChild(log.lastChild);\n        }\n\n        var stylesheet = output_document.createElementNS(xhtml_ns, \"style\");\n        stylesheet.textContent = stylesheetContent;\n        var heads = output_document.getElementsByTagName(\"head\");\n        if (heads.length) {\n            heads[0].appendChild(stylesheet);\n        }\n\n        var status_number = {};\n        forEach(tests,\n                function(test) {\n                    var status = test.format_status();\n                    if (status_number.hasOwnProperty(status)) {\n                        status_number[status] += 1;\n                    } else {\n                        status_number[status] = 1;\n                    }\n                });\n\n        function status_class(status)\n        {\n            return status.replace(/\\s/g, '').toLowerCase();\n        }\n\n        var summary_template = [\"section\", {\"id\":\"summary\"},\n                                [\"h2\", {}, \"Summary\"],\n                                function()\n                                {\n                                    var status = harness_status.format_status();\n                                    var rv = [[\"section\", {},\n                                               [\"p\", {},\n                                                \"Harness status: \",\n                                                [\"span\", {\"class\":status_class(status)},\n                                                 status\n                                                ],\n                                               ],\n                                               [\"button\",\n                                                {\"onclick\": \"let evt = new Event('__test_restart'); \" +\n                                                 \"let canceled = !window.dispatchEvent(evt);\" +\n                                                 \"if (!canceled) { location.reload() }\"},\n                                                \"Rerun\"]\n                                              ]];\n\n                                    if (harness_status.status === harness_status.ERROR) {\n                                        rv[0].push([\"pre\", {}, harness_status.message]);\n                                        if (harness_status.stack) {\n                                            rv[0].push([\"pre\", {}, harness_status.stack]);\n                                        }\n                                    }\n                                    return rv;\n                                },\n                                [\"p\", {}, \"Found ${num_tests} tests\"],\n                                function() {\n                                    var rv = [[\"div\", {}]];\n                                    var i = 0;\n                                    while (Test.prototype.status_formats.hasOwnProperty(i)) {\n                                        if (status_number.hasOwnProperty(Test.prototype.status_formats[i])) {\n                                            var status = Test.prototype.status_formats[i];\n                                            rv[0].push([\"div\", {},\n                                                        [\"label\", {},\n                                                         [\"input\", {type:\"checkbox\", checked:\"checked\"}],\n                                                         status_number[status] + \" \",\n                                                         [\"span\", {\"class\":status_class(status)}, status]]]);\n                                        }\n                                        i++;\n                                    }\n                                    return rv;\n                                },\n                               ];\n\n        log.appendChild(render(summary_template, {num_tests:tests.length}, output_document));\n\n        forEach(output_document.querySelectorAll(\"section#summary label\"),\n                function(element)\n                {\n                    on_event(element, \"click\",\n                             function(e)\n                             {\n                                 if (output_document.getElementById(\"results\") === null) {\n                                     e.preventDefault();\n                                     return;\n                                 }\n                                 var result_class = element.querySelector(\"span[class]\").getAttribute(\"class\");\n                                 var style_element = output_document.querySelector(\"style#hide-\" + result_class);\n                                 var input_element = element.querySelector(\"input\");\n                                 if (!style_element && !input_element.checked) {\n                                     style_element = output_document.createElementNS(xhtml_ns, \"style\");\n                                     style_element.id = \"hide-\" + result_class;\n                                     style_element.textContent = \"table#results > tbody > tr.overall-\"+result_class+\"{display:none}\";\n                                     output_document.body.appendChild(style_element);\n                                 } else if (style_element && input_element.checked) {\n                                     style_element.parentNode.removeChild(style_element);\n                                 }\n                             });\n                });\n\n        // This use of innerHTML plus manual escaping is not recommended in\n        // general, but is necessary here for performance.  Using textContent\n        // on each individual <td> adds tens of seconds of execution time for\n        // large test suites (tens of thousands of tests).\n        function escape_html(s)\n        {\n            return s.replace(/\\&/g, \"&amp;\")\n                .replace(/</g, \"&lt;\")\n                .replace(/\"/g, \"&quot;\")\n                .replace(/'/g, \"&#39;\");\n        }\n\n        function has_assertions()\n        {\n            for (var i = 0; i < tests.length; i++) {\n                if (tests[i].properties.hasOwnProperty(\"assert\")) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function get_assertion(test)\n        {\n            if (test.properties.hasOwnProperty(\"assert\")) {\n                if (Array.isArray(test.properties.assert)) {\n                    return test.properties.assert.join(' ');\n                }\n                return test.properties.assert;\n            }\n            return '';\n        }\n\n        var asserts_run_by_test = new Map();\n        asserts_run.forEach(assert => {\n            if (!asserts_run_by_test.has(assert.test)) {\n                asserts_run_by_test.set(assert.test, []);\n            }\n            asserts_run_by_test.get(assert.test).push(assert);\n        });\n\n        function get_asserts_output(test) {\n            var asserts = asserts_run_by_test.get(test);\n            if (!asserts) {\n                return \"No asserts ran\";\n            }\n            rv = \"<table>\";\n            rv += asserts.map(assert => {\n                var output_fn = \"<strong>\" + escape_html(assert.assert_name) + \"</strong>(\";\n                var prefix_len = output_fn.length;\n                var output_args = assert.args;\n                var output_len = output_args.reduce((prev, current) => prev+current, prefix_len);\n                if (output_len[output_len.length - 1] > 50) {\n                    output_args = output_args.map((x, i) =>\n                    (i > 0 ? \"  \".repeat(prefix_len) : \"\" )+ x + (i < output_args.length - 1 ? \",\\n\" : \"\"));\n                } else {\n                    output_args = output_args.map((x, i) => x + (i < output_args.length - 1 ? \", \" : \"\"));\n                }\n                output_fn += escape_html(output_args.join(\"\"));\n                output_fn += ')';\n                var output_location;\n                if (assert.stack) {\n                    output_location = assert.stack.split(\"\\n\", 1)[0].replace(/@?\\w+:\\/\\/[^ \"\\/]+(?::\\d+)?/g, \" \");\n                }\n                return \"<tr class='overall-\" +\n                    status_class(Test.prototype.status_formats[assert.status]) + \"'>\" +\n                    \"<td class='\" +\n                    status_class(Test.prototype.status_formats[assert.status]) + \"'>\" +\n                    Test.prototype.status_formats[assert.status] + \"</td>\" +\n                    \"<td><pre>\" +\n                    output_fn +\n                    (output_location ? \"\\n\" + escape_html(output_location) : \"\") +\n                    \"</pre></td></tr>\";\n            }\n            ).join(\"\\n\");\n            rv += \"</table>\";\n            return rv;\n        }\n\n        log.appendChild(document.createElementNS(xhtml_ns, \"section\"));\n        var assertions = has_assertions();\n        var html = \"<h2>Details</h2><table id='results' \" + (assertions ? \"class='assertions'\" : \"\" ) + \">\" +\n            \"<thead><tr><th>Result</th><th>Test Name</th>\" +\n            (assertions ? \"<th>Assertion</th>\" : \"\") +\n            \"<th>Message</th></tr></thead>\" +\n            \"<tbody>\";\n        for (var i = 0; i < tests.length; i++) {\n            var test = tests[i];\n            html += '<tr class=\"overall-' +\n                status_class(test.format_status()) +\n                '\">' +\n                '<td class=\"' +\n                status_class(test.format_status()) +\n                '\">' +\n                test.format_status() +\n                \"</td><td>\" +\n                escape_html(test.name) +\n                \"</td><td>\" +\n                (assertions ? escape_html(get_assertion(test)) + \"</td><td>\" : \"\") +\n                escape_html(test.message ? tests[i].message : \" \") +\n                (tests[i].stack ? \"<pre>\" +\n                 escape_html(tests[i].stack) +\n                 \"</pre>\": \"\");\n            if (!(test instanceof RemoteTest)) {\n                 html += \"<details><summary>Asserts run</summary>\" + get_asserts_output(test) + \"</details>\"\n            }\n            html += \"</td></tr>\";\n        }\n        html += \"</tbody></table>\";\n        try {\n            log.lastChild.innerHTML = html;\n        } catch (e) {\n            log.appendChild(document.createElementNS(xhtml_ns, \"p\"))\n               .textContent = \"Setting innerHTML for the log threw an exception.\";\n            log.appendChild(document.createElementNS(xhtml_ns, \"pre\"))\n               .textContent = html;\n        }\n\n        window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"DOWNLOAD\", content: \"\", ts: Date.now()}}))\n    };\n\n    /*\n     * Template code\n     *\n     * A template is just a JavaScript structure. An element is represented as:\n     *\n     * [tag_name, {attr_name:attr_value}, child1, child2]\n     *\n     * the children can either be strings (which act like text nodes), other templates or\n     * functions (see below)\n     *\n     * A text node is represented as\n     *\n     * [\"{text}\", value]\n     *\n     * String values have a simple substitution syntax; ${foo} represents a variable foo.\n     *\n     * It is possible to embed logic in templates by using a function in a place where a\n     * node would usually go. The function must either return part of a template or null.\n     *\n     * In cases where a set of nodes are required as output rather than a single node\n     * with children it is possible to just use a list\n     * [node1, node2, node3]\n     *\n     * Usage:\n     *\n     * render(template, substitutions) - take a template and an object mapping\n     * variable names to parameters and return either a DOM node or a list of DOM nodes\n     *\n     * substitute(template, substitutions) - take a template and variable mapping object,\n     * make the variable substitutions and return the substituted template\n     *\n     */\n\n    function is_single_node(template)\n    {\n        return typeof template[0] === \"string\";\n    }\n\n    function substitute(template, substitutions)\n    {\n        if (typeof template === \"function\") {\n            var replacement = template(substitutions);\n            if (!replacement) {\n                return null;\n            }\n\n            return substitute(replacement, substitutions);\n        }\n\n        if (is_single_node(template)) {\n            return substitute_single(template, substitutions);\n        }\n\n        return filter(map(template, function(x) {\n                              return substitute(x, substitutions);\n                          }), function(x) {return x !== null;});\n    }\n\n    function substitute_single(template, substitutions)\n    {\n        var substitution_re = /\\$\\{([^ }]*)\\}/g;\n\n        function do_substitution(input) {\n            var components = input.split(substitution_re);\n            var rv = [];\n            for (var i = 0; i < components.length; i += 2) {\n                rv.push(components[i]);\n                if (components[i + 1]) {\n                    rv.push(String(substitutions[components[i + 1]]));\n                }\n            }\n            return rv;\n        }\n\n        function substitute_attrs(attrs, rv)\n        {\n            rv[1] = {};\n            for (var name in template[1]) {\n                if (attrs.hasOwnProperty(name)) {\n                    var new_name = do_substitution(name).join(\"\");\n                    var new_value = do_substitution(attrs[name]).join(\"\");\n                    rv[1][new_name] = new_value;\n                }\n            }\n        }\n\n        function substitute_children(children, rv)\n        {\n            for (var i = 0; i < children.length; i++) {\n                if (children[i] instanceof Object) {\n                    var replacement = substitute(children[i], substitutions);\n                    if (replacement !== null) {\n                        if (is_single_node(replacement)) {\n                            rv.push(replacement);\n                        } else {\n                            extend(rv, replacement);\n                        }\n                    }\n                } else {\n                    extend(rv, do_substitution(String(children[i])));\n                }\n            }\n            return rv;\n        }\n\n        var rv = [];\n        rv.push(do_substitution(String(template[0])).join(\"\"));\n\n        if (template[0] === \"{text}\") {\n            substitute_children(template.slice(1), rv);\n        } else {\n            substitute_attrs(template[1], rv);\n            substitute_children(template.slice(2), rv);\n        }\n\n        return rv;\n    }\n\n    function make_dom_single(template, doc)\n    {\n        var output_document = doc || document;\n        var element;\n        if (template[0] === \"{text}\") {\n            element = output_document.createTextNode(\"\");\n            for (var i = 1; i < template.length; i++) {\n                element.data += template[i];\n            }\n        } else {\n            element = output_document.createElementNS(xhtml_ns, template[0]);\n            for (var name in template[1]) {\n                if (template[1].hasOwnProperty(name)) {\n                    element.setAttribute(name, template[1][name]);\n                }\n            }\n            for (var i = 2; i < template.length; i++) {\n                if (template[i] instanceof Object) {\n                    var sub_element = make_dom(template[i]);\n                    element.appendChild(sub_element);\n                } else {\n                    var text_node = output_document.createTextNode(template[i]);\n                    element.appendChild(text_node);\n                }\n            }\n        }\n\n        return element;\n    }\n\n    function make_dom(template, substitutions, output_document)\n    {\n        if (is_single_node(template)) {\n            return make_dom_single(template, output_document);\n        }\n\n        return map(template, function(x) {\n                       return make_dom_single(x, output_document);\n                   });\n    }\n\n    function render(template, substitutions, output_document)\n    {\n        return make_dom(substitute(template, substitutions), output_document);\n    }\n\n    /*\n     * Utility functions\n     */\n    function assert(expected_true, function_name, description, error, substitutions)\n    {\n        if (expected_true !== true && false) {\n            var msg = make_message(function_name, description,\n                                   error, substitutions);\n            throw new AssertionError(msg);\n        }\n    }\n\n    /**\n     * @class\n     * Exception type that represents a failing assert.\n     *\n     * @param {string} message - Error message.\n     */\n    function AssertionError(message)\n    {\n        if (typeof message == \"string\") {\n            message = sanitize_unpaired_surrogates(message);\n        }\n        this.message = message;\n        this.stack = get_stack();\n    }\n    expose(AssertionError, \"AssertionError\");\n\n    AssertionError.prototype = Object.create(Error.prototype);\n\n    const get_stack = function() {\n        var stack = new Error().stack;\n\n        // 'Error.stack' is not supported in all browsers/versions\n        if (!stack) {\n            return \"(Stack trace unavailable)\";\n        }\n\n        var lines = stack.split(\"\\n\");\n\n        // Create a pattern to match stack frames originating within testharness.js.  These include the\n        // script URL, followed by the line/col (e.g., '/resources/testharness.js:120:21').\n        // Escape the URL per http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n        // in case it contains RegExp characters.\n        var script_url = get_script_url();\n        var re_text = script_url ? script_url.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') : \"\\\\btestharness.js\";\n        var re = new RegExp(re_text + \":\\\\d+:\\\\d+\");\n\n        // Some browsers include a preamble that specifies the type of the error object.  Skip this by\n        // advancing until we find the first stack frame originating from testharness.js.\n        var i = 0;\n        while (!re.test(lines[i]) && i < lines.length) {\n            i++;\n        }\n\n        // Then skip the top frames originating from testharness.js to begin the stack at the test code.\n        while (re.test(lines[i]) && i < lines.length) {\n            i++;\n        }\n\n        // Paranoid check that we didn't skip all frames.  If so, return the original stack unmodified.\n        if (i >= lines.length) {\n            return stack;\n        }\n\n        return lines.slice(i).join(\"\\n\");\n    }\n\n    function OptionalFeatureUnsupportedError(message)\n    {\n        AssertionError.call(this, message);\n    }\n    OptionalFeatureUnsupportedError.prototype = Object.create(AssertionError.prototype);\n    expose(OptionalFeatureUnsupportedError, \"OptionalFeatureUnsupportedError\");\n\n    function make_message(function_name, description, error, substitutions)\n    {\n        for (var p in substitutions) {\n            if (substitutions.hasOwnProperty(p)) {\n                substitutions[p] = format_value(substitutions[p]);\n            }\n        }\n        var node_form = substitute([\"{text}\", \"${function_name}: ${description}\" + error],\n                                   merge({function_name:function_name,\n                                          description:(description?description + \" \":\"\")},\n                                          substitutions));\n        return node_form.slice(1).join(\"\");\n    }\n\n    function filter(array, callable, thisObj) {\n        var rv = [];\n        for (var i = 0; i < array.length; i++) {\n            if (array.hasOwnProperty(i)) {\n                var pass = callable.call(thisObj, array[i], i, array);\n                if (pass) {\n                    rv.push(array[i]);\n                }\n            }\n        }\n        return rv;\n    }\n\n    function map(array, callable, thisObj)\n    {\n        var rv = [];\n        rv.length = array.length;\n        for (var i = 0; i < array.length; i++) {\n            if (array.hasOwnProperty(i)) {\n                rv[i] = callable.call(thisObj, array[i], i, array);\n            }\n        }\n        return rv;\n    }\n\n    function extend(array, items)\n    {\n        Array.prototype.push.apply(array, items);\n    }\n\n    function forEach(array, callback, thisObj)\n    {\n        for (var i = 0; i < array.length; i++) {\n            if (array.hasOwnProperty(i)) {\n                callback.call(thisObj, array[i], i, array);\n            }\n        }\n    }\n\n    /**\n     * Immediately invoke a \"iteratee\" function with a series of values in\n     * parallel and invoke a final \"done\" function when all of the \"iteratee\"\n     * invocations have signaled completion.\n     *\n     * If all callbacks complete synchronously (or if no callbacks are\n     * specified), the ``done_callback`` will be invoked synchronously. It is the\n     * responsibility of the caller to ensure asynchronicity in cases where\n     * that is desired.\n     *\n     * @param {array} value Zero or more values to use in the invocation of\n     *                      ``iter_callback``\n     * @param {function} iter_callback A function that will be invoked\n     *                                 once for each of the values min\n     *                                 ``value``. Two arguments will\n     *                                 be available in each\n     *                                 invocation: the value from\n     *                                 ``value`` and a function that\n     *                                 must be invoked to signal\n     *                                 completion\n     * @param {function} done_callback A function that will be invoked after\n     *                                 all operations initiated by the\n     *                                 ``iter_callback`` function have signaled\n     *                                 completion\n     */\n    function all_async(values, iter_callback, done_callback)\n    {\n        var remaining = values.length;\n\n        if (remaining === 0) {\n            done_callback();\n        }\n\n        forEach(values,\n                function(element) {\n                    var invoked = false;\n                    var elDone = function() {\n                        if (invoked) {\n                            return;\n                        }\n\n                        invoked = true;\n                        remaining -= 1;\n\n                        if (remaining === 0) {\n                            done_callback();\n                        }\n                    };\n\n                    iter_callback(element, elDone);\n                });\n    }\n\n    function merge(a,b)\n    {\n        var rv = {};\n        var p;\n        for (p in a) {\n            rv[p] = a[p];\n        }\n        for (p in b) {\n            rv[p] = b[p];\n        }\n        return rv;\n    }\n\n    function expose(object, name)\n    {\n        var components = name.split(\".\");\n        var target = global_scope;\n        for (var i = 0; i < components.length - 1; i++) {\n            if (!(components[i] in target)) {\n                target[components[i]] = {};\n            }\n            target = target[components[i]];\n        }\n        target[components[components.length - 1]] = object;\n    }\n\n    function is_same_origin(w) {\n        try {\n            'random_prop' in w;\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /** Returns the 'src' URL of the first <script> tag in the page to include the file 'testharness.js'. */\n    function get_script_url()\n    {\n        if (!('document' in global_scope)) {\n            return undefined;\n        }\n\n        var scripts = document.getElementsByTagName(\"script\");\n        for (var i = 0; i < scripts.length; i++) {\n            var src;\n            if (scripts[i].src) {\n                src = scripts[i].src;\n            } else if (scripts[i].href) {\n                //SVG case\n                src = scripts[i].href.baseVal;\n            }\n\n            var matches = src && src.match(/^(.*\\/|)testharness\\.js$/);\n            if (matches) {\n                return src;\n            }\n        }\n        return undefined;\n    }\n\n    /** Returns the <title> or filename or \"Untitled\" */\n    function get_title()\n    {\n        if ('document' in global_scope) {\n            //Don't use document.title to work around an Opera/Presto bug in XHTML documents\n            var title = document.getElementsByTagName(\"title\")[0];\n            if (title && title.firstChild && title.firstChild.data) {\n                return title.firstChild.data;\n            }\n        }\n        if ('META_TITLE' in global_scope && META_TITLE) {\n            return META_TITLE;\n        }\n        if ('location' in global_scope && 'pathname' in location) {\n            return location.pathname.substring(location.pathname.lastIndexOf('/') + 1, location.pathname.indexOf('.'));\n        }\n        return \"Untitled\";\n    }\n\n    /**\n     * Setup globals\n     */\n\n    var tests = new Tests();\n\n    if (global_scope.addEventListener) {\n        var error_handler = function(error, message, stack) {\n            var optional_unsupported = error instanceof OptionalFeatureUnsupportedError;\n            if (tests.file_is_test) {\n                var test = tests.tests[0];\n                if (test.phase >= test.phases.HAS_RESULT) {\n                    return;\n                }\n                var status = optional_unsupported ? test.PRECONDITION_FAILED : test.FAIL;\n                test.set_status(status, message, stack);\n                test.phase = test.phases.HAS_RESULT;\n            } else if (!tests.allow_uncaught_exception) {\n                var status = optional_unsupported ? tests.status.PRECONDITION_FAILED : tests.status.ERROR;\n                tests.status.status = status;\n                tests.status.message = message;\n                tests.status.stack = stack;\n            }\n\n            // Do not transition to the \"complete\" phase if the test has been\n            // configured to allow uncaught exceptions. This gives the test an\n            // opportunity to define subtests based on the exception reporting\n            // behavior.\n            if (!tests.allow_uncaught_exception) {\n                done();\n            }\n        };\n\n        addEventListener(\"error\", function(e) {\n            var message = e.message;\n            var stack;\n            if (e.error && e.error.stack) {\n                stack = e.error.stack;\n            } else {\n                stack = e.filename + \":\" + e.lineno + \":\" + e.colno;\n            }\n            error_handler(e.error, message, stack);\n        }, false);\n\n        addEventListener(\"unhandledrejection\", function(e) {\n            var message;\n            if (e.reason && e.reason.message) {\n                message = \"Unhandled rejection: \" + e.reason.message;\n            } else {\n                message = \"Unhandled rejection\";\n            }\n            var stack;\n            if (e.reason && e.reason.stack) {\n                stack = e.reason.stack;\n            }\n            error_handler(e.reason, message, stack);\n        }, false);\n    }\n\n    test_environment.on_tests_ready();\n\n    /**\n     * Stylesheet\n     */\n     var stylesheetContent = \"\\\nhtml {\\\n    font-family:DejaVu Sans, Bitstream Vera Sans, Arial, Sans;\\\n}\\\n\\\n#log .warning,\\\n#log .warning a {\\\n  color: black;\\\n  background: yellow;\\\n}\\\n\\\n#log .error,\\\n#log .error a {\\\n  color: white;\\\n  background: red;\\\n}\\\n\\\nsection#summary {\\\n    margin-bottom:1em;\\\n}\\\n\\\ntable#results {\\\n    border-collapse:collapse;\\\n    table-layout:fixed;\\\n    width:100%;\\\n}\\\n\\\ntable#results > thead > tr > th:first-child,\\\ntable#results > tbody > tr > td:first-child {\\\n    width:8em;\\\n}\\\n\\\ntable#results > thead > tr > th:last-child,\\\ntable#results > thead > tr > td:last-child {\\\n    width:50%;\\\n}\\\n\\\ntable#results.assertions > thead > tr > th:last-child,\\\ntable#results.assertions > tbody > tr > td:last-child {\\\n    width:35%;\\\n}\\\n\\\ntable#results > thead > > tr > th {\\\n    padding:0;\\\n    padding-bottom:0.5em;\\\n    border-bottom:medium solid black;\\\n}\\\n\\\ntable#results > tbody > tr> td {\\\n    padding:1em;\\\n    padding-bottom:0.5em;\\\n    border-bottom:thin solid black;\\\n}\\\n\\\n.pass {\\\n    color:green;\\\n}\\\n\\\n.fail {\\\n    color:red;\\\n}\\\n\\\ntr.timeout {\\\n    color:red;\\\n}\\\n\\\ntr.notrun {\\\n    color:blue;\\\n}\\\n\\\ntr.optionalunsupported {\\\n    color:blue;\\\n}\\\n\\\n.ok {\\\n    color:green;\\\n}\\\n\\\n.error {\\\n    color:red;\\\n}\\\n\\\n.pass, .fail, .timeout, .notrun, .optionalunsupported .ok, .timeout, .error {\\\n    font-variant:small-caps;\\\n}\\\n\\\ntable#results span {\\\n    display:block;\\\n}\\\n\\\ntable#results span.expected {\\\n    font-family:DejaVu Sans Mono, Bitstream Vera Sans Mono, Monospace;\\\n    white-space:pre;\\\n}\\\n\\\ntable#results span.actual {\\\n    font-family:DejaVu Sans Mono, Bitstream Vera Sans Mono, Monospace;\\\n    white-space:pre;\\\n}\\\n\";\n\n})(self);\n// vim: set expandtab shiftwidth=4 tabstop=4:\n"},{"url":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","request_start":1696742123.872195,"response_start":1696742123.8786604,"request_end":1696742123.8746445,"response_end":1696742123.8794014,"ts":1696742123.8796127,"body":"/**\n * @fileoverview Utilities for mixed-content in web-platform-tests.\n * @author burnik@google.com (Kristijan Burnik)\n * Disclaimer: Some methods of other authors are annotated in the corresponding\n *     method's JSDoc.\n */\n\n// ===============================================================\n// Types\n// ===============================================================\n// Objects of the following types are used to represent what kind of\n// subresource requests should be sent with what kind of policies,\n// from what kind of possibly nested source contexts.\n// The objects are represented as JSON objects (not JavaScript/Python classes\n// in a strict sense) to be passed between JavaScript/Python code.\n//\n// See also common/security-features/Types.md for high-level description.\n\n/**\n  @typedef PolicyDelivery\n  @type {object}\n  Referrer policy etc. can be applied/delivered in several ways.\n  A PolicyDelivery object specifies what policy is delivered and how.\n\n  @property {string} deliveryType\n    Specifies how the policy is delivered.\n    The valid deliveryType are:\n\n     \"attr\"\n        [A] DOM attributes e.g. referrerPolicy.\n\n      \"rel-noref\"\n        [A] <link rel=\"noreferrer\"> (referrer-policy only).\n\n      \"http-rp\"\n        [B] HTTP response headers.\n\n      \"meta\"\n        [B] <meta> elements.\n\n  @property {string} key\n  @property {string} value\n    Specifies what policy to be delivered. The valid keys are:\n\n      \"referrerPolicy\"\n        Referrer Policy\n        https://w3c.github.io/webappsec-referrer-policy/\n        Valid values are those listed in\n        https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n        (except that \"\" is represented as null/None)\n\n  A PolicyDelivery can be specified in several ways:\n\n  - (for [A]) Associated with an individual subresource request and\n    specified in `Subresource.policies`,\n    e.g. referrerPolicy attributes of DOM elements.\n    This is handled in invokeRequest().\n\n  - (for [B]) Associated with an nested environmental settings object and\n    specified in `SourceContext.policies`,\n    e.g. HTTP referrer-policy response headers of HTML/worker scripts.\n    This is handled in server-side under /common/security-features/scope/.\n\n  - (for [B]) Associated with the top-level HTML document.\n    This is handled by the generators.d\n*/\n\n/**\n  @typedef Subresource\n  @type {object}\n  A Subresource represents how a subresource request is sent.\n\n  @property{SubresourceType} subresourceType\n    How the subresource request is sent,\n    e.g. \"img-tag\" for sending a request via <img src>.\n    See the keys of `subresourceMap` for valid values.\n\n  @property{string} url\n    subresource's URL.\n    Typically this is constructed by getRequestURLs() below.\n\n  @property{PolicyDelivery} policyDeliveries\n    Policies delivered specific to the subresource request.\n*/\n\n/**\n  @typedef SourceContext\n  @type {object}\n\n  @property {string} sourceContextType\n    Kind of the source context to be used.\n    Valid values are the keys of `sourceContextMap` below.\n\n  @property {Array<PolicyDelivery>} policyDeliveries\n    A list of PolicyDelivery applied to the source context.\n*/\n\n// ===============================================================\n// General utility functions\n// ===============================================================\n\nfunction timeoutPromise(t, ms) {\n  return new Promise(resolve => { t.step_timeout(resolve, ms); });\n}\n\n/**\n * Normalizes the target port for use in a URL. For default ports, this is the\n *     empty string (omitted port), otherwise it's a colon followed by the port\n *     number. Ports 80, 443 and an empty string are regarded as default ports.\n * @param {number} targetPort The port to use\n * @return {string} The port portion for using as part of a URL.\n */\nfunction getNormalizedPort(targetPort) {\n  return ([80, 443, \"\"].indexOf(targetPort) >= 0) ? \"\" : \":\" + targetPort;\n}\n\n/**\n * Creates a GUID.\n *     See: https://en.wikipedia.org/wiki/Globally_unique_identifier\n *     Original author: broofa (http://www.broofa.com/)\n *     Sourced from: http://stackoverflow.com/a/2117523/4949715\n * @return {string} A pseudo-random GUID.\n */\nfunction guid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * Initiates a new XHR via GET.\n * @param {string} url The endpoint URL for the XHR.\n * @param {string} responseType Optional - how should the response be parsed.\n *     Default is \"json\".\n *     See: https://xhr.spec.whatwg.org/#dom-xmlhttprequest-responsetype\n * @return {Promise} A promise wrapping the success and error events.\n */\nfunction xhrRequest(url, responseType) {\n  return new Promise(function(resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = responseType || \"json\";\n\n    xhr.addEventListener(\"error\", function() {\n      reject(Error(\"Network Error\"));\n    });\n\n    xhr.addEventListener(\"load\", function() {\n      if (xhr.status != 200)\n        reject(Error(xhr.statusText));\n      else\n        resolve(xhr.response);\n    });\n\n    xhr.send();\n  });\n}\n\n/**\n * Sets attributes on a given DOM element.\n * @param {DOMElement} element The element on which to set the attributes.\n * @param {object} An object with keys (serving as attribute names) and values.\n */\nfunction setAttributes(el, attrs) {\n  attrs = attrs || {}\n  for (var attr in attrs) {\n    if (attr !== 'src')\n      el.setAttribute(attr, attrs[attr]);\n  }\n  // Workaround for Chromium: set <img>'s src attribute after all other\n  // attributes to ensure the policy is applied.\n  for (var attr in attrs) {\n    if (attr === 'src')\n      el.setAttribute(attr, attrs[attr]);\n  }\n}\n\n/**\n * Binds to success and error events of an object wrapping them into a promise\n *     available through {@code element.eventPromise}. The success event\n *     resolves and error event rejects.\n * This method adds event listeners, and then removes all the added listeners\n * when one of listened event is fired.\n * @param {object} element An object supporting events on which to bind the\n *     promise.\n * @param {string} resolveEventName [=\"load\"] The event name to bind resolve to.\n * @param {string} rejectEventName [=\"error\"] The event name to bind reject to.\n */\nfunction bindEvents(element, resolveEventName, rejectEventName) {\n  element.eventPromise =\n      bindEvents2(element, resolveEventName, element, rejectEventName);\n}\n\n// Returns a promise wrapping success and error events of objects.\n// This is a variant of bindEvents that can accept separate objects for each\n// events and two events to reject, and doesn't set `eventPromise`.\n//\n// When `resolveObject`'s `resolveEventName` event (default: \"load\") is\n// fired, the promise is resolved with the event.\n//\n// When `rejectObject`'s `rejectEventName` event (default: \"error\") or\n// `rejectObject2`'s `rejectEventName2` event (default: \"error\") is\n// fired, the promise is rejected.\n//\n// `rejectObject2` is optional.\nfunction bindEvents2(resolveObject, resolveEventName, rejectObject, rejectEventName, rejectObject2, rejectEventName2) {\n  return new Promise(function(resolve, reject) {\n    const actualResolveEventName = resolveEventName || \"load\";\n    const actualRejectEventName = rejectEventName || \"error\";\n    const actualRejectEventName2 = rejectEventName2 || \"error\";\n\n    const resolveHandler = function(event) {\n      cleanup();\n      resolve(event);\n    };\n\n    const rejectHandler = function(event) {\n      // Chromium starts propagating errors from worker.onerror to\n      // window.onerror. This handles the uncaught exceptions in tests.\n      event.preventDefault();\n      cleanup();\n      reject(event);\n    };\n\n    const cleanup = function() {\n      resolveObject.removeEventListener(actualResolveEventName, resolveHandler);\n      rejectObject.removeEventListener(actualRejectEventName, rejectHandler);\n      if (rejectObject2) {\n        rejectObject2.removeEventListener(actualRejectEventName2, rejectHandler);\n      }\n    };\n\n    resolveObject.addEventListener(actualResolveEventName, resolveHandler);\n    rejectObject.addEventListener(actualRejectEventName, rejectHandler);\n    if (rejectObject2) {\n      rejectObject2.addEventListener(actualRejectEventName2, rejectHandler);\n    }\n  });\n}\n\n/**\n * Creates a new DOM element.\n * @param {string} tagName The type of the DOM element.\n * @param {object} attrs A JSON with attributes to apply to the element.\n * @param {DOMElement} parent Optional - an existing DOM element to append to\n *     If not provided, the returned element will remain orphaned.\n * @param {boolean} doBindEvents Optional - Whether to bind to load and error\n *     events and provide the promise wrapping the events via the element's\n *     {@code eventPromise} property. Default value evaluates to false.\n * @return {DOMElement} The newly created DOM element.\n */\nfunction createElement(tagName, attrs, parentNode, doBindEvents) {\n  var element = document.createElement(tagName);\n\n  if (doBindEvents) {\n    bindEvents(element);\n    if (element.tagName == \"IFRAME\" && !('srcdoc' in attrs || 'src' in attrs)) {\n      // If we're loading a frame, ensure we spin the event loop after load to\n      // paper over the different event timing in Gecko vs Blink/WebKit\n      // see https://github.com/whatwg/html/issues/4965\n      element.eventPromise = element.eventPromise.then(() => {\n        return new Promise(resolve => setTimeout(resolve, 0))\n      });\n    }\n  }\n  // We set the attributes after binding to events to catch any\n  // event-triggering attribute changes. E.g. form submission.\n  //\n  // But be careful with images: unlike other elements they will start the load\n  // as soon as the attr is set, even if not in the document yet, and sometimes\n  // complete it synchronously, so the append doesn't have the effect we want.\n  // So for images, we want to set the attrs after appending, whereas for other\n  // elements we want to do it before appending.\n  var isImg = (tagName == \"img\");\n  if (!isImg)\n    setAttributes(element, attrs);\n\n  if (parentNode)\n    parentNode.appendChild(element);\n\n  if (isImg)\n    setAttributes(element, attrs);\n\n  return element;\n}\n\nfunction createRequestViaElement(tagName, attrs, parentNode) {\n  return createElement(tagName, attrs, parentNode, true).eventPromise;\n}\n\nfunction wrapResult(server_data) {\n  if (typeof(server_data) === \"string\") {\n    throw server_data;\n  }\n  return {\n    referrer: server_data.headers.referer,\n    headers: server_data.headers\n  }\n}\n\n// ===============================================================\n// Subresources\n// ===============================================================\n\n/**\n  @typedef RequestResult\n  @type {object}\n  Represents the result of sending an request.\n  All properties are optional. See the comments for\n  requestVia*() and invokeRequest() below to see which properties are set.\n\n  @property {Array<Object<string, string>>} headers\n    HTTP request headers sent to server.\n  @property {string} referrer - Referrer.\n  @property {string} location - The URL of the subresource.\n  @property {string} sourceContextUrl\n    the URL of the global object where the actual request is sent.\n*/\n\n/**\n  requestVia*(url, additionalAttributes) functions send a subresource\n  request from the current environment settings object.\n\n  @param {string} url\n    The URL of the subresource.\n  @param {Object<string, string>} additionalAttributes\n    Additional attributes set to DOM elements\n    (element-initiated requests only).\n\n  @returns {Promise} that are resolved with a RequestResult object\n  on successful requests.\n\n  - Category 1:\n      `headers`: set.\n      `referrer`: set via `document.referrer`.\n      `location`: set via `document.location`.\n      See `template/document.html.template`.\n  - Category 2:\n      `headers`: set.\n      `referrer`: set to `headers.referer` by `wrapResult()`.\n      `location`: not set.\n  - Category 3:\n      All the keys listed above are NOT set.\n  `sourceContextUrl` is not set here.\n\n  -------------------------------- -------- --------------------------\n  Function name                    Category Used in\n                                            -------- ------- ---------\n                                            referrer mixed-  upgrade-\n                                            policy   content insecure-\n                                            policy   content request\n  -------------------------------- -------- -------- ------- ---------\n  requestViaAnchor                 1        Y        Y       -\n  requestViaArea                   1        Y        Y       -\n  requestViaAudio                  3        -        Y       -\n  requestViaDedicatedWorker        2        Y        Y       Y\n  requestViaFetch                  2        Y        Y       -\n  requestViaForm                   2        -        Y       -\n  requestViaIframe                 1        Y        Y       -\n  requestViaImage                  2        Y        Y       -\n  requestViaLinkPrefetch           3        -        Y       -\n  requestViaLinkStylesheet         3        -        Y       -\n  requestViaObject                 3        -        Y       -\n  requestViaPicture                3        -        Y       -\n  requestViaScript                 2        Y        Y       -\n  requestViaSendBeacon             3        -        Y       -\n  requestViaSharedWorker           2        Y        Y       Y\n  requestViaVideo                  3        -        Y       -\n  requestViaWebSocket              3        -        Y       -\n  requestViaWorklet                3        -        Y       Y\n  requestViaXhr                    2        Y        Y       -\n  -------------------------------- -------- -------- ------- ---------\n*/\n\n/**\n * Creates a new iframe, binds load and error events, sets the src attribute and\n *     appends it to {@code document.body} .\n * @param {string} url The src for the iframe.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaIframe(url, additionalAttributes) {\n  const iframe = createElement(\n      \"iframe\",\n      Object.assign({\"src\": url}, additionalAttributes),\n      document.body,\n      false);\n  return bindEvents2(window, \"message\", iframe, \"error\", window, \"error\")\n      .then(event => {\n          if (event.source !== iframe.contentWindow)\n            return Promise.reject(new Error('Unexpected event.source'));\n          return event.data;\n        });\n}\n\n/**\n * Creates a new image, binds load and error events, sets the src attribute and\n *     appends it to {@code document.body} .\n * @param {string} url The src for the image.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaImage(url, additionalAttributes) {\n  const img = createElement(\n      \"img\",\n      // crossOrigin attribute is added to read the pixel data of the response.\n      Object.assign({\"src\": url, \"crossOrigin\": \"Anonymous\"}, additionalAttributes),\n      document.body, true);\n  return img.eventPromise.then(() => wrapResult(decodeImageData(img)));\n}\n\n// Helper for requestViaImage().\nfunction decodeImageData(img) {\n  var canvas = document.createElement(\"canvas\");\n  var context = canvas.getContext('2d');\n  context.drawImage(img, 0, 0);\n  var imgData = context.getImageData(0, 0, img.clientWidth, img.clientHeight);\n  const rgba = imgData.data;\n\n  let decodedBytes = new Uint8ClampedArray(rgba.length);\n  let decodedLength = 0;\n\n  for (var i = 0; i + 12 <= rgba.length; i += 12) {\n    // A single byte is encoded in three pixels. 8 pixel octets (among\n    // 9 octets = 3 pixels * 3 channels) are used to encode 8 bits,\n    // the most significant bit first, where `0` and `255` in pixel values\n    // represent `0` and `1` in bits, respectively.\n    // This encoding is used to avoid errors due to different color spaces.\n    const bits = [];\n    for (let j = 0; j < 3; ++j) {\n      bits.push(rgba[i + j * 4 + 0]);\n      bits.push(rgba[i + j * 4 + 1]);\n      bits.push(rgba[i + j * 4 + 2]);\n      // rgba[i + j * 4 + 3]: Skip alpha channel.\n    }\n    // The last one element is not used.\n    bits.pop();\n\n    // Decode a single byte.\n    let byte = 0;\n    for (let j = 0; j < 8; ++j) {\n      byte <<= 1;\n      if (bits[j] >= 128)\n        byte |= 1;\n    }\n\n    // Zero is the string terminator.\n    if (byte == 0)\n      break;\n\n    decodedBytes[decodedLength++] = byte;\n  }\n\n  // Remove trailing nulls from data.\n  decodedBytes = decodedBytes.subarray(0, decodedLength);\n  var string_data = (new TextDecoder(\"ascii\")).decode(decodedBytes);\n\n  return JSON.parse(string_data);\n}\n\n/**\n * Initiates a new XHR GET request to provided URL.\n * @param {string} url The endpoint URL for the XHR.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaXhr(url) {\n  return xhrRequest(url).then(result => wrapResult(result));\n}\n\n/**\n * Initiates a new GET request to provided URL via the Fetch API.\n * @param {string} url The endpoint URL for the Fetch.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaFetch(url) {\n  return fetch(url)\n    .then(res => res.json())\n    .then(j => wrapResult(j));\n}\n\nfunction dedicatedWorkerUrlThatFetches(url) {\n  return `data:text/javascript,\n    fetch('${url}')\n      .then(r => r.json())\n      .then(j => postMessage(j))\n      .catch((e) => postMessage(e.message));`;\n}\n\nfunction workerUrlThatImports(url, additionalAttributes) {\n  let csp = \"\";\n  if (additionalAttributes && additionalAttributes.contentSecurityPolicy) {\n    csp=`&contentSecurityPolicy=${additionalAttributes.contentSecurityPolicy}`;\n  }\n  return `/common/security-features/subresource/static-import.py` +\n      `?import_url=${encodeURIComponent(url)}${csp}`;\n}\n\nfunction workerDataUrlThatImports(url) {\n  return `data:text/javascript,import '${url}';`;\n}\n\n/**\n * Creates a new Worker, binds message and error events wrapping them into.\n *     {@code worker.eventPromise} and posts an empty string message to start\n *     the worker.\n * @param {string} url The endpoint URL for the worker script.\n * @param {object} options The options for Worker constructor.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaDedicatedWorker(url, options) {\n  var worker;\n  try {\n    worker = new Worker(url, options);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n  worker.postMessage('');\n  return bindEvents2(worker, \"message\", worker, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\nfunction requestViaSharedWorker(url, options) {\n  var worker;\n  try {\n    worker = new SharedWorker(url, options);\n  } catch(e) {\n    return Promise.reject(e);\n  }\n  const promise = bindEvents2(worker.port, \"message\", worker, \"error\")\n    .then(event => wrapResult(event.data));\n  worker.port.start();\n  return promise;\n}\n\n// Returns a reference to a worklet object corresponding to a given type.\nfunction get_worklet(type) {\n  if (type == 'animation')\n    return CSS.animationWorklet;\n  if (type == 'layout')\n    return CSS.layoutWorklet;\n  if (type == 'paint')\n    return CSS.paintWorklet;\n  if (type == 'audio')\n    return new OfflineAudioContext(2,44100*40,44100).audioWorklet;\n\n  throw new Error('unknown worklet type is passed.');\n}\n\nfunction requestViaWorklet(type, url) {\n  try {\n    return get_worklet(type).addModule(url);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Creates a navigable element with the name `navigableElementName`\n * (<a>, <area>, or <form>) under `parentNode`, and\n * performs a navigation by `trigger()` (e.g. clicking <a>).\n * To avoid navigating away from the current execution context,\n * a target attribute is set to point to a new helper iframe.\n * @param {string} navigableElementName\n * @param {object} additionalAttributes The attributes of the navigable element.\n * @param {DOMElement} parentNode\n * @param {function(DOMElement} trigger A callback called after the navigable\n * element is inserted and should trigger navigation using the element.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaNavigable(navigableElementName, additionalAttributes,\n                             parentNode, trigger) {\n  const name = guid();\n\n  const iframe =\n    createElement(\"iframe\", {\"name\": name, \"id\": name}, parentNode, false);\n\n  const navigable = createElement(\n      navigableElementName,\n      Object.assign({\"target\": name}, additionalAttributes),\n      parentNode, false);\n\n  const promise =\n    bindEvents2(window, \"message\", iframe, \"error\", window, \"error\")\n      .then(event => {\n          if (event.source !== iframe.contentWindow)\n            return Promise.reject(new Error('Unexpected event.source'));\n          return event.data;\n        });\n  trigger(navigable);\n  return promise;\n}\n\n/**\n * Creates a new anchor element, appends it to {@code document.body} and\n *     performs the navigation.\n * @param {string} url The URL to navigate to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaAnchor(url, additionalAttributes) {\n  return requestViaNavigable(\n      \"a\",\n      Object.assign({\"href\": url, \"innerHTML\": \"Link to resource\"},\n                    additionalAttributes),\n      document.body, a => a.click());\n}\n\n/**\n * Creates a new area element, appends it to {@code document.body} and performs\n *     the navigation.\n * @param {string} url The URL to navigate to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaArea(url, additionalAttributes) {\n  // TODO(kristijanburnik): Append to map and add image.\n  return requestViaNavigable(\n      \"area\",\n      Object.assign({\"href\": url}, additionalAttributes),\n      document.body, area => area.click());\n}\n\n/**\n * Creates a new script element, sets the src to url, and appends it to\n *     {@code document.body}.\n * @param {string} url The src URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaScript(url, additionalAttributes) {\n  const script = createElement(\n      \"script\",\n      Object.assign({\"src\": url}, additionalAttributes),\n      document.body,\n      false);\n\n  return bindEvents2(window, \"message\", script, \"error\", window, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\n/**\n * Creates a new script element that performs a dynamic import to `url`, and\n * appends the script element to {@code document.body}.\n * @param {string} url The src URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaDynamicImport(url, additionalAttributes) {\n  const scriptUrl = `data:text/javascript,import(\"${url}\");`;\n  const script = createElement(\n      \"script\",\n      Object.assign({\"src\": scriptUrl}, additionalAttributes),\n      document.body,\n      false);\n\n  return bindEvents2(window, \"message\", script, \"error\", window, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\n/**\n * Creates a new form element, sets attributes, appends it to\n *     {@code document.body} and submits the form.\n * @param {string} url The URL to submit to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaForm(url, additionalAttributes) {\n  return requestViaNavigable(\n      \"form\",\n      Object.assign({\"action\": url, \"method\": \"POST\"}, additionalAttributes),\n      document.body, form => form.submit());\n}\n\n/**\n * Creates a new link element for a stylesheet, binds load and error events,\n *     sets the href to url and appends it to {@code document.head}.\n * @param {string} url The URL for a stylesheet.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaLinkStylesheet(url) {\n  return createRequestViaElement(\"link\",\n                                 {\"rel\": \"stylesheet\", \"href\": url},\n                                 document.head);\n}\n\n/**\n * Creates a new link element for a prefetch, binds load and error events, sets\n *     the href to url and appends it to {@code document.head}.\n * @param {string} url The URL of a resource to prefetch.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaLinkPrefetch(url) {\n  var link = document.createElement('link');\n  if (link.relList && link.relList.supports && link.relList.supports(\"prefetch\")) {\n    return createRequestViaElement(\"link\",\n                                   {\"rel\": \"prefetch\", \"href\": url},\n                                   document.head);\n  } else {\n    return Promise.reject(\"This browser does not support 'prefetch'.\");\n  }\n}\n\n/**\n * Initiates a new beacon request.\n * @param {string} url The URL of a resource to prefetch.\n * @return {Promise} The promise for success/error events.\n */\nasync function requestViaSendBeacon(url) {\n  function wait(ms) {\n    return new Promise(resolve => step_timeout(resolve, ms));\n  }\n  if (!navigator.sendBeacon(url)) {\n    // If mixed-content check fails, it should return false.\n    throw new Error('sendBeacon() fails.');\n  }\n  // We don't have a means to see the result of sendBeacon() request\n  // for sure. Let's wait for a while and let the generic test function\n  // ask the server for the result.\n  await wait(500);\n  return 'allowed';\n}\n\n/**\n * Creates a new media element with a child source element, binds loadeddata and\n *     error events, sets attributes and appends to document.body.\n * @param {string} type The type of the media element (audio/video/picture).\n * @param {object} media_attrs The attributes for the media element.\n * @param {object} source_attrs The attributes for the child source element.\n * @return {DOMElement} The newly created media element.\n */\nfunction createMediaElement(type, media_attrs, source_attrs) {\n  var mediaElement = createElement(type, {});\n\n  var sourceElement = createElement(\"source\", {});\n\n  mediaElement.eventPromise = new Promise(function(resolve, reject) {\n    mediaElement.addEventListener(\"loadeddata\", function (e) {\n      resolve(e);\n    });\n\n    // Safari doesn't fire an `error` event when blocking mixed content.\n    mediaElement.addEventListener(\"stalled\", function(e) {\n      reject(e);\n    });\n\n    sourceElement.addEventListener(\"error\", function(e) {\n      reject(e);\n    });\n  });\n\n  setAttributes(mediaElement, media_attrs);\n  setAttributes(sourceElement, source_attrs);\n\n  mediaElement.appendChild(sourceElement);\n  document.body.appendChild(mediaElement);\n\n  return mediaElement;\n}\n\n/**\n * Creates a new video element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}.\n * @param {string} url The URL of the video.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaVideo(url) {\n  return createMediaElement(\"video\",\n                            {},\n                            {\"src\": url}).eventPromise;\n}\n\n/**\n * Creates a new audio element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}.\n * @param {string} url The URL of the audio.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaAudio(url) {\n  return createMediaElement(\"audio\",\n                            {},\n                            {\"type\": \"audio/wav\", \"src\": url}).eventPromise;\n}\n\n/**\n * Creates a new picture element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}. Also\n *     creates new image element appending it to the picture\n * @param {string} url The URL of the image for the source and image elements.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaPicture(url) {\n  var picture = createMediaElement(\"picture\", {}, {\"srcset\": url,\n                                                \"type\": \"image/png\"});\n  return createRequestViaElement(\"img\", {\"src\": url}, picture);\n}\n\n/**\n * Creates a new object element, binds load and error events, sets the data to\n *     url, and appends it to {@code document.body}.\n * @param {string} url The data URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaObject(url) {\n  return createRequestViaElement(\"object\", {\"data\": url, \"type\": \"text/html\"}, document.body);\n}\n\n/**\n * Creates a new WebSocket pointing to {@code url} and sends a message string\n * \"echo\". The {@code message} and {@code error} events are triggering the\n * returned promise resolve/reject events.\n * @param {string} url The URL for WebSocket to connect to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaWebSocket(url) {\n  return new Promise(function(resolve, reject) {\n    var websocket = new WebSocket(url);\n\n    websocket.addEventListener(\"message\", function(e) {\n      resolve(e.data);\n    });\n\n    websocket.addEventListener(\"open\", function(e) {\n      websocket.send(\"echo\");\n    });\n\n    websocket.addEventListener(\"error\", function(e) {\n      reject(e)\n    });\n  })\n  .then(data => {\n      return JSON.parse(data);\n    });\n}\n\n/**\n  @typedef SubresourceType\n  @type {string}\n\n  Represents how a subresource is sent.\n  The keys of `subresourceMap` below are the valid values.\n*/\n\n// Subresource paths and invokers.\nconst subresourceMap = {\n  \"a-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaAnchor,\n  },\n  \"area-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaArea,\n  },\n  \"audio-tag\": {\n    path: \"/common/security-features/subresource/audio.py\",\n    invoker: requestViaAudio,\n  },\n  \"beacon\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaSendBeacon,\n  },\n  \"fetch\": {\n    path: \"/common/security-features/subresource/xhr.py\",\n    invoker: requestViaFetch,\n  },\n  \"form-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaForm,\n  },\n  \"iframe-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaIframe,\n  },\n  \"img-tag\": {\n    path: \"/common/security-features/subresource/image.py\",\n    invoker: requestViaImage,\n  },\n  \"link-css-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaLinkStylesheet,\n  },\n  \"link-prefetch-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaLinkPrefetch,\n  },\n  \"object-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaObject,\n  },\n  \"picture-tag\": {\n    path: \"/common/security-features/subresource/image.py\",\n    invoker: requestViaPicture,\n  },\n  \"script-tag\": {\n    path: \"/common/security-features/subresource/script.py\",\n    invoker: requestViaScript,\n  },\n  \"script-tag-dynamic-import\": {\n    path: \"/common/security-features/subresource/script.py\",\n    invoker: requestViaDynamicImport,\n  },\n  \"video-tag\": {\n    path: \"/common/security-features/subresource/video.py\",\n    invoker: requestViaVideo,\n  },\n  \"xhr\": {\n    path: \"/common/security-features/subresource/xhr.py\",\n    invoker: requestViaXhr,\n  },\n\n  \"worker-classic\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url => requestViaDedicatedWorker(url),\n  },\n  \"worker-module\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url => requestViaDedicatedWorker(url, {type: \"module\"}),\n  },\n  \"worker-import\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: (url, additionalAttributes) =>\n        requestViaDedicatedWorker(workerUrlThatImports(url, additionalAttributes), {type: \"module\"}),\n  },\n  \"worker-import-data\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url =>\n        requestViaDedicatedWorker(workerDataUrlThatImports(url), {type: \"module\"}),\n  },\n  \"sharedworker-classic\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url => requestViaSharedWorker(url),\n  },\n  \"sharedworker-module\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url => requestViaSharedWorker(url, {type: \"module\"}),\n  },\n  \"sharedworker-import\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: (url, additionalAttributes) =>\n        requestViaSharedWorker(workerUrlThatImports(url, additionalAttributes), {type: \"module\"}),\n  },\n  \"sharedworker-import-data\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url =>\n        requestViaSharedWorker(workerDataUrlThatImports(url), {type: \"module\"}),\n  },\n\n  \"websocket\": {\n    path: \"/stash_responder\",\n    invoker: requestViaWebSocket,\n  },\n};\nfor (const workletType of ['animation', 'audio', 'layout', 'paint']) {\n  subresourceMap[`worklet-${workletType}`] = {\n      path: \"/common/security-features/subresource/worker.py\",\n      invoker: url => requestViaWorklet(workletType, url)\n    };\n  subresourceMap[`worklet-${workletType}-import-data`] = {\n      path: \"/common/security-features/subresource/worker.py\",\n      invoker: url =>\n          requestViaWorklet(workletType, workerDataUrlThatImports(url))\n    };\n}\n\n/**\n  @typedef RedirectionType\n  @type {string}\n\n  Represents what redirects should occur to the subresource request\n  after initial request.\n  See preprocess_redirection() in\n  /common/security-features/subresource/subresource.py for valid values.\n*/\n\n/**\n  Construct subresource (and related) origin.\n\n  @param {string} originType\n  @returns {object} the origin of the subresource.\n*/\nfunction getSubresourceOrigin(originType) {\n  const httpProtocol = \"http\";\n  const httpsProtocol = \"https\";\n  const wsProtocol = \"ws\";\n  const wssProtocol = \"wss\";\n\n  const sameOriginHost = \"web-platform.test\";\n  const crossOriginHost = \"www1.web-platform.test\";\n\n  // These values can evaluate to either empty strings or a \":port\" string.\n  const httpPort = getNormalizedPort(parseInt(\"8000\", 10));\n  const httpsRawPort = parseInt(\"8443\", 10);\n  const httpsPort = getNormalizedPort(httpsRawPort);\n  const wsPort = getNormalizedPort(parseInt(\"8888\", 10));\n  const wssRawPort = parseInt(\"8889\", 10);\n  const wssPort = getNormalizedPort(wssRawPort);\n\n  /**\n    @typedef OriginType\n    @type {string}\n\n    Represents the origin of the subresource request URL.\n    The keys of `originMap` below are the valid values.\n\n    Note that there can be redirects from the specified origin\n    (see RedirectionType), and thus the origin of the subresource\n    response URL might be different from what is specified by OriginType.\n  */\n  const originMap = {\n    \"same-https\": httpsProtocol + \"://\" + sameOriginHost + httpsPort,\n    \"same-http\": httpProtocol + \"://\" + sameOriginHost + httpPort,\n    \"cross-https\": httpsProtocol + \"://\" + crossOriginHost + httpsPort,\n    \"cross-http\": httpProtocol + \"://\" + crossOriginHost + httpPort,\n    \"same-wss\": wssProtocol + \"://\" + sameOriginHost + wssPort,\n    \"same-ws\": wsProtocol + \"://\" + sameOriginHost + wsPort,\n    \"cross-wss\": wssProtocol + \"://\" + crossOriginHost + wssPort,\n    \"cross-ws\": wsProtocol + \"://\" + crossOriginHost + wsPort,\n\n    // The following origin types are used for upgrade-insecure-requests tests:\n    // These rely on some unintuitive cleverness due to WPT's test setup:\n    // 'Upgrade-Insecure-Requests' does not upgrade the port number,\n    // so we use URLs in the form `http://[domain]:[https-port]`,\n    // which will be upgraded to `https://[domain]:[https-port]`.\n    // If the upgrade fails, the load will fail, as we don't serve HTTP over\n    // the secure port.\n    \"same-http-downgrade\":\n        httpProtocol + \"://\" + sameOriginHost + \":\" + httpsRawPort,\n    \"cross-http-downgrade\":\n        httpProtocol + \"://\" + crossOriginHost + \":\" + httpsRawPort,\n    \"same-ws-downgrade\":\n        wsProtocol + \"://\" + sameOriginHost + \":\" + wssRawPort,\n    \"cross-ws-downgrade\":\n        wsProtocol + \"://\" + crossOriginHost + \":\" + wssRawPort,\n  };\n\n  return originMap[originType];\n}\n\n/**\n  Construct subresource (and related) URLs.\n\n  @param {SubresourceType} subresourceType\n  @param {OriginType} originType\n  @param {RedirectionType} redirectionType\n  @returns {object} with following properties:\n    {string} testUrl\n      The subresource request URL.\n    {string} announceUrl\n    {string} assertUrl\n      The URLs to be used for detecting whether `testUrl` is actually sent\n      to the server.\n      1. Fetch `announceUrl` first,\n      2. then possibly fetch `testUrl`, and\n      3. finally fetch `assertUrl`.\n         The fetch result of `assertUrl` should indicate whether\n         `testUrl` is actually sent to the server or not.\n*/\nfunction getRequestURLs(subresourceType, originType, redirectionType) {\n  const key = guid();\n  const value = guid();\n\n  // We use the same stash path for both HTTP/S and WS/S stash requests.\n  const stashPath = encodeURIComponent(\"/mixed-content\");\n\n  const stashEndpoint = \"/common/security-features/subresource/xhr.py?key=\" +\n                        key + \"&path=\" + stashPath;\n  return {\n    testUrl:\n      getSubresourceOrigin(originType) +\n        subresourceMap[subresourceType].path +\n        \"?redirection=\" + encodeURIComponent(redirectionType) +\n        \"&action=purge&key=\" + key +\n        \"&path=\" + stashPath,\n    announceUrl: stashEndpoint + \"&action=put&value=\" + value,\n    assertUrl: stashEndpoint + \"&action=take\",\n  };\n}\n\n// ===============================================================\n// Source Context\n// ===============================================================\n// Requests can be sent from several source contexts,\n// such as the main documents, iframes, workers, or so,\n// possibly nested, and possibly with <meta>/http headers added.\n// invokeRequest() and invokeFrom*() functions handles\n// SourceContext-related setup in client-side.\n\n/**\n  invokeRequest() invokes a subresource request\n  (specified as `subresource`)\n  from a (possibly nested) environment settings object\n  (specified as `sourceContextList`).\n\n  For nested contexts, invokeRequest() calls an invokeFrom*() function\n  that creates a nested environment settings object using\n  /common/security-features/scope/, which calls invokeRequest()\n  again inside the nested environment settings object.\n  This cycle continues until all specified\n  nested environment settings object are created, and\n  finally invokeRequest() calls a requestVia*() function to start the\n  subresource request from the inner-most environment settings object.\n\n  @param {Subresource} subresource\n  @param {Array<SourceContext>} sourceContextList\n\n  @returns {Promise} A promise that is resolved with an RequestResult object.\n  `sourceContextUrl` is always set. For whether other properties are set,\n  see the comments for requestVia*() above.\n*/\nfunction invokeRequest(subresource, sourceContextList) {\n  if (sourceContextList.length === 0) {\n    // No further nested global objects. Send the subresource request here.\n\n    const additionalAttributes = {};\n    /** @type {PolicyDelivery} policyDelivery */\n    for (const policyDelivery of (subresource.policyDeliveries || [])) {\n      // Depending on the delivery method, extend the subresource element with\n      // these attributes.\n      if (policyDelivery.deliveryType === \"attr\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      } else if (policyDelivery.deliveryType === \"rel-noref\") {\n        additionalAttributes[\"rel\"] = \"noreferrer\";\n      } else if (policyDelivery.deliveryType === \"http-rp\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      } else if (policyDelivery.deliveryType === \"meta\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      }\n    }\n\n    return subresourceMap[subresource.subresourceType].invoker(\n        subresource.url,\n        additionalAttributes)\n      .then(result => Object.assign(\n          {sourceContextUrl: location.toString()},\n          result));\n  }\n\n  // Defines invokers for each valid SourceContext.sourceContextType.\n  const sourceContextMap = {\n    \"srcdoc\": { // <iframe srcdoc></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"iframe\": { // <iframe src=\"same-origin-URL\"></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"iframe-blank\": { // <iframe></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"worker-classic\": {\n      // Classic dedicated worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", false, {}),\n    },\n    \"worker-classic-data\": {\n      // Classic dedicated worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", true, {}),\n    },\n    \"worker-module\": {\n      // Module dedicated worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", false, {type: 'module'}),\n    },\n    \"worker-module-data\": {\n      // Module dedicated worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", true, {type: 'module'}),\n    },\n    \"sharedworker-classic\": {\n      // Classic shared worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", false, {}),\n    },\n    \"sharedworker-classic-data\": {\n      // Classic shared worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", true, {}),\n    },\n    \"sharedworker-module\": {\n      // Module shared worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", false, {type: 'module'}),\n    },\n    \"sharedworker-module-data\": {\n      // Module shared worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", true, {type: 'module'}),\n    },\n  };\n\n  return sourceContextMap[sourceContextList[0].sourceContextType].invoker(\n      subresource, sourceContextList);\n}\n\n// Quick hack to expose invokeRequest when common.sub.js is loaded either\n// as a classic or module script.\nself.invokeRequest = invokeRequest;\n\n/**\n  invokeFrom*() functions are helper functions with the same parameters\n  and return values as invokeRequest(), that are tied to specific types\n  of top-most environment settings objects.\n  For example, invokeFromIframe() is the helper function for the cases where\n  sourceContextList[0] is an iframe.\n*/\n\n/**\n  @param {string} workerType\n    \"worker\" (for dedicated worker) or \"sharedworker\".\n  @param {boolean} isDataUrl\n    true if the worker script is loaded from data: URL.\n    Otherwise, the script is loaded from same-origin.\n  @param {object} workerOptions\n    The `options` argument for Worker constructor.\n\n  Other parameters and return values are the same as those of invokeRequest().\n*/\nfunction invokeFromWorker(workerType, isDataUrl, workerOptions,\n                          subresource, sourceContextList) {\n  const currentSourceContext = sourceContextList[0];\n  let workerUrl =\n    \"/common/security-features/scope/worker.py?policyDeliveries=\" +\n    encodeURIComponent(JSON.stringify(\n        currentSourceContext.policyDeliveries || []));\n  if (workerOptions.type === 'module') {\n    workerUrl += \"&type=module\";\n  }\n\n  let promise;\n  if (isDataUrl) {\n    promise = fetch(workerUrl)\n      .then(r => r.text())\n      .then(source => {\n          return 'data:text/javascript;base64,' + btoa(source);\n        });\n  } else {\n    promise = Promise.resolve(workerUrl);\n  }\n\n  return promise\n    .then(url => {\n      if (workerType === \"worker\") {\n        const worker = new Worker(url, workerOptions);\n        worker.postMessage({subresource: subresource,\n                            sourceContextList: sourceContextList.slice(1)});\n        return bindEvents2(worker, \"message\", worker, \"error\", window, \"error\");\n      } else if (workerType === \"sharedworker\") {\n        const worker = new SharedWorker(url, workerOptions);\n        worker.port.start();\n        worker.port.postMessage({subresource: subresource,\n                                 sourceContextList: sourceContextList.slice(1)});\n        return bindEvents2(worker.port, \"message\", worker, \"error\", window, \"error\");\n      } else {\n        throw new Error('Invalid worker type: ' + workerType);\n      }\n    })\n    .then(event => {\n        if (event.data.error)\n          return Promise.reject(event.data.error);\n        return event.data;\n      });\n}\n\nfunction invokeFromIframe(subresource, sourceContextList) {\n  const currentSourceContext = sourceContextList[0];\n  const frameUrl =\n    \"/common/security-features/scope/document.py?policyDeliveries=\" +\n    encodeURIComponent(JSON.stringify(\n        currentSourceContext.policyDeliveries || []));\n\n  let iframe;\n  let promise;\n  if (currentSourceContext.sourceContextType === 'srcdoc') {\n    promise = fetch(frameUrl)\n      .then(r => r.text())\n      .then(srcdoc => {\n          iframe = createElement(\n              \"iframe\", {srcdoc: srcdoc}, document.body, true);\n          return iframe.eventPromise;\n        });\n  } else if (currentSourceContext.sourceContextType === 'iframe') {\n    iframe = createElement(\"iframe\", {src: frameUrl}, document.body, true);\n    promise = iframe.eventPromise;\n  } else if (currentSourceContext.sourceContextType === 'iframe-blank') {\n    let frameContent;\n    promise = fetch(frameUrl)\n      .then(r => r.text())\n      .then(t => {\n          frameContent = t;\n          iframe = createElement(\"iframe\", {}, document.body, true);\n          return iframe.eventPromise;\n        })\n      .then(() => {\n          // Reinitialize `iframe.eventPromise` with a new promise\n          // that catches the load event for the document.write() below.\n          bindEvents(iframe);\n\n          iframe.contentDocument.write(frameContent);\n          iframe.contentDocument.close();\n          return iframe.eventPromise;\n        });\n  }\n\n  return promise\n    .then(() => {\n        const promise = bindEvents2(\n            window, \"message\", iframe, \"error\", window, \"error\");\n        iframe.contentWindow.postMessage(\n            {subresource: subresource,\n             sourceContextList: sourceContextList.slice(1)},\n            \"*\");\n        return promise;\n      })\n    .then(event => {\n        if (event.data.error)\n          return Promise.reject(event.data.error);\n        return event.data;\n      });\n}\n\n// SanityChecker does nothing in release mode. See sanity-checker.js for debug\n// mode.\nfunction SanityChecker() {}\nSanityChecker.prototype.checkScenario = function() {};\nSanityChecker.prototype.setFailTimeout = function(test, timeout) {};\nSanityChecker.prototype.checkSubresourceResult = function() {};\n"},{"url":"https://web-platform.test:8443/resources/testharnessreport.js","request_start":1696742123.863972,"response_start":1696742123.9116595,"request_end":1696742123.8656645,"response_end":1696742123.912471,"ts":1696742123.912668,"body":"class MessageQueue {\n  constructor() {\n    this.item_id = 0;\n    this._queue = [];\n  }\n\n  push(item) {\n    let cmd_id = this.item_id++;\n    item.id = cmd_id;\n    this._queue.push(item);\n    __wptrunner_process_next_event();\n    return cmd_id;\n  }\n\n  shift() {\n    return this._queue.shift();\n  }\n}\n\nwindow.__wptrunner_testdriver_callback = null;\nwindow.__wptrunner_message_queue = new MessageQueue();\nwindow.__wptrunner_url = null;\n\nwindow.__wptrunner_process_next_event = function() {\n  /* This function handles the next testdriver event. The presence of\n     window.testdriver_callback is used as a switch; when that function\n     is present we are able to handle the next event and when is is not\n     present we must wait. Therefore to drive the event processing, this\n     function must be called in two circumstances:\n       * Every time there is a new event that we may be able to handle\n       * Every time we set the callback function\n     This function unsets the callback, so no further testdriver actions\n     will be run until it is reset, which wptrunner does after it has\n     completed handling the current action.\n   */\n\n  if (!window.__wptrunner_testdriver_callback) {\n    return;\n  }\n  var data = window.__wptrunner_message_queue.shift();\n  if (!data) {\n    return;\n  }\n\n  var payload = undefined;\n\n  switch(data.type) {\n  case \"complete\":\n    var tests = data.tests;\n    var status = data.status;\n\n    var subtest_results = tests.map(function(x) {\n      return [x.name, x.status, x.message, x.stack];\n    });\n    payload = [status.status,\n               status.message,\n               status.stack,\n               subtest_results];\n    clearTimeout(window.__wptrunner_timer);\n    break;\n  case \"action\":\n    payload = data;\n    break;\n  default:\n    return;\n  }\n  var callback = window.__wptrunner_testdriver_callback;\n  window.__wptrunner_testdriver_callback = null;\n  callback([__wptrunner_url, data.type, payload]);\n};\n\n(function() {\n  var props = {output: 1,\n               timeout_multiplier: 1,\n               explicit_timeout: false,\n               debug: false,\n               message_events: [\"completion\"]};\n\n  add_completion_callback(function(tests, harness_status) {\n    __wptrunner_message_queue.push({\n      \"type\": \"complete\",\n      \"tests\": tests,\n      \"status\": harness_status});\n    __wptrunner_process_next_event();\n  });\n  setup(props);\n})();\n\n"},{"url":"https://web-platform.test:8443/mixed-content/generic/test-case.sub.js","request_start":1696742123.8772042,"response_start":1696742123.9234781,"request_end":1696742123.8777628,"response_end":1696742123.9241207,"ts":1696742123.9242878,"body":"/**\n * @fileoverview Test case for mixed-content in web-platform-tests.\n * @author burnik@google.com (Kristijan Burnik)\n */\n\n/**\n * MixedContentTestCase exercises all the tests for checking browser behavior\n * when resources regarded as mixed-content are requested. A single run covers\n * only a single scenario.\n * @param {object} scenario A JSON describing the test arrangement and\n *     expectation(s). Refer to /mixed-content/spec.src.json for details.\n * @param {string} description The test scenario verbose description.\n * @param {SanityChecker} sanityChecker Instance of an object used to check the\n *     running scenario. Useful in debug mode. See ./sanity-checker.js.\n *     Run {@code ./tools/generate.py -h} for info on test generating modes.\n * @return {object} Object wrapping the start method used to run the test.\n */\nfunction TestCase(scenarios, sanityChecker) {\n  function runTest(scenario) {\n    sanityChecker.checkScenario(scenario, subresourceMap);\n\n    const urls = getRequestURLs(scenario.subresource,\n                                scenario.origin,\n                                scenario.redirection);\n    const checkResult = _ => {\n      // Send request to check if the key has been torn down.\n      return xhrRequest(urls.assertUrl)\n        .then(assertResult => {\n            // Now check if the value has been torn down. If it's still there,\n            // we have blocked the request to mixed-content.\n            assert_equals(assertResult.status, scenario.expectation,\n              \"The resource request should be '\" + scenario.expectation + \"'.\");\n          });\n    };\n\n    /** @type {Subresource} */\n    const subresource = {\n      subresourceType: scenario.subresource,\n      url: urls.testUrl,\n      policyDeliveries: scenario.subresource_policy_deliveries,\n    };\n\n    promise_test(() => {\n      return xhrRequest(urls.announceUrl)\n        // Send out the real resource request.\n        // This should tear down the key if it's not blocked.\n        .then(_ => invokeRequest(subresource, scenario.source_context_list))\n        // We check the key state, regardless of whether the main request\n        // succeeded or failed.\n        .then(checkResult, checkResult);\n      }, scenario.test_description);\n  }  // runTest\n\n  function runTests() {\n    for (const scenario of scenarios) {\n      runTest(scenario);\n    }\n  }\n\n  return {start: runTests};\n}\n"},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=put&value=8dd73b9d-3879-47ea-b60b-33460b5aa4d9","request_start":1696742123.9324617,"response_start":1696742123.946124,"request_end":1696742123.9331613,"response_end":1696742123.9467678,"ts":1696742123.9470184,"body":"{\"status\": \"success\", \"result\": \"b2923c98-5e82-4e85-804d-d49185012241\"}"},{"url":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","request_start":1696742123.951665,"response_start":1696742123.9563758,"request_end":1696742123.9522352,"response_end":1696742123.9569075,"ts":1696742123.957138,"body":"import \"https://web-platform.test:8443/common/security-features/resources/common.sub.js\";\n\nif ('DedicatedWorkerGlobalScope' in self &&\n    self instanceof DedicatedWorkerGlobalScope) {\n  self.onmessage = event => onMessageFromParent(event, self);\n} else if ('SharedWorkerGlobalScope' in self &&\n    self instanceof SharedWorkerGlobalScope) {\n  onconnect = event => {\n    const port = event.ports[0];\n    port.onmessage = event => onMessageFromParent(event, port);\n  };\n}\n\n// Receive a message from the parent and start the test.\nfunction onMessageFromParent(event, port) {\n  const configurationError = \"\";\n  if (configurationError.length > 0) {\n    port.postMessage({error: configurationError});\n    return;\n  }\n\n  invokeRequest(event.data.subresource,\n                event.data.sourceContextList)\n    .then(result => port.postMessage(result))\n    .catch(e => {\n        const message = (e.error && e.error.stack) || e.message || \"Error\";\n        port.postMessage({error: message});\n      });\n}\n"},{"url":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","request_start":1696742123.992888,"response_start":1696742123.9959984,"request_end":1696742123.9935048,"response_end":1696742123.9966328,"ts":1696742123.9968522,"body":"/**\n * @fileoverview Utilities for mixed-content in web-platform-tests.\n * @author burnik@google.com (Kristijan Burnik)\n * Disclaimer: Some methods of other authors are annotated in the corresponding\n *     method's JSDoc.\n */\n\n// ===============================================================\n// Types\n// ===============================================================\n// Objects of the following types are used to represent what kind of\n// subresource requests should be sent with what kind of policies,\n// from what kind of possibly nested source contexts.\n// The objects are represented as JSON objects (not JavaScript/Python classes\n// in a strict sense) to be passed between JavaScript/Python code.\n//\n// See also common/security-features/Types.md for high-level description.\n\n/**\n  @typedef PolicyDelivery\n  @type {object}\n  Referrer policy etc. can be applied/delivered in several ways.\n  A PolicyDelivery object specifies what policy is delivered and how.\n\n  @property {string} deliveryType\n    Specifies how the policy is delivered.\n    The valid deliveryType are:\n\n     \"attr\"\n        [A] DOM attributes e.g. referrerPolicy.\n\n      \"rel-noref\"\n        [A] <link rel=\"noreferrer\"> (referrer-policy only).\n\n      \"http-rp\"\n        [B] HTTP response headers.\n\n      \"meta\"\n        [B] <meta> elements.\n\n  @property {string} key\n  @property {string} value\n    Specifies what policy to be delivered. The valid keys are:\n\n      \"referrerPolicy\"\n        Referrer Policy\n        https://w3c.github.io/webappsec-referrer-policy/\n        Valid values are those listed in\n        https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n        (except that \"\" is represented as null/None)\n\n  A PolicyDelivery can be specified in several ways:\n\n  - (for [A]) Associated with an individual subresource request and\n    specified in `Subresource.policies`,\n    e.g. referrerPolicy attributes of DOM elements.\n    This is handled in invokeRequest().\n\n  - (for [B]) Associated with an nested environmental settings object and\n    specified in `SourceContext.policies`,\n    e.g. HTTP referrer-policy response headers of HTML/worker scripts.\n    This is handled in server-side under /common/security-features/scope/.\n\n  - (for [B]) Associated with the top-level HTML document.\n    This is handled by the generators.d\n*/\n\n/**\n  @typedef Subresource\n  @type {object}\n  A Subresource represents how a subresource request is sent.\n\n  @property{SubresourceType} subresourceType\n    How the subresource request is sent,\n    e.g. \"img-tag\" for sending a request via <img src>.\n    See the keys of `subresourceMap` for valid values.\n\n  @property{string} url\n    subresource's URL.\n    Typically this is constructed by getRequestURLs() below.\n\n  @property{PolicyDelivery} policyDeliveries\n    Policies delivered specific to the subresource request.\n*/\n\n/**\n  @typedef SourceContext\n  @type {object}\n\n  @property {string} sourceContextType\n    Kind of the source context to be used.\n    Valid values are the keys of `sourceContextMap` below.\n\n  @property {Array<PolicyDelivery>} policyDeliveries\n    A list of PolicyDelivery applied to the source context.\n*/\n\n// ===============================================================\n// General utility functions\n// ===============================================================\n\nfunction timeoutPromise(t, ms) {\n  return new Promise(resolve => { t.step_timeout(resolve, ms); });\n}\n\n/**\n * Normalizes the target port for use in a URL. For default ports, this is the\n *     empty string (omitted port), otherwise it's a colon followed by the port\n *     number. Ports 80, 443 and an empty string are regarded as default ports.\n * @param {number} targetPort The port to use\n * @return {string} The port portion for using as part of a URL.\n */\nfunction getNormalizedPort(targetPort) {\n  return ([80, 443, \"\"].indexOf(targetPort) >= 0) ? \"\" : \":\" + targetPort;\n}\n\n/**\n * Creates a GUID.\n *     See: https://en.wikipedia.org/wiki/Globally_unique_identifier\n *     Original author: broofa (http://www.broofa.com/)\n *     Sourced from: http://stackoverflow.com/a/2117523/4949715\n * @return {string} A pseudo-random GUID.\n */\nfunction guid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * Initiates a new XHR via GET.\n * @param {string} url The endpoint URL for the XHR.\n * @param {string} responseType Optional - how should the response be parsed.\n *     Default is \"json\".\n *     See: https://xhr.spec.whatwg.org/#dom-xmlhttprequest-responsetype\n * @return {Promise} A promise wrapping the success and error events.\n */\nfunction xhrRequest(url, responseType) {\n  return new Promise(function(resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = responseType || \"json\";\n\n    xhr.addEventListener(\"error\", function() {\n      reject(Error(\"Network Error\"));\n    });\n\n    xhr.addEventListener(\"load\", function() {\n      if (xhr.status != 200)\n        reject(Error(xhr.statusText));\n      else\n        resolve(xhr.response);\n    });\n\n    xhr.send();\n  });\n}\n\n/**\n * Sets attributes on a given DOM element.\n * @param {DOMElement} element The element on which to set the attributes.\n * @param {object} An object with keys (serving as attribute names) and values.\n */\nfunction setAttributes(el, attrs) {\n  attrs = attrs || {}\n  for (var attr in attrs) {\n    if (attr !== 'src')\n      el.setAttribute(attr, attrs[attr]);\n  }\n  // Workaround for Chromium: set <img>'s src attribute after all other\n  // attributes to ensure the policy is applied.\n  for (var attr in attrs) {\n    if (attr === 'src')\n      el.setAttribute(attr, attrs[attr]);\n  }\n}\n\n/**\n * Binds to success and error events of an object wrapping them into a promise\n *     available through {@code element.eventPromise}. The success event\n *     resolves and error event rejects.\n * This method adds event listeners, and then removes all the added listeners\n * when one of listened event is fired.\n * @param {object} element An object supporting events on which to bind the\n *     promise.\n * @param {string} resolveEventName [=\"load\"] The event name to bind resolve to.\n * @param {string} rejectEventName [=\"error\"] The event name to bind reject to.\n */\nfunction bindEvents(element, resolveEventName, rejectEventName) {\n  element.eventPromise =\n      bindEvents2(element, resolveEventName, element, rejectEventName);\n}\n\n// Returns a promise wrapping success and error events of objects.\n// This is a variant of bindEvents that can accept separate objects for each\n// events and two events to reject, and doesn't set `eventPromise`.\n//\n// When `resolveObject`'s `resolveEventName` event (default: \"load\") is\n// fired, the promise is resolved with the event.\n//\n// When `rejectObject`'s `rejectEventName` event (default: \"error\") or\n// `rejectObject2`'s `rejectEventName2` event (default: \"error\") is\n// fired, the promise is rejected.\n//\n// `rejectObject2` is optional.\nfunction bindEvents2(resolveObject, resolveEventName, rejectObject, rejectEventName, rejectObject2, rejectEventName2) {\n  return new Promise(function(resolve, reject) {\n    const actualResolveEventName = resolveEventName || \"load\";\n    const actualRejectEventName = rejectEventName || \"error\";\n    const actualRejectEventName2 = rejectEventName2 || \"error\";\n\n    const resolveHandler = function(event) {\n      cleanup();\n      resolve(event);\n    };\n\n    const rejectHandler = function(event) {\n      // Chromium starts propagating errors from worker.onerror to\n      // window.onerror. This handles the uncaught exceptions in tests.\n      event.preventDefault();\n      cleanup();\n      reject(event);\n    };\n\n    const cleanup = function() {\n      resolveObject.removeEventListener(actualResolveEventName, resolveHandler);\n      rejectObject.removeEventListener(actualRejectEventName, rejectHandler);\n      if (rejectObject2) {\n        rejectObject2.removeEventListener(actualRejectEventName2, rejectHandler);\n      }\n    };\n\n    resolveObject.addEventListener(actualResolveEventName, resolveHandler);\n    rejectObject.addEventListener(actualRejectEventName, rejectHandler);\n    if (rejectObject2) {\n      rejectObject2.addEventListener(actualRejectEventName2, rejectHandler);\n    }\n  });\n}\n\n/**\n * Creates a new DOM element.\n * @param {string} tagName The type of the DOM element.\n * @param {object} attrs A JSON with attributes to apply to the element.\n * @param {DOMElement} parent Optional - an existing DOM element to append to\n *     If not provided, the returned element will remain orphaned.\n * @param {boolean} doBindEvents Optional - Whether to bind to load and error\n *     events and provide the promise wrapping the events via the element's\n *     {@code eventPromise} property. Default value evaluates to false.\n * @return {DOMElement} The newly created DOM element.\n */\nfunction createElement(tagName, attrs, parentNode, doBindEvents) {\n  var element = document.createElement(tagName);\n\n  if (doBindEvents) {\n    bindEvents(element);\n    if (element.tagName == \"IFRAME\" && !('srcdoc' in attrs || 'src' in attrs)) {\n      // If we're loading a frame, ensure we spin the event loop after load to\n      // paper over the different event timing in Gecko vs Blink/WebKit\n      // see https://github.com/whatwg/html/issues/4965\n      element.eventPromise = element.eventPromise.then(() => {\n        return new Promise(resolve => setTimeout(resolve, 0))\n      });\n    }\n  }\n  // We set the attributes after binding to events to catch any\n  // event-triggering attribute changes. E.g. form submission.\n  //\n  // But be careful with images: unlike other elements they will start the load\n  // as soon as the attr is set, even if not in the document yet, and sometimes\n  // complete it synchronously, so the append doesn't have the effect we want.\n  // So for images, we want to set the attrs after appending, whereas for other\n  // elements we want to do it before appending.\n  var isImg = (tagName == \"img\");\n  if (!isImg)\n    setAttributes(element, attrs);\n\n  if (parentNode)\n    parentNode.appendChild(element);\n\n  if (isImg)\n    setAttributes(element, attrs);\n\n  return element;\n}\n\nfunction createRequestViaElement(tagName, attrs, parentNode) {\n  return createElement(tagName, attrs, parentNode, true).eventPromise;\n}\n\nfunction wrapResult(server_data) {\n  if (typeof(server_data) === \"string\") {\n    throw server_data;\n  }\n  return {\n    referrer: server_data.headers.referer,\n    headers: server_data.headers\n  }\n}\n\n// ===============================================================\n// Subresources\n// ===============================================================\n\n/**\n  @typedef RequestResult\n  @type {object}\n  Represents the result of sending an request.\n  All properties are optional. See the comments for\n  requestVia*() and invokeRequest() below to see which properties are set.\n\n  @property {Array<Object<string, string>>} headers\n    HTTP request headers sent to server.\n  @property {string} referrer - Referrer.\n  @property {string} location - The URL of the subresource.\n  @property {string} sourceContextUrl\n    the URL of the global object where the actual request is sent.\n*/\n\n/**\n  requestVia*(url, additionalAttributes) functions send a subresource\n  request from the current environment settings object.\n\n  @param {string} url\n    The URL of the subresource.\n  @param {Object<string, string>} additionalAttributes\n    Additional attributes set to DOM elements\n    (element-initiated requests only).\n\n  @returns {Promise} that are resolved with a RequestResult object\n  on successful requests.\n\n  - Category 1:\n      `headers`: set.\n      `referrer`: set via `document.referrer`.\n      `location`: set via `document.location`.\n      See `template/document.html.template`.\n  - Category 2:\n      `headers`: set.\n      `referrer`: set to `headers.referer` by `wrapResult()`.\n      `location`: not set.\n  - Category 3:\n      All the keys listed above are NOT set.\n  `sourceContextUrl` is not set here.\n\n  -------------------------------- -------- --------------------------\n  Function name                    Category Used in\n                                            -------- ------- ---------\n                                            referrer mixed-  upgrade-\n                                            policy   content insecure-\n                                            policy   content request\n  -------------------------------- -------- -------- ------- ---------\n  requestViaAnchor                 1        Y        Y       -\n  requestViaArea                   1        Y        Y       -\n  requestViaAudio                  3        -        Y       -\n  requestViaDedicatedWorker        2        Y        Y       Y\n  requestViaFetch                  2        Y        Y       -\n  requestViaForm                   2        -        Y       -\n  requestViaIframe                 1        Y        Y       -\n  requestViaImage                  2        Y        Y       -\n  requestViaLinkPrefetch           3        -        Y       -\n  requestViaLinkStylesheet         3        -        Y       -\n  requestViaObject                 3        -        Y       -\n  requestViaPicture                3        -        Y       -\n  requestViaScript                 2        Y        Y       -\n  requestViaSendBeacon             3        -        Y       -\n  requestViaSharedWorker           2        Y        Y       Y\n  requestViaVideo                  3        -        Y       -\n  requestViaWebSocket              3        -        Y       -\n  requestViaWorklet                3        -        Y       Y\n  requestViaXhr                    2        Y        Y       -\n  -------------------------------- -------- -------- ------- ---------\n*/\n\n/**\n * Creates a new iframe, binds load and error events, sets the src attribute and\n *     appends it to {@code document.body} .\n * @param {string} url The src for the iframe.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaIframe(url, additionalAttributes) {\n  const iframe = createElement(\n      \"iframe\",\n      Object.assign({\"src\": url}, additionalAttributes),\n      document.body,\n      false);\n  return bindEvents2(window, \"message\", iframe, \"error\", window, \"error\")\n      .then(event => {\n          if (event.source !== iframe.contentWindow)\n            return Promise.reject(new Error('Unexpected event.source'));\n          return event.data;\n        });\n}\n\n/**\n * Creates a new image, binds load and error events, sets the src attribute and\n *     appends it to {@code document.body} .\n * @param {string} url The src for the image.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaImage(url, additionalAttributes) {\n  const img = createElement(\n      \"img\",\n      // crossOrigin attribute is added to read the pixel data of the response.\n      Object.assign({\"src\": url, \"crossOrigin\": \"Anonymous\"}, additionalAttributes),\n      document.body, true);\n  return img.eventPromise.then(() => wrapResult(decodeImageData(img)));\n}\n\n// Helper for requestViaImage().\nfunction decodeImageData(img) {\n  var canvas = document.createElement(\"canvas\");\n  var context = canvas.getContext('2d');\n  context.drawImage(img, 0, 0);\n  var imgData = context.getImageData(0, 0, img.clientWidth, img.clientHeight);\n  const rgba = imgData.data;\n\n  let decodedBytes = new Uint8ClampedArray(rgba.length);\n  let decodedLength = 0;\n\n  for (var i = 0; i + 12 <= rgba.length; i += 12) {\n    // A single byte is encoded in three pixels. 8 pixel octets (among\n    // 9 octets = 3 pixels * 3 channels) are used to encode 8 bits,\n    // the most significant bit first, where `0` and `255` in pixel values\n    // represent `0` and `1` in bits, respectively.\n    // This encoding is used to avoid errors due to different color spaces.\n    const bits = [];\n    for (let j = 0; j < 3; ++j) {\n      bits.push(rgba[i + j * 4 + 0]);\n      bits.push(rgba[i + j * 4 + 1]);\n      bits.push(rgba[i + j * 4 + 2]);\n      // rgba[i + j * 4 + 3]: Skip alpha channel.\n    }\n    // The last one element is not used.\n    bits.pop();\n\n    // Decode a single byte.\n    let byte = 0;\n    for (let j = 0; j < 8; ++j) {\n      byte <<= 1;\n      if (bits[j] >= 128)\n        byte |= 1;\n    }\n\n    // Zero is the string terminator.\n    if (byte == 0)\n      break;\n\n    decodedBytes[decodedLength++] = byte;\n  }\n\n  // Remove trailing nulls from data.\n  decodedBytes = decodedBytes.subarray(0, decodedLength);\n  var string_data = (new TextDecoder(\"ascii\")).decode(decodedBytes);\n\n  return JSON.parse(string_data);\n}\n\n/**\n * Initiates a new XHR GET request to provided URL.\n * @param {string} url The endpoint URL for the XHR.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaXhr(url) {\n  return xhrRequest(url).then(result => wrapResult(result));\n}\n\n/**\n * Initiates a new GET request to provided URL via the Fetch API.\n * @param {string} url The endpoint URL for the Fetch.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaFetch(url) {\n  return fetch(url)\n    .then(res => res.json())\n    .then(j => wrapResult(j));\n}\n\nfunction dedicatedWorkerUrlThatFetches(url) {\n  return `data:text/javascript,\n    fetch('${url}')\n      .then(r => r.json())\n      .then(j => postMessage(j))\n      .catch((e) => postMessage(e.message));`;\n}\n\nfunction workerUrlThatImports(url, additionalAttributes) {\n  let csp = \"\";\n  if (additionalAttributes && additionalAttributes.contentSecurityPolicy) {\n    csp=`&contentSecurityPolicy=${additionalAttributes.contentSecurityPolicy}`;\n  }\n  return `/common/security-features/subresource/static-import.py` +\n      `?import_url=${encodeURIComponent(url)}${csp}`;\n}\n\nfunction workerDataUrlThatImports(url) {\n  return `data:text/javascript,import '${url}';`;\n}\n\n/**\n * Creates a new Worker, binds message and error events wrapping them into.\n *     {@code worker.eventPromise} and posts an empty string message to start\n *     the worker.\n * @param {string} url The endpoint URL for the worker script.\n * @param {object} options The options for Worker constructor.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaDedicatedWorker(url, options) {\n  var worker;\n  try {\n    worker = new Worker(url, options);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n  worker.postMessage('');\n  return bindEvents2(worker, \"message\", worker, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\nfunction requestViaSharedWorker(url, options) {\n  var worker;\n  try {\n    worker = new SharedWorker(url, options);\n  } catch(e) {\n    return Promise.reject(e);\n  }\n  const promise = bindEvents2(worker.port, \"message\", worker, \"error\")\n    .then(event => wrapResult(event.data));\n  worker.port.start();\n  return promise;\n}\n\n// Returns a reference to a worklet object corresponding to a given type.\nfunction get_worklet(type) {\n  if (type == 'animation')\n    return CSS.animationWorklet;\n  if (type == 'layout')\n    return CSS.layoutWorklet;\n  if (type == 'paint')\n    return CSS.paintWorklet;\n  if (type == 'audio')\n    return new OfflineAudioContext(2,44100*40,44100).audioWorklet;\n\n  throw new Error('unknown worklet type is passed.');\n}\n\nfunction requestViaWorklet(type, url) {\n  try {\n    return get_worklet(type).addModule(url);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Creates a navigable element with the name `navigableElementName`\n * (<a>, <area>, or <form>) under `parentNode`, and\n * performs a navigation by `trigger()` (e.g. clicking <a>).\n * To avoid navigating away from the current execution context,\n * a target attribute is set to point to a new helper iframe.\n * @param {string} navigableElementName\n * @param {object} additionalAttributes The attributes of the navigable element.\n * @param {DOMElement} parentNode\n * @param {function(DOMElement} trigger A callback called after the navigable\n * element is inserted and should trigger navigation using the element.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaNavigable(navigableElementName, additionalAttributes,\n                             parentNode, trigger) {\n  const name = guid();\n\n  const iframe =\n    createElement(\"iframe\", {\"name\": name, \"id\": name}, parentNode, false);\n\n  const navigable = createElement(\n      navigableElementName,\n      Object.assign({\"target\": name}, additionalAttributes),\n      parentNode, false);\n\n  const promise =\n    bindEvents2(window, \"message\", iframe, \"error\", window, \"error\")\n      .then(event => {\n          if (event.source !== iframe.contentWindow)\n            return Promise.reject(new Error('Unexpected event.source'));\n          return event.data;\n        });\n  trigger(navigable);\n  return promise;\n}\n\n/**\n * Creates a new anchor element, appends it to {@code document.body} and\n *     performs the navigation.\n * @param {string} url The URL to navigate to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaAnchor(url, additionalAttributes) {\n  return requestViaNavigable(\n      \"a\",\n      Object.assign({\"href\": url, \"innerHTML\": \"Link to resource\"},\n                    additionalAttributes),\n      document.body, a => a.click());\n}\n\n/**\n * Creates a new area element, appends it to {@code document.body} and performs\n *     the navigation.\n * @param {string} url The URL to navigate to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaArea(url, additionalAttributes) {\n  // TODO(kristijanburnik): Append to map and add image.\n  return requestViaNavigable(\n      \"area\",\n      Object.assign({\"href\": url}, additionalAttributes),\n      document.body, area => area.click());\n}\n\n/**\n * Creates a new script element, sets the src to url, and appends it to\n *     {@code document.body}.\n * @param {string} url The src URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaScript(url, additionalAttributes) {\n  const script = createElement(\n      \"script\",\n      Object.assign({\"src\": url}, additionalAttributes),\n      document.body,\n      false);\n\n  return bindEvents2(window, \"message\", script, \"error\", window, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\n/**\n * Creates a new script element that performs a dynamic import to `url`, and\n * appends the script element to {@code document.body}.\n * @param {string} url The src URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaDynamicImport(url, additionalAttributes) {\n  const scriptUrl = `data:text/javascript,import(\"${url}\");`;\n  const script = createElement(\n      \"script\",\n      Object.assign({\"src\": scriptUrl}, additionalAttributes),\n      document.body,\n      false);\n\n  return bindEvents2(window, \"message\", script, \"error\", window, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\n/**\n * Creates a new form element, sets attributes, appends it to\n *     {@code document.body} and submits the form.\n * @param {string} url The URL to submit to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaForm(url, additionalAttributes) {\n  return requestViaNavigable(\n      \"form\",\n      Object.assign({\"action\": url, \"method\": \"POST\"}, additionalAttributes),\n      document.body, form => form.submit());\n}\n\n/**\n * Creates a new link element for a stylesheet, binds load and error events,\n *     sets the href to url and appends it to {@code document.head}.\n * @param {string} url The URL for a stylesheet.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaLinkStylesheet(url) {\n  return createRequestViaElement(\"link\",\n                                 {\"rel\": \"stylesheet\", \"href\": url},\n                                 document.head);\n}\n\n/**\n * Creates a new link element for a prefetch, binds load and error events, sets\n *     the href to url and appends it to {@code document.head}.\n * @param {string} url The URL of a resource to prefetch.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaLinkPrefetch(url) {\n  var link = document.createElement('link');\n  if (link.relList && link.relList.supports && link.relList.supports(\"prefetch\")) {\n    return createRequestViaElement(\"link\",\n                                   {\"rel\": \"prefetch\", \"href\": url},\n                                   document.head);\n  } else {\n    return Promise.reject(\"This browser does not support 'prefetch'.\");\n  }\n}\n\n/**\n * Initiates a new beacon request.\n * @param {string} url The URL of a resource to prefetch.\n * @return {Promise} The promise for success/error events.\n */\nasync function requestViaSendBeacon(url) {\n  function wait(ms) {\n    return new Promise(resolve => step_timeout(resolve, ms));\n  }\n  if (!navigator.sendBeacon(url)) {\n    // If mixed-content check fails, it should return false.\n    throw new Error('sendBeacon() fails.');\n  }\n  // We don't have a means to see the result of sendBeacon() request\n  // for sure. Let's wait for a while and let the generic test function\n  // ask the server for the result.\n  await wait(500);\n  return 'allowed';\n}\n\n/**\n * Creates a new media element with a child source element, binds loadeddata and\n *     error events, sets attributes and appends to document.body.\n * @param {string} type The type of the media element (audio/video/picture).\n * @param {object} media_attrs The attributes for the media element.\n * @param {object} source_attrs The attributes for the child source element.\n * @return {DOMElement} The newly created media element.\n */\nfunction createMediaElement(type, media_attrs, source_attrs) {\n  var mediaElement = createElement(type, {});\n\n  var sourceElement = createElement(\"source\", {});\n\n  mediaElement.eventPromise = new Promise(function(resolve, reject) {\n    mediaElement.addEventListener(\"loadeddata\", function (e) {\n      resolve(e);\n    });\n\n    // Safari doesn't fire an `error` event when blocking mixed content.\n    mediaElement.addEventListener(\"stalled\", function(e) {\n      reject(e);\n    });\n\n    sourceElement.addEventListener(\"error\", function(e) {\n      reject(e);\n    });\n  });\n\n  setAttributes(mediaElement, media_attrs);\n  setAttributes(sourceElement, source_attrs);\n\n  mediaElement.appendChild(sourceElement);\n  document.body.appendChild(mediaElement);\n\n  return mediaElement;\n}\n\n/**\n * Creates a new video element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}.\n * @param {string} url The URL of the video.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaVideo(url) {\n  return createMediaElement(\"video\",\n                            {},\n                            {\"src\": url}).eventPromise;\n}\n\n/**\n * Creates a new audio element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}.\n * @param {string} url The URL of the audio.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaAudio(url) {\n  return createMediaElement(\"audio\",\n                            {},\n                            {\"type\": \"audio/wav\", \"src\": url}).eventPromise;\n}\n\n/**\n * Creates a new picture element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}. Also\n *     creates new image element appending it to the picture\n * @param {string} url The URL of the image for the source and image elements.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaPicture(url) {\n  var picture = createMediaElement(\"picture\", {}, {\"srcset\": url,\n                                                \"type\": \"image/png\"});\n  return createRequestViaElement(\"img\", {\"src\": url}, picture);\n}\n\n/**\n * Creates a new object element, binds load and error events, sets the data to\n *     url, and appends it to {@code document.body}.\n * @param {string} url The data URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaObject(url) {\n  return createRequestViaElement(\"object\", {\"data\": url, \"type\": \"text/html\"}, document.body);\n}\n\n/**\n * Creates a new WebSocket pointing to {@code url} and sends a message string\n * \"echo\". The {@code message} and {@code error} events are triggering the\n * returned promise resolve/reject events.\n * @param {string} url The URL for WebSocket to connect to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaWebSocket(url) {\n  return new Promise(function(resolve, reject) {\n    var websocket = new WebSocket(url);\n\n    websocket.addEventListener(\"message\", function(e) {\n      resolve(e.data);\n    });\n\n    websocket.addEventListener(\"open\", function(e) {\n      websocket.send(\"echo\");\n    });\n\n    websocket.addEventListener(\"error\", function(e) {\n      reject(e)\n    });\n  })\n  .then(data => {\n      return JSON.parse(data);\n    });\n}\n\n/**\n  @typedef SubresourceType\n  @type {string}\n\n  Represents how a subresource is sent.\n  The keys of `subresourceMap` below are the valid values.\n*/\n\n// Subresource paths and invokers.\nconst subresourceMap = {\n  \"a-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaAnchor,\n  },\n  \"area-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaArea,\n  },\n  \"audio-tag\": {\n    path: \"/common/security-features/subresource/audio.py\",\n    invoker: requestViaAudio,\n  },\n  \"beacon\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaSendBeacon,\n  },\n  \"fetch\": {\n    path: \"/common/security-features/subresource/xhr.py\",\n    invoker: requestViaFetch,\n  },\n  \"form-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaForm,\n  },\n  \"iframe-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaIframe,\n  },\n  \"img-tag\": {\n    path: \"/common/security-features/subresource/image.py\",\n    invoker: requestViaImage,\n  },\n  \"link-css-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaLinkStylesheet,\n  },\n  \"link-prefetch-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaLinkPrefetch,\n  },\n  \"object-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaObject,\n  },\n  \"picture-tag\": {\n    path: \"/common/security-features/subresource/image.py\",\n    invoker: requestViaPicture,\n  },\n  \"script-tag\": {\n    path: \"/common/security-features/subresource/script.py\",\n    invoker: requestViaScript,\n  },\n  \"script-tag-dynamic-import\": {\n    path: \"/common/security-features/subresource/script.py\",\n    invoker: requestViaDynamicImport,\n  },\n  \"video-tag\": {\n    path: \"/common/security-features/subresource/video.py\",\n    invoker: requestViaVideo,\n  },\n  \"xhr\": {\n    path: \"/common/security-features/subresource/xhr.py\",\n    invoker: requestViaXhr,\n  },\n\n  \"worker-classic\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url => requestViaDedicatedWorker(url),\n  },\n  \"worker-module\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url => requestViaDedicatedWorker(url, {type: \"module\"}),\n  },\n  \"worker-import\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: (url, additionalAttributes) =>\n        requestViaDedicatedWorker(workerUrlThatImports(url, additionalAttributes), {type: \"module\"}),\n  },\n  \"worker-import-data\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url =>\n        requestViaDedicatedWorker(workerDataUrlThatImports(url), {type: \"module\"}),\n  },\n  \"sharedworker-classic\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url => requestViaSharedWorker(url),\n  },\n  \"sharedworker-module\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url => requestViaSharedWorker(url, {type: \"module\"}),\n  },\n  \"sharedworker-import\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: (url, additionalAttributes) =>\n        requestViaSharedWorker(workerUrlThatImports(url, additionalAttributes), {type: \"module\"}),\n  },\n  \"sharedworker-import-data\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url =>\n        requestViaSharedWorker(workerDataUrlThatImports(url), {type: \"module\"}),\n  },\n\n  \"websocket\": {\n    path: \"/stash_responder\",\n    invoker: requestViaWebSocket,\n  },\n};\nfor (const workletType of ['animation', 'audio', 'layout', 'paint']) {\n  subresourceMap[`worklet-${workletType}`] = {\n      path: \"/common/security-features/subresource/worker.py\",\n      invoker: url => requestViaWorklet(workletType, url)\n    };\n  subresourceMap[`worklet-${workletType}-import-data`] = {\n      path: \"/common/security-features/subresource/worker.py\",\n      invoker: url =>\n          requestViaWorklet(workletType, workerDataUrlThatImports(url))\n    };\n}\n\n/**\n  @typedef RedirectionType\n  @type {string}\n\n  Represents what redirects should occur to the subresource request\n  after initial request.\n  See preprocess_redirection() in\n  /common/security-features/subresource/subresource.py for valid values.\n*/\n\n/**\n  Construct subresource (and related) origin.\n\n  @param {string} originType\n  @returns {object} the origin of the subresource.\n*/\nfunction getSubresourceOrigin(originType) {\n  const httpProtocol = \"http\";\n  const httpsProtocol = \"https\";\n  const wsProtocol = \"ws\";\n  const wssProtocol = \"wss\";\n\n  const sameOriginHost = \"web-platform.test\";\n  const crossOriginHost = \"www1.web-platform.test\";\n\n  // These values can evaluate to either empty strings or a \":port\" string.\n  const httpPort = getNormalizedPort(parseInt(\"8000\", 10));\n  const httpsRawPort = parseInt(\"8443\", 10);\n  const httpsPort = getNormalizedPort(httpsRawPort);\n  const wsPort = getNormalizedPort(parseInt(\"8888\", 10));\n  const wssRawPort = parseInt(\"8889\", 10);\n  const wssPort = getNormalizedPort(wssRawPort);\n\n  /**\n    @typedef OriginType\n    @type {string}\n\n    Represents the origin of the subresource request URL.\n    The keys of `originMap` below are the valid values.\n\n    Note that there can be redirects from the specified origin\n    (see RedirectionType), and thus the origin of the subresource\n    response URL might be different from what is specified by OriginType.\n  */\n  const originMap = {\n    \"same-https\": httpsProtocol + \"://\" + sameOriginHost + httpsPort,\n    \"same-http\": httpProtocol + \"://\" + sameOriginHost + httpPort,\n    \"cross-https\": httpsProtocol + \"://\" + crossOriginHost + httpsPort,\n    \"cross-http\": httpProtocol + \"://\" + crossOriginHost + httpPort,\n    \"same-wss\": wssProtocol + \"://\" + sameOriginHost + wssPort,\n    \"same-ws\": wsProtocol + \"://\" + sameOriginHost + wsPort,\n    \"cross-wss\": wssProtocol + \"://\" + crossOriginHost + wssPort,\n    \"cross-ws\": wsProtocol + \"://\" + crossOriginHost + wsPort,\n\n    // The following origin types are used for upgrade-insecure-requests tests:\n    // These rely on some unintuitive cleverness due to WPT's test setup:\n    // 'Upgrade-Insecure-Requests' does not upgrade the port number,\n    // so we use URLs in the form `http://[domain]:[https-port]`,\n    // which will be upgraded to `https://[domain]:[https-port]`.\n    // If the upgrade fails, the load will fail, as we don't serve HTTP over\n    // the secure port.\n    \"same-http-downgrade\":\n        httpProtocol + \"://\" + sameOriginHost + \":\" + httpsRawPort,\n    \"cross-http-downgrade\":\n        httpProtocol + \"://\" + crossOriginHost + \":\" + httpsRawPort,\n    \"same-ws-downgrade\":\n        wsProtocol + \"://\" + sameOriginHost + \":\" + wssRawPort,\n    \"cross-ws-downgrade\":\n        wsProtocol + \"://\" + crossOriginHost + \":\" + wssRawPort,\n  };\n\n  return originMap[originType];\n}\n\n/**\n  Construct subresource (and related) URLs.\n\n  @param {SubresourceType} subresourceType\n  @param {OriginType} originType\n  @param {RedirectionType} redirectionType\n  @returns {object} with following properties:\n    {string} testUrl\n      The subresource request URL.\n    {string} announceUrl\n    {string} assertUrl\n      The URLs to be used for detecting whether `testUrl` is actually sent\n      to the server.\n      1. Fetch `announceUrl` first,\n      2. then possibly fetch `testUrl`, and\n      3. finally fetch `assertUrl`.\n         The fetch result of `assertUrl` should indicate whether\n         `testUrl` is actually sent to the server or not.\n*/\nfunction getRequestURLs(subresourceType, originType, redirectionType) {\n  const key = guid();\n  const value = guid();\n\n  // We use the same stash path for both HTTP/S and WS/S stash requests.\n  const stashPath = encodeURIComponent(\"/mixed-content\");\n\n  const stashEndpoint = \"/common/security-features/subresource/xhr.py?key=\" +\n                        key + \"&path=\" + stashPath;\n  return {\n    testUrl:\n      getSubresourceOrigin(originType) +\n        subresourceMap[subresourceType].path +\n        \"?redirection=\" + encodeURIComponent(redirectionType) +\n        \"&action=purge&key=\" + key +\n        \"&path=\" + stashPath,\n    announceUrl: stashEndpoint + \"&action=put&value=\" + value,\n    assertUrl: stashEndpoint + \"&action=take\",\n  };\n}\n\n// ===============================================================\n// Source Context\n// ===============================================================\n// Requests can be sent from several source contexts,\n// such as the main documents, iframes, workers, or so,\n// possibly nested, and possibly with <meta>/http headers added.\n// invokeRequest() and invokeFrom*() functions handles\n// SourceContext-related setup in client-side.\n\n/**\n  invokeRequest() invokes a subresource request\n  (specified as `subresource`)\n  from a (possibly nested) environment settings object\n  (specified as `sourceContextList`).\n\n  For nested contexts, invokeRequest() calls an invokeFrom*() function\n  that creates a nested environment settings object using\n  /common/security-features/scope/, which calls invokeRequest()\n  again inside the nested environment settings object.\n  This cycle continues until all specified\n  nested environment settings object are created, and\n  finally invokeRequest() calls a requestVia*() function to start the\n  subresource request from the inner-most environment settings object.\n\n  @param {Subresource} subresource\n  @param {Array<SourceContext>} sourceContextList\n\n  @returns {Promise} A promise that is resolved with an RequestResult object.\n  `sourceContextUrl` is always set. For whether other properties are set,\n  see the comments for requestVia*() above.\n*/\nfunction invokeRequest(subresource, sourceContextList) {\n  if (sourceContextList.length === 0) {\n    // No further nested global objects. Send the subresource request here.\n\n    const additionalAttributes = {};\n    /** @type {PolicyDelivery} policyDelivery */\n    for (const policyDelivery of (subresource.policyDeliveries || [])) {\n      // Depending on the delivery method, extend the subresource element with\n      // these attributes.\n      if (policyDelivery.deliveryType === \"attr\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      } else if (policyDelivery.deliveryType === \"rel-noref\") {\n        additionalAttributes[\"rel\"] = \"noreferrer\";\n      } else if (policyDelivery.deliveryType === \"http-rp\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      } else if (policyDelivery.deliveryType === \"meta\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      }\n    }\n\n    return subresourceMap[subresource.subresourceType].invoker(\n        subresource.url,\n        additionalAttributes)\n      .then(result => Object.assign(\n          {sourceContextUrl: location.toString()},\n          result));\n  }\n\n  // Defines invokers for each valid SourceContext.sourceContextType.\n  const sourceContextMap = {\n    \"srcdoc\": { // <iframe srcdoc></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"iframe\": { // <iframe src=\"same-origin-URL\"></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"iframe-blank\": { // <iframe></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"worker-classic\": {\n      // Classic dedicated worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", false, {}),\n    },\n    \"worker-classic-data\": {\n      // Classic dedicated worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", true, {}),\n    },\n    \"worker-module\": {\n      // Module dedicated worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", false, {type: 'module'}),\n    },\n    \"worker-module-data\": {\n      // Module dedicated worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", true, {type: 'module'}),\n    },\n    \"sharedworker-classic\": {\n      // Classic shared worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", false, {}),\n    },\n    \"sharedworker-classic-data\": {\n      // Classic shared worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", true, {}),\n    },\n    \"sharedworker-module\": {\n      // Module shared worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", false, {type: 'module'}),\n    },\n    \"sharedworker-module-data\": {\n      // Module shared worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", true, {type: 'module'}),\n    },\n  };\n\n  return sourceContextMap[sourceContextList[0].sourceContextType].invoker(\n      subresource, sourceContextList);\n}\n\n// Quick hack to expose invokeRequest when common.sub.js is loaded either\n// as a classic or module script.\nself.invokeRequest = invokeRequest;\n\n/**\n  invokeFrom*() functions are helper functions with the same parameters\n  and return values as invokeRequest(), that are tied to specific types\n  of top-most environment settings objects.\n  For example, invokeFromIframe() is the helper function for the cases where\n  sourceContextList[0] is an iframe.\n*/\n\n/**\n  @param {string} workerType\n    \"worker\" (for dedicated worker) or \"sharedworker\".\n  @param {boolean} isDataUrl\n    true if the worker script is loaded from data: URL.\n    Otherwise, the script is loaded from same-origin.\n  @param {object} workerOptions\n    The `options` argument for Worker constructor.\n\n  Other parameters and return values are the same as those of invokeRequest().\n*/\nfunction invokeFromWorker(workerType, isDataUrl, workerOptions,\n                          subresource, sourceContextList) {\n  const currentSourceContext = sourceContextList[0];\n  let workerUrl =\n    \"/common/security-features/scope/worker.py?policyDeliveries=\" +\n    encodeURIComponent(JSON.stringify(\n        currentSourceContext.policyDeliveries || []));\n  if (workerOptions.type === 'module') {\n    workerUrl += \"&type=module\";\n  }\n\n  let promise;\n  if (isDataUrl) {\n    promise = fetch(workerUrl)\n      .then(r => r.text())\n      .then(source => {\n          return 'data:text/javascript;base64,' + btoa(source);\n        });\n  } else {\n    promise = Promise.resolve(workerUrl);\n  }\n\n  return promise\n    .then(url => {\n      if (workerType === \"worker\") {\n        const worker = new Worker(url, workerOptions);\n        worker.postMessage({subresource: subresource,\n                            sourceContextList: sourceContextList.slice(1)});\n        return bindEvents2(worker, \"message\", worker, \"error\", window, \"error\");\n      } else if (workerType === \"sharedworker\") {\n        const worker = new SharedWorker(url, workerOptions);\n        worker.port.start();\n        worker.port.postMessage({subresource: subresource,\n                                 sourceContextList: sourceContextList.slice(1)});\n        return bindEvents2(worker.port, \"message\", worker, \"error\", window, \"error\");\n      } else {\n        throw new Error('Invalid worker type: ' + workerType);\n      }\n    })\n    .then(event => {\n        if (event.data.error)\n          return Promise.reject(event.data.error);\n        return event.data;\n      });\n}\n\nfunction invokeFromIframe(subresource, sourceContextList) {\n  const currentSourceContext = sourceContextList[0];\n  const frameUrl =\n    \"/common/security-features/scope/document.py?policyDeliveries=\" +\n    encodeURIComponent(JSON.stringify(\n        currentSourceContext.policyDeliveries || []));\n\n  let iframe;\n  let promise;\n  if (currentSourceContext.sourceContextType === 'srcdoc') {\n    promise = fetch(frameUrl)\n      .then(r => r.text())\n      .then(srcdoc => {\n          iframe = createElement(\n              \"iframe\", {srcdoc: srcdoc}, document.body, true);\n          return iframe.eventPromise;\n        });\n  } else if (currentSourceContext.sourceContextType === 'iframe') {\n    iframe = createElement(\"iframe\", {src: frameUrl}, document.body, true);\n    promise = iframe.eventPromise;\n  } else if (currentSourceContext.sourceContextType === 'iframe-blank') {\n    let frameContent;\n    promise = fetch(frameUrl)\n      .then(r => r.text())\n      .then(t => {\n          frameContent = t;\n          iframe = createElement(\"iframe\", {}, document.body, true);\n          return iframe.eventPromise;\n        })\n      .then(() => {\n          // Reinitialize `iframe.eventPromise` with a new promise\n          // that catches the load event for the document.write() below.\n          bindEvents(iframe);\n\n          iframe.contentDocument.write(frameContent);\n          iframe.contentDocument.close();\n          return iframe.eventPromise;\n        });\n  }\n\n  return promise\n    .then(() => {\n        const promise = bindEvents2(\n            window, \"message\", iframe, \"error\", window, \"error\");\n        iframe.contentWindow.postMessage(\n            {subresource: subresource,\n             sourceContextList: sourceContextList.slice(1)},\n            \"*\");\n        return promise;\n      })\n    .then(event => {\n        if (event.data.error)\n          return Promise.reject(event.data.error);\n        return event.data;\n      });\n}\n\n// SanityChecker does nothing in release mode. See sanity-checker.js for debug\n// mode.\nfunction SanityChecker() {}\nSanityChecker.prototype.checkScenario = function() {};\nSanityChecker.prototype.setFailTimeout = function(test, timeout) {};\nSanityChecker.prototype.checkSubresourceResult = function() {};\n"},{"url":"https://web-platform.test:8889/stash_responder?redirection=no-redirect&action=purge&key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content","request_start":1696742124.0402422,"response_start":1696742124.0839381,"request_end":1696742124.0410311,"response_end":1696742124.0846198,"ts":1696742124.084855,"body":""},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=b2923c98-5e82-4e85-804d-d49185012241&path=%2Fmixed-content&action=take","request_start":1696742124.1159527,"response_start":1696742124.1219954,"request_end":1696742124.1171193,"response_end":1696742124.122916,"ts":1696742124.1232822,"body":"{\"status\": \"allowed\", \"result\": null}"},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=put&value=c94e3994-6ca0-4f36-b67a-da4a8e3e6be6","request_start":1696742124.1680906,"response_start":1696742124.172645,"request_end":1696742124.1686738,"response_end":1696742124.1733792,"ts":1696742124.1736364,"body":"{\"status\": \"success\", \"result\": \"4bd1da16-e662-4962-b3a1-79f4b183f767\"}"},{"url":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","request_start":1696742124.1985848,"response_start":1696742124.2019079,"request_end":1696742124.1992779,"response_end":1696742124.202557,"ts":1696742124.2028244,"body":"import \"https://web-platform.test:8443/common/security-features/resources/common.sub.js\";\n\nif ('DedicatedWorkerGlobalScope' in self &&\n    self instanceof DedicatedWorkerGlobalScope) {\n  self.onmessage = event => onMessageFromParent(event, self);\n} else if ('SharedWorkerGlobalScope' in self &&\n    self instanceof SharedWorkerGlobalScope) {\n  onconnect = event => {\n    const port = event.ports[0];\n    port.onmessage = event => onMessageFromParent(event, port);\n  };\n}\n\n// Receive a message from the parent and start the test.\nfunction onMessageFromParent(event, port) {\n  const configurationError = \"\";\n  if (configurationError.length > 0) {\n    port.postMessage({error: configurationError});\n    return;\n  }\n\n  invokeRequest(event.data.subresource,\n                event.data.sourceContextList)\n    .then(result => port.postMessage(result))\n    .catch(e => {\n        const message = (e.error && e.error.stack) || e.message || \"Error\";\n        port.postMessage({error: message});\n      });\n}\n"},{"url":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","request_start":1696742124.213901,"response_start":1696742124.2174919,"request_end":1696742124.2145894,"response_end":1696742124.2182174,"ts":1696742124.218443,"body":"/**\n * @fileoverview Utilities for mixed-content in web-platform-tests.\n * @author burnik@google.com (Kristijan Burnik)\n * Disclaimer: Some methods of other authors are annotated in the corresponding\n *     method's JSDoc.\n */\n\n// ===============================================================\n// Types\n// ===============================================================\n// Objects of the following types are used to represent what kind of\n// subresource requests should be sent with what kind of policies,\n// from what kind of possibly nested source contexts.\n// The objects are represented as JSON objects (not JavaScript/Python classes\n// in a strict sense) to be passed between JavaScript/Python code.\n//\n// See also common/security-features/Types.md for high-level description.\n\n/**\n  @typedef PolicyDelivery\n  @type {object}\n  Referrer policy etc. can be applied/delivered in several ways.\n  A PolicyDelivery object specifies what policy is delivered and how.\n\n  @property {string} deliveryType\n    Specifies how the policy is delivered.\n    The valid deliveryType are:\n\n     \"attr\"\n        [A] DOM attributes e.g. referrerPolicy.\n\n      \"rel-noref\"\n        [A] <link rel=\"noreferrer\"> (referrer-policy only).\n\n      \"http-rp\"\n        [B] HTTP response headers.\n\n      \"meta\"\n        [B] <meta> elements.\n\n  @property {string} key\n  @property {string} value\n    Specifies what policy to be delivered. The valid keys are:\n\n      \"referrerPolicy\"\n        Referrer Policy\n        https://w3c.github.io/webappsec-referrer-policy/\n        Valid values are those listed in\n        https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n        (except that \"\" is represented as null/None)\n\n  A PolicyDelivery can be specified in several ways:\n\n  - (for [A]) Associated with an individual subresource request and\n    specified in `Subresource.policies`,\n    e.g. referrerPolicy attributes of DOM elements.\n    This is handled in invokeRequest().\n\n  - (for [B]) Associated with an nested environmental settings object and\n    specified in `SourceContext.policies`,\n    e.g. HTTP referrer-policy response headers of HTML/worker scripts.\n    This is handled in server-side under /common/security-features/scope/.\n\n  - (for [B]) Associated with the top-level HTML document.\n    This is handled by the generators.d\n*/\n\n/**\n  @typedef Subresource\n  @type {object}\n  A Subresource represents how a subresource request is sent.\n\n  @property{SubresourceType} subresourceType\n    How the subresource request is sent,\n    e.g. \"img-tag\" for sending a request via <img src>.\n    See the keys of `subresourceMap` for valid values.\n\n  @property{string} url\n    subresource's URL.\n    Typically this is constructed by getRequestURLs() below.\n\n  @property{PolicyDelivery} policyDeliveries\n    Policies delivered specific to the subresource request.\n*/\n\n/**\n  @typedef SourceContext\n  @type {object}\n\n  @property {string} sourceContextType\n    Kind of the source context to be used.\n    Valid values are the keys of `sourceContextMap` below.\n\n  @property {Array<PolicyDelivery>} policyDeliveries\n    A list of PolicyDelivery applied to the source context.\n*/\n\n// ===============================================================\n// General utility functions\n// ===============================================================\n\nfunction timeoutPromise(t, ms) {\n  return new Promise(resolve => { t.step_timeout(resolve, ms); });\n}\n\n/**\n * Normalizes the target port for use in a URL. For default ports, this is the\n *     empty string (omitted port), otherwise it's a colon followed by the port\n *     number. Ports 80, 443 and an empty string are regarded as default ports.\n * @param {number} targetPort The port to use\n * @return {string} The port portion for using as part of a URL.\n */\nfunction getNormalizedPort(targetPort) {\n  return ([80, 443, \"\"].indexOf(targetPort) >= 0) ? \"\" : \":\" + targetPort;\n}\n\n/**\n * Creates a GUID.\n *     See: https://en.wikipedia.org/wiki/Globally_unique_identifier\n *     Original author: broofa (http://www.broofa.com/)\n *     Sourced from: http://stackoverflow.com/a/2117523/4949715\n * @return {string} A pseudo-random GUID.\n */\nfunction guid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * Initiates a new XHR via GET.\n * @param {string} url The endpoint URL for the XHR.\n * @param {string} responseType Optional - how should the response be parsed.\n *     Default is \"json\".\n *     See: https://xhr.spec.whatwg.org/#dom-xmlhttprequest-responsetype\n * @return {Promise} A promise wrapping the success and error events.\n */\nfunction xhrRequest(url, responseType) {\n  return new Promise(function(resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = responseType || \"json\";\n\n    xhr.addEventListener(\"error\", function() {\n      reject(Error(\"Network Error\"));\n    });\n\n    xhr.addEventListener(\"load\", function() {\n      if (xhr.status != 200)\n        reject(Error(xhr.statusText));\n      else\n        resolve(xhr.response);\n    });\n\n    xhr.send();\n  });\n}\n\n/**\n * Sets attributes on a given DOM element.\n * @param {DOMElement} element The element on which to set the attributes.\n * @param {object} An object with keys (serving as attribute names) and values.\n */\nfunction setAttributes(el, attrs) {\n  attrs = attrs || {}\n  for (var attr in attrs) {\n    if (attr !== 'src')\n      el.setAttribute(attr, attrs[attr]);\n  }\n  // Workaround for Chromium: set <img>'s src attribute after all other\n  // attributes to ensure the policy is applied.\n  for (var attr in attrs) {\n    if (attr === 'src')\n      el.setAttribute(attr, attrs[attr]);\n  }\n}\n\n/**\n * Binds to success and error events of an object wrapping them into a promise\n *     available through {@code element.eventPromise}. The success event\n *     resolves and error event rejects.\n * This method adds event listeners, and then removes all the added listeners\n * when one of listened event is fired.\n * @param {object} element An object supporting events on which to bind the\n *     promise.\n * @param {string} resolveEventName [=\"load\"] The event name to bind resolve to.\n * @param {string} rejectEventName [=\"error\"] The event name to bind reject to.\n */\nfunction bindEvents(element, resolveEventName, rejectEventName) {\n  element.eventPromise =\n      bindEvents2(element, resolveEventName, element, rejectEventName);\n}\n\n// Returns a promise wrapping success and error events of objects.\n// This is a variant of bindEvents that can accept separate objects for each\n// events and two events to reject, and doesn't set `eventPromise`.\n//\n// When `resolveObject`'s `resolveEventName` event (default: \"load\") is\n// fired, the promise is resolved with the event.\n//\n// When `rejectObject`'s `rejectEventName` event (default: \"error\") or\n// `rejectObject2`'s `rejectEventName2` event (default: \"error\") is\n// fired, the promise is rejected.\n//\n// `rejectObject2` is optional.\nfunction bindEvents2(resolveObject, resolveEventName, rejectObject, rejectEventName, rejectObject2, rejectEventName2) {\n  return new Promise(function(resolve, reject) {\n    const actualResolveEventName = resolveEventName || \"load\";\n    const actualRejectEventName = rejectEventName || \"error\";\n    const actualRejectEventName2 = rejectEventName2 || \"error\";\n\n    const resolveHandler = function(event) {\n      cleanup();\n      resolve(event);\n    };\n\n    const rejectHandler = function(event) {\n      // Chromium starts propagating errors from worker.onerror to\n      // window.onerror. This handles the uncaught exceptions in tests.\n      event.preventDefault();\n      cleanup();\n      reject(event);\n    };\n\n    const cleanup = function() {\n      resolveObject.removeEventListener(actualResolveEventName, resolveHandler);\n      rejectObject.removeEventListener(actualRejectEventName, rejectHandler);\n      if (rejectObject2) {\n        rejectObject2.removeEventListener(actualRejectEventName2, rejectHandler);\n      }\n    };\n\n    resolveObject.addEventListener(actualResolveEventName, resolveHandler);\n    rejectObject.addEventListener(actualRejectEventName, rejectHandler);\n    if (rejectObject2) {\n      rejectObject2.addEventListener(actualRejectEventName2, rejectHandler);\n    }\n  });\n}\n\n/**\n * Creates a new DOM element.\n * @param {string} tagName The type of the DOM element.\n * @param {object} attrs A JSON with attributes to apply to the element.\n * @param {DOMElement} parent Optional - an existing DOM element to append to\n *     If not provided, the returned element will remain orphaned.\n * @param {boolean} doBindEvents Optional - Whether to bind to load and error\n *     events and provide the promise wrapping the events via the element's\n *     {@code eventPromise} property. Default value evaluates to false.\n * @return {DOMElement} The newly created DOM element.\n */\nfunction createElement(tagName, attrs, parentNode, doBindEvents) {\n  var element = document.createElement(tagName);\n\n  if (doBindEvents) {\n    bindEvents(element);\n    if (element.tagName == \"IFRAME\" && !('srcdoc' in attrs || 'src' in attrs)) {\n      // If we're loading a frame, ensure we spin the event loop after load to\n      // paper over the different event timing in Gecko vs Blink/WebKit\n      // see https://github.com/whatwg/html/issues/4965\n      element.eventPromise = element.eventPromise.then(() => {\n        return new Promise(resolve => setTimeout(resolve, 0))\n      });\n    }\n  }\n  // We set the attributes after binding to events to catch any\n  // event-triggering attribute changes. E.g. form submission.\n  //\n  // But be careful with images: unlike other elements they will start the load\n  // as soon as the attr is set, even if not in the document yet, and sometimes\n  // complete it synchronously, so the append doesn't have the effect we want.\n  // So for images, we want to set the attrs after appending, whereas for other\n  // elements we want to do it before appending.\n  var isImg = (tagName == \"img\");\n  if (!isImg)\n    setAttributes(element, attrs);\n\n  if (parentNode)\n    parentNode.appendChild(element);\n\n  if (isImg)\n    setAttributes(element, attrs);\n\n  return element;\n}\n\nfunction createRequestViaElement(tagName, attrs, parentNode) {\n  return createElement(tagName, attrs, parentNode, true).eventPromise;\n}\n\nfunction wrapResult(server_data) {\n  if (typeof(server_data) === \"string\") {\n    throw server_data;\n  }\n  return {\n    referrer: server_data.headers.referer,\n    headers: server_data.headers\n  }\n}\n\n// ===============================================================\n// Subresources\n// ===============================================================\n\n/**\n  @typedef RequestResult\n  @type {object}\n  Represents the result of sending an request.\n  All properties are optional. See the comments for\n  requestVia*() and invokeRequest() below to see which properties are set.\n\n  @property {Array<Object<string, string>>} headers\n    HTTP request headers sent to server.\n  @property {string} referrer - Referrer.\n  @property {string} location - The URL of the subresource.\n  @property {string} sourceContextUrl\n    the URL of the global object where the actual request is sent.\n*/\n\n/**\n  requestVia*(url, additionalAttributes) functions send a subresource\n  request from the current environment settings object.\n\n  @param {string} url\n    The URL of the subresource.\n  @param {Object<string, string>} additionalAttributes\n    Additional attributes set to DOM elements\n    (element-initiated requests only).\n\n  @returns {Promise} that are resolved with a RequestResult object\n  on successful requests.\n\n  - Category 1:\n      `headers`: set.\n      `referrer`: set via `document.referrer`.\n      `location`: set via `document.location`.\n      See `template/document.html.template`.\n  - Category 2:\n      `headers`: set.\n      `referrer`: set to `headers.referer` by `wrapResult()`.\n      `location`: not set.\n  - Category 3:\n      All the keys listed above are NOT set.\n  `sourceContextUrl` is not set here.\n\n  -------------------------------- -------- --------------------------\n  Function name                    Category Used in\n                                            -------- ------- ---------\n                                            referrer mixed-  upgrade-\n                                            policy   content insecure-\n                                            policy   content request\n  -------------------------------- -------- -------- ------- ---------\n  requestViaAnchor                 1        Y        Y       -\n  requestViaArea                   1        Y        Y       -\n  requestViaAudio                  3        -        Y       -\n  requestViaDedicatedWorker        2        Y        Y       Y\n  requestViaFetch                  2        Y        Y       -\n  requestViaForm                   2        -        Y       -\n  requestViaIframe                 1        Y        Y       -\n  requestViaImage                  2        Y        Y       -\n  requestViaLinkPrefetch           3        -        Y       -\n  requestViaLinkStylesheet         3        -        Y       -\n  requestViaObject                 3        -        Y       -\n  requestViaPicture                3        -        Y       -\n  requestViaScript                 2        Y        Y       -\n  requestViaSendBeacon             3        -        Y       -\n  requestViaSharedWorker           2        Y        Y       Y\n  requestViaVideo                  3        -        Y       -\n  requestViaWebSocket              3        -        Y       -\n  requestViaWorklet                3        -        Y       Y\n  requestViaXhr                    2        Y        Y       -\n  -------------------------------- -------- -------- ------- ---------\n*/\n\n/**\n * Creates a new iframe, binds load and error events, sets the src attribute and\n *     appends it to {@code document.body} .\n * @param {string} url The src for the iframe.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaIframe(url, additionalAttributes) {\n  const iframe = createElement(\n      \"iframe\",\n      Object.assign({\"src\": url}, additionalAttributes),\n      document.body,\n      false);\n  return bindEvents2(window, \"message\", iframe, \"error\", window, \"error\")\n      .then(event => {\n          if (event.source !== iframe.contentWindow)\n            return Promise.reject(new Error('Unexpected event.source'));\n          return event.data;\n        });\n}\n\n/**\n * Creates a new image, binds load and error events, sets the src attribute and\n *     appends it to {@code document.body} .\n * @param {string} url The src for the image.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaImage(url, additionalAttributes) {\n  const img = createElement(\n      \"img\",\n      // crossOrigin attribute is added to read the pixel data of the response.\n      Object.assign({\"src\": url, \"crossOrigin\": \"Anonymous\"}, additionalAttributes),\n      document.body, true);\n  return img.eventPromise.then(() => wrapResult(decodeImageData(img)));\n}\n\n// Helper for requestViaImage().\nfunction decodeImageData(img) {\n  var canvas = document.createElement(\"canvas\");\n  var context = canvas.getContext('2d');\n  context.drawImage(img, 0, 0);\n  var imgData = context.getImageData(0, 0, img.clientWidth, img.clientHeight);\n  const rgba = imgData.data;\n\n  let decodedBytes = new Uint8ClampedArray(rgba.length);\n  let decodedLength = 0;\n\n  for (var i = 0; i + 12 <= rgba.length; i += 12) {\n    // A single byte is encoded in three pixels. 8 pixel octets (among\n    // 9 octets = 3 pixels * 3 channels) are used to encode 8 bits,\n    // the most significant bit first, where `0` and `255` in pixel values\n    // represent `0` and `1` in bits, respectively.\n    // This encoding is used to avoid errors due to different color spaces.\n    const bits = [];\n    for (let j = 0; j < 3; ++j) {\n      bits.push(rgba[i + j * 4 + 0]);\n      bits.push(rgba[i + j * 4 + 1]);\n      bits.push(rgba[i + j * 4 + 2]);\n      // rgba[i + j * 4 + 3]: Skip alpha channel.\n    }\n    // The last one element is not used.\n    bits.pop();\n\n    // Decode a single byte.\n    let byte = 0;\n    for (let j = 0; j < 8; ++j) {\n      byte <<= 1;\n      if (bits[j] >= 128)\n        byte |= 1;\n    }\n\n    // Zero is the string terminator.\n    if (byte == 0)\n      break;\n\n    decodedBytes[decodedLength++] = byte;\n  }\n\n  // Remove trailing nulls from data.\n  decodedBytes = decodedBytes.subarray(0, decodedLength);\n  var string_data = (new TextDecoder(\"ascii\")).decode(decodedBytes);\n\n  return JSON.parse(string_data);\n}\n\n/**\n * Initiates a new XHR GET request to provided URL.\n * @param {string} url The endpoint URL for the XHR.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaXhr(url) {\n  return xhrRequest(url).then(result => wrapResult(result));\n}\n\n/**\n * Initiates a new GET request to provided URL via the Fetch API.\n * @param {string} url The endpoint URL for the Fetch.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaFetch(url) {\n  return fetch(url)\n    .then(res => res.json())\n    .then(j => wrapResult(j));\n}\n\nfunction dedicatedWorkerUrlThatFetches(url) {\n  return `data:text/javascript,\n    fetch('${url}')\n      .then(r => r.json())\n      .then(j => postMessage(j))\n      .catch((e) => postMessage(e.message));`;\n}\n\nfunction workerUrlThatImports(url, additionalAttributes) {\n  let csp = \"\";\n  if (additionalAttributes && additionalAttributes.contentSecurityPolicy) {\n    csp=`&contentSecurityPolicy=${additionalAttributes.contentSecurityPolicy}`;\n  }\n  return `/common/security-features/subresource/static-import.py` +\n      `?import_url=${encodeURIComponent(url)}${csp}`;\n}\n\nfunction workerDataUrlThatImports(url) {\n  return `data:text/javascript,import '${url}';`;\n}\n\n/**\n * Creates a new Worker, binds message and error events wrapping them into.\n *     {@code worker.eventPromise} and posts an empty string message to start\n *     the worker.\n * @param {string} url The endpoint URL for the worker script.\n * @param {object} options The options for Worker constructor.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaDedicatedWorker(url, options) {\n  var worker;\n  try {\n    worker = new Worker(url, options);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n  worker.postMessage('');\n  return bindEvents2(worker, \"message\", worker, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\nfunction requestViaSharedWorker(url, options) {\n  var worker;\n  try {\n    worker = new SharedWorker(url, options);\n  } catch(e) {\n    return Promise.reject(e);\n  }\n  const promise = bindEvents2(worker.port, \"message\", worker, \"error\")\n    .then(event => wrapResult(event.data));\n  worker.port.start();\n  return promise;\n}\n\n// Returns a reference to a worklet object corresponding to a given type.\nfunction get_worklet(type) {\n  if (type == 'animation')\n    return CSS.animationWorklet;\n  if (type == 'layout')\n    return CSS.layoutWorklet;\n  if (type == 'paint')\n    return CSS.paintWorklet;\n  if (type == 'audio')\n    return new OfflineAudioContext(2,44100*40,44100).audioWorklet;\n\n  throw new Error('unknown worklet type is passed.');\n}\n\nfunction requestViaWorklet(type, url) {\n  try {\n    return get_worklet(type).addModule(url);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Creates a navigable element with the name `navigableElementName`\n * (<a>, <area>, or <form>) under `parentNode`, and\n * performs a navigation by `trigger()` (e.g. clicking <a>).\n * To avoid navigating away from the current execution context,\n * a target attribute is set to point to a new helper iframe.\n * @param {string} navigableElementName\n * @param {object} additionalAttributes The attributes of the navigable element.\n * @param {DOMElement} parentNode\n * @param {function(DOMElement} trigger A callback called after the navigable\n * element is inserted and should trigger navigation using the element.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaNavigable(navigableElementName, additionalAttributes,\n                             parentNode, trigger) {\n  const name = guid();\n\n  const iframe =\n    createElement(\"iframe\", {\"name\": name, \"id\": name}, parentNode, false);\n\n  const navigable = createElement(\n      navigableElementName,\n      Object.assign({\"target\": name}, additionalAttributes),\n      parentNode, false);\n\n  const promise =\n    bindEvents2(window, \"message\", iframe, \"error\", window, \"error\")\n      .then(event => {\n          if (event.source !== iframe.contentWindow)\n            return Promise.reject(new Error('Unexpected event.source'));\n          return event.data;\n        });\n  trigger(navigable);\n  return promise;\n}\n\n/**\n * Creates a new anchor element, appends it to {@code document.body} and\n *     performs the navigation.\n * @param {string} url The URL to navigate to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaAnchor(url, additionalAttributes) {\n  return requestViaNavigable(\n      \"a\",\n      Object.assign({\"href\": url, \"innerHTML\": \"Link to resource\"},\n                    additionalAttributes),\n      document.body, a => a.click());\n}\n\n/**\n * Creates a new area element, appends it to {@code document.body} and performs\n *     the navigation.\n * @param {string} url The URL to navigate to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaArea(url, additionalAttributes) {\n  // TODO(kristijanburnik): Append to map and add image.\n  return requestViaNavigable(\n      \"area\",\n      Object.assign({\"href\": url}, additionalAttributes),\n      document.body, area => area.click());\n}\n\n/**\n * Creates a new script element, sets the src to url, and appends it to\n *     {@code document.body}.\n * @param {string} url The src URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaScript(url, additionalAttributes) {\n  const script = createElement(\n      \"script\",\n      Object.assign({\"src\": url}, additionalAttributes),\n      document.body,\n      false);\n\n  return bindEvents2(window, \"message\", script, \"error\", window, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\n/**\n * Creates a new script element that performs a dynamic import to `url`, and\n * appends the script element to {@code document.body}.\n * @param {string} url The src URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaDynamicImport(url, additionalAttributes) {\n  const scriptUrl = `data:text/javascript,import(\"${url}\");`;\n  const script = createElement(\n      \"script\",\n      Object.assign({\"src\": scriptUrl}, additionalAttributes),\n      document.body,\n      false);\n\n  return bindEvents2(window, \"message\", script, \"error\", window, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\n/**\n * Creates a new form element, sets attributes, appends it to\n *     {@code document.body} and submits the form.\n * @param {string} url The URL to submit to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaForm(url, additionalAttributes) {\n  return requestViaNavigable(\n      \"form\",\n      Object.assign({\"action\": url, \"method\": \"POST\"}, additionalAttributes),\n      document.body, form => form.submit());\n}\n\n/**\n * Creates a new link element for a stylesheet, binds load and error events,\n *     sets the href to url and appends it to {@code document.head}.\n * @param {string} url The URL for a stylesheet.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaLinkStylesheet(url) {\n  return createRequestViaElement(\"link\",\n                                 {\"rel\": \"stylesheet\", \"href\": url},\n                                 document.head);\n}\n\n/**\n * Creates a new link element for a prefetch, binds load and error events, sets\n *     the href to url and appends it to {@code document.head}.\n * @param {string} url The URL of a resource to prefetch.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaLinkPrefetch(url) {\n  var link = document.createElement('link');\n  if (link.relList && link.relList.supports && link.relList.supports(\"prefetch\")) {\n    return createRequestViaElement(\"link\",\n                                   {\"rel\": \"prefetch\", \"href\": url},\n                                   document.head);\n  } else {\n    return Promise.reject(\"This browser does not support 'prefetch'.\");\n  }\n}\n\n/**\n * Initiates a new beacon request.\n * @param {string} url The URL of a resource to prefetch.\n * @return {Promise} The promise for success/error events.\n */\nasync function requestViaSendBeacon(url) {\n  function wait(ms) {\n    return new Promise(resolve => step_timeout(resolve, ms));\n  }\n  if (!navigator.sendBeacon(url)) {\n    // If mixed-content check fails, it should return false.\n    throw new Error('sendBeacon() fails.');\n  }\n  // We don't have a means to see the result of sendBeacon() request\n  // for sure. Let's wait for a while and let the generic test function\n  // ask the server for the result.\n  await wait(500);\n  return 'allowed';\n}\n\n/**\n * Creates a new media element with a child source element, binds loadeddata and\n *     error events, sets attributes and appends to document.body.\n * @param {string} type The type of the media element (audio/video/picture).\n * @param {object} media_attrs The attributes for the media element.\n * @param {object} source_attrs The attributes for the child source element.\n * @return {DOMElement} The newly created media element.\n */\nfunction createMediaElement(type, media_attrs, source_attrs) {\n  var mediaElement = createElement(type, {});\n\n  var sourceElement = createElement(\"source\", {});\n\n  mediaElement.eventPromise = new Promise(function(resolve, reject) {\n    mediaElement.addEventListener(\"loadeddata\", function (e) {\n      resolve(e);\n    });\n\n    // Safari doesn't fire an `error` event when blocking mixed content.\n    mediaElement.addEventListener(\"stalled\", function(e) {\n      reject(e);\n    });\n\n    sourceElement.addEventListener(\"error\", function(e) {\n      reject(e);\n    });\n  });\n\n  setAttributes(mediaElement, media_attrs);\n  setAttributes(sourceElement, source_attrs);\n\n  mediaElement.appendChild(sourceElement);\n  document.body.appendChild(mediaElement);\n\n  return mediaElement;\n}\n\n/**\n * Creates a new video element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}.\n * @param {string} url The URL of the video.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaVideo(url) {\n  return createMediaElement(\"video\",\n                            {},\n                            {\"src\": url}).eventPromise;\n}\n\n/**\n * Creates a new audio element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}.\n * @param {string} url The URL of the audio.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaAudio(url) {\n  return createMediaElement(\"audio\",\n                            {},\n                            {\"type\": \"audio/wav\", \"src\": url}).eventPromise;\n}\n\n/**\n * Creates a new picture element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}. Also\n *     creates new image element appending it to the picture\n * @param {string} url The URL of the image for the source and image elements.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaPicture(url) {\n  var picture = createMediaElement(\"picture\", {}, {\"srcset\": url,\n                                                \"type\": \"image/png\"});\n  return createRequestViaElement(\"img\", {\"src\": url}, picture);\n}\n\n/**\n * Creates a new object element, binds load and error events, sets the data to\n *     url, and appends it to {@code document.body}.\n * @param {string} url The data URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaObject(url) {\n  return createRequestViaElement(\"object\", {\"data\": url, \"type\": \"text/html\"}, document.body);\n}\n\n/**\n * Creates a new WebSocket pointing to {@code url} and sends a message string\n * \"echo\". The {@code message} and {@code error} events are triggering the\n * returned promise resolve/reject events.\n * @param {string} url The URL for WebSocket to connect to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaWebSocket(url) {\n  return new Promise(function(resolve, reject) {\n    var websocket = new WebSocket(url);\n\n    websocket.addEventListener(\"message\", function(e) {\n      resolve(e.data);\n    });\n\n    websocket.addEventListener(\"open\", function(e) {\n      websocket.send(\"echo\");\n    });\n\n    websocket.addEventListener(\"error\", function(e) {\n      reject(e)\n    });\n  })\n  .then(data => {\n      return JSON.parse(data);\n    });\n}\n\n/**\n  @typedef SubresourceType\n  @type {string}\n\n  Represents how a subresource is sent.\n  The keys of `subresourceMap` below are the valid values.\n*/\n\n// Subresource paths and invokers.\nconst subresourceMap = {\n  \"a-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaAnchor,\n  },\n  \"area-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaArea,\n  },\n  \"audio-tag\": {\n    path: \"/common/security-features/subresource/audio.py\",\n    invoker: requestViaAudio,\n  },\n  \"beacon\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaSendBeacon,\n  },\n  \"fetch\": {\n    path: \"/common/security-features/subresource/xhr.py\",\n    invoker: requestViaFetch,\n  },\n  \"form-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaForm,\n  },\n  \"iframe-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaIframe,\n  },\n  \"img-tag\": {\n    path: \"/common/security-features/subresource/image.py\",\n    invoker: requestViaImage,\n  },\n  \"link-css-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaLinkStylesheet,\n  },\n  \"link-prefetch-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaLinkPrefetch,\n  },\n  \"object-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaObject,\n  },\n  \"picture-tag\": {\n    path: \"/common/security-features/subresource/image.py\",\n    invoker: requestViaPicture,\n  },\n  \"script-tag\": {\n    path: \"/common/security-features/subresource/script.py\",\n    invoker: requestViaScript,\n  },\n  \"script-tag-dynamic-import\": {\n    path: \"/common/security-features/subresource/script.py\",\n    invoker: requestViaDynamicImport,\n  },\n  \"video-tag\": {\n    path: \"/common/security-features/subresource/video.py\",\n    invoker: requestViaVideo,\n  },\n  \"xhr\": {\n    path: \"/common/security-features/subresource/xhr.py\",\n    invoker: requestViaXhr,\n  },\n\n  \"worker-classic\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url => requestViaDedicatedWorker(url),\n  },\n  \"worker-module\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url => requestViaDedicatedWorker(url, {type: \"module\"}),\n  },\n  \"worker-import\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: (url, additionalAttributes) =>\n        requestViaDedicatedWorker(workerUrlThatImports(url, additionalAttributes), {type: \"module\"}),\n  },\n  \"worker-import-data\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url =>\n        requestViaDedicatedWorker(workerDataUrlThatImports(url), {type: \"module\"}),\n  },\n  \"sharedworker-classic\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url => requestViaSharedWorker(url),\n  },\n  \"sharedworker-module\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url => requestViaSharedWorker(url, {type: \"module\"}),\n  },\n  \"sharedworker-import\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: (url, additionalAttributes) =>\n        requestViaSharedWorker(workerUrlThatImports(url, additionalAttributes), {type: \"module\"}),\n  },\n  \"sharedworker-import-data\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url =>\n        requestViaSharedWorker(workerDataUrlThatImports(url), {type: \"module\"}),\n  },\n\n  \"websocket\": {\n    path: \"/stash_responder\",\n    invoker: requestViaWebSocket,\n  },\n};\nfor (const workletType of ['animation', 'audio', 'layout', 'paint']) {\n  subresourceMap[`worklet-${workletType}`] = {\n      path: \"/common/security-features/subresource/worker.py\",\n      invoker: url => requestViaWorklet(workletType, url)\n    };\n  subresourceMap[`worklet-${workletType}-import-data`] = {\n      path: \"/common/security-features/subresource/worker.py\",\n      invoker: url =>\n          requestViaWorklet(workletType, workerDataUrlThatImports(url))\n    };\n}\n\n/**\n  @typedef RedirectionType\n  @type {string}\n\n  Represents what redirects should occur to the subresource request\n  after initial request.\n  See preprocess_redirection() in\n  /common/security-features/subresource/subresource.py for valid values.\n*/\n\n/**\n  Construct subresource (and related) origin.\n\n  @param {string} originType\n  @returns {object} the origin of the subresource.\n*/\nfunction getSubresourceOrigin(originType) {\n  const httpProtocol = \"http\";\n  const httpsProtocol = \"https\";\n  const wsProtocol = \"ws\";\n  const wssProtocol = \"wss\";\n\n  const sameOriginHost = \"web-platform.test\";\n  const crossOriginHost = \"www1.web-platform.test\";\n\n  // These values can evaluate to either empty strings or a \":port\" string.\n  const httpPort = getNormalizedPort(parseInt(\"8000\", 10));\n  const httpsRawPort = parseInt(\"8443\", 10);\n  const httpsPort = getNormalizedPort(httpsRawPort);\n  const wsPort = getNormalizedPort(parseInt(\"8888\", 10));\n  const wssRawPort = parseInt(\"8889\", 10);\n  const wssPort = getNormalizedPort(wssRawPort);\n\n  /**\n    @typedef OriginType\n    @type {string}\n\n    Represents the origin of the subresource request URL.\n    The keys of `originMap` below are the valid values.\n\n    Note that there can be redirects from the specified origin\n    (see RedirectionType), and thus the origin of the subresource\n    response URL might be different from what is specified by OriginType.\n  */\n  const originMap = {\n    \"same-https\": httpsProtocol + \"://\" + sameOriginHost + httpsPort,\n    \"same-http\": httpProtocol + \"://\" + sameOriginHost + httpPort,\n    \"cross-https\": httpsProtocol + \"://\" + crossOriginHost + httpsPort,\n    \"cross-http\": httpProtocol + \"://\" + crossOriginHost + httpPort,\n    \"same-wss\": wssProtocol + \"://\" + sameOriginHost + wssPort,\n    \"same-ws\": wsProtocol + \"://\" + sameOriginHost + wsPort,\n    \"cross-wss\": wssProtocol + \"://\" + crossOriginHost + wssPort,\n    \"cross-ws\": wsProtocol + \"://\" + crossOriginHost + wsPort,\n\n    // The following origin types are used for upgrade-insecure-requests tests:\n    // These rely on some unintuitive cleverness due to WPT's test setup:\n    // 'Upgrade-Insecure-Requests' does not upgrade the port number,\n    // so we use URLs in the form `http://[domain]:[https-port]`,\n    // which will be upgraded to `https://[domain]:[https-port]`.\n    // If the upgrade fails, the load will fail, as we don't serve HTTP over\n    // the secure port.\n    \"same-http-downgrade\":\n        httpProtocol + \"://\" + sameOriginHost + \":\" + httpsRawPort,\n    \"cross-http-downgrade\":\n        httpProtocol + \"://\" + crossOriginHost + \":\" + httpsRawPort,\n    \"same-ws-downgrade\":\n        wsProtocol + \"://\" + sameOriginHost + \":\" + wssRawPort,\n    \"cross-ws-downgrade\":\n        wsProtocol + \"://\" + crossOriginHost + \":\" + wssRawPort,\n  };\n\n  return originMap[originType];\n}\n\n/**\n  Construct subresource (and related) URLs.\n\n  @param {SubresourceType} subresourceType\n  @param {OriginType} originType\n  @param {RedirectionType} redirectionType\n  @returns {object} with following properties:\n    {string} testUrl\n      The subresource request URL.\n    {string} announceUrl\n    {string} assertUrl\n      The URLs to be used for detecting whether `testUrl` is actually sent\n      to the server.\n      1. Fetch `announceUrl` first,\n      2. then possibly fetch `testUrl`, and\n      3. finally fetch `assertUrl`.\n         The fetch result of `assertUrl` should indicate whether\n         `testUrl` is actually sent to the server or not.\n*/\nfunction getRequestURLs(subresourceType, originType, redirectionType) {\n  const key = guid();\n  const value = guid();\n\n  // We use the same stash path for both HTTP/S and WS/S stash requests.\n  const stashPath = encodeURIComponent(\"/mixed-content\");\n\n  const stashEndpoint = \"/common/security-features/subresource/xhr.py?key=\" +\n                        key + \"&path=\" + stashPath;\n  return {\n    testUrl:\n      getSubresourceOrigin(originType) +\n        subresourceMap[subresourceType].path +\n        \"?redirection=\" + encodeURIComponent(redirectionType) +\n        \"&action=purge&key=\" + key +\n        \"&path=\" + stashPath,\n    announceUrl: stashEndpoint + \"&action=put&value=\" + value,\n    assertUrl: stashEndpoint + \"&action=take\",\n  };\n}\n\n// ===============================================================\n// Source Context\n// ===============================================================\n// Requests can be sent from several source contexts,\n// such as the main documents, iframes, workers, or so,\n// possibly nested, and possibly with <meta>/http headers added.\n// invokeRequest() and invokeFrom*() functions handles\n// SourceContext-related setup in client-side.\n\n/**\n  invokeRequest() invokes a subresource request\n  (specified as `subresource`)\n  from a (possibly nested) environment settings object\n  (specified as `sourceContextList`).\n\n  For nested contexts, invokeRequest() calls an invokeFrom*() function\n  that creates a nested environment settings object using\n  /common/security-features/scope/, which calls invokeRequest()\n  again inside the nested environment settings object.\n  This cycle continues until all specified\n  nested environment settings object are created, and\n  finally invokeRequest() calls a requestVia*() function to start the\n  subresource request from the inner-most environment settings object.\n\n  @param {Subresource} subresource\n  @param {Array<SourceContext>} sourceContextList\n\n  @returns {Promise} A promise that is resolved with an RequestResult object.\n  `sourceContextUrl` is always set. For whether other properties are set,\n  see the comments for requestVia*() above.\n*/\nfunction invokeRequest(subresource, sourceContextList) {\n  if (sourceContextList.length === 0) {\n    // No further nested global objects. Send the subresource request here.\n\n    const additionalAttributes = {};\n    /** @type {PolicyDelivery} policyDelivery */\n    for (const policyDelivery of (subresource.policyDeliveries || [])) {\n      // Depending on the delivery method, extend the subresource element with\n      // these attributes.\n      if (policyDelivery.deliveryType === \"attr\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      } else if (policyDelivery.deliveryType === \"rel-noref\") {\n        additionalAttributes[\"rel\"] = \"noreferrer\";\n      } else if (policyDelivery.deliveryType === \"http-rp\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      } else if (policyDelivery.deliveryType === \"meta\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      }\n    }\n\n    return subresourceMap[subresource.subresourceType].invoker(\n        subresource.url,\n        additionalAttributes)\n      .then(result => Object.assign(\n          {sourceContextUrl: location.toString()},\n          result));\n  }\n\n  // Defines invokers for each valid SourceContext.sourceContextType.\n  const sourceContextMap = {\n    \"srcdoc\": { // <iframe srcdoc></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"iframe\": { // <iframe src=\"same-origin-URL\"></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"iframe-blank\": { // <iframe></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"worker-classic\": {\n      // Classic dedicated worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", false, {}),\n    },\n    \"worker-classic-data\": {\n      // Classic dedicated worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", true, {}),\n    },\n    \"worker-module\": {\n      // Module dedicated worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", false, {type: 'module'}),\n    },\n    \"worker-module-data\": {\n      // Module dedicated worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", true, {type: 'module'}),\n    },\n    \"sharedworker-classic\": {\n      // Classic shared worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", false, {}),\n    },\n    \"sharedworker-classic-data\": {\n      // Classic shared worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", true, {}),\n    },\n    \"sharedworker-module\": {\n      // Module shared worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", false, {type: 'module'}),\n    },\n    \"sharedworker-module-data\": {\n      // Module shared worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", true, {type: 'module'}),\n    },\n  };\n\n  return sourceContextMap[sourceContextList[0].sourceContextType].invoker(\n      subresource, sourceContextList);\n}\n\n// Quick hack to expose invokeRequest when common.sub.js is loaded either\n// as a classic or module script.\nself.invokeRequest = invokeRequest;\n\n/**\n  invokeFrom*() functions are helper functions with the same parameters\n  and return values as invokeRequest(), that are tied to specific types\n  of top-most environment settings objects.\n  For example, invokeFromIframe() is the helper function for the cases where\n  sourceContextList[0] is an iframe.\n*/\n\n/**\n  @param {string} workerType\n    \"worker\" (for dedicated worker) or \"sharedworker\".\n  @param {boolean} isDataUrl\n    true if the worker script is loaded from data: URL.\n    Otherwise, the script is loaded from same-origin.\n  @param {object} workerOptions\n    The `options` argument for Worker constructor.\n\n  Other parameters and return values are the same as those of invokeRequest().\n*/\nfunction invokeFromWorker(workerType, isDataUrl, workerOptions,\n                          subresource, sourceContextList) {\n  const currentSourceContext = sourceContextList[0];\n  let workerUrl =\n    \"/common/security-features/scope/worker.py?policyDeliveries=\" +\n    encodeURIComponent(JSON.stringify(\n        currentSourceContext.policyDeliveries || []));\n  if (workerOptions.type === 'module') {\n    workerUrl += \"&type=module\";\n  }\n\n  let promise;\n  if (isDataUrl) {\n    promise = fetch(workerUrl)\n      .then(r => r.text())\n      .then(source => {\n          return 'data:text/javascript;base64,' + btoa(source);\n        });\n  } else {\n    promise = Promise.resolve(workerUrl);\n  }\n\n  return promise\n    .then(url => {\n      if (workerType === \"worker\") {\n        const worker = new Worker(url, workerOptions);\n        worker.postMessage({subresource: subresource,\n                            sourceContextList: sourceContextList.slice(1)});\n        return bindEvents2(worker, \"message\", worker, \"error\", window, \"error\");\n      } else if (workerType === \"sharedworker\") {\n        const worker = new SharedWorker(url, workerOptions);\n        worker.port.start();\n        worker.port.postMessage({subresource: subresource,\n                                 sourceContextList: sourceContextList.slice(1)});\n        return bindEvents2(worker.port, \"message\", worker, \"error\", window, \"error\");\n      } else {\n        throw new Error('Invalid worker type: ' + workerType);\n      }\n    })\n    .then(event => {\n        if (event.data.error)\n          return Promise.reject(event.data.error);\n        return event.data;\n      });\n}\n\nfunction invokeFromIframe(subresource, sourceContextList) {\n  const currentSourceContext = sourceContextList[0];\n  const frameUrl =\n    \"/common/security-features/scope/document.py?policyDeliveries=\" +\n    encodeURIComponent(JSON.stringify(\n        currentSourceContext.policyDeliveries || []));\n\n  let iframe;\n  let promise;\n  if (currentSourceContext.sourceContextType === 'srcdoc') {\n    promise = fetch(frameUrl)\n      .then(r => r.text())\n      .then(srcdoc => {\n          iframe = createElement(\n              \"iframe\", {srcdoc: srcdoc}, document.body, true);\n          return iframe.eventPromise;\n        });\n  } else if (currentSourceContext.sourceContextType === 'iframe') {\n    iframe = createElement(\"iframe\", {src: frameUrl}, document.body, true);\n    promise = iframe.eventPromise;\n  } else if (currentSourceContext.sourceContextType === 'iframe-blank') {\n    let frameContent;\n    promise = fetch(frameUrl)\n      .then(r => r.text())\n      .then(t => {\n          frameContent = t;\n          iframe = createElement(\"iframe\", {}, document.body, true);\n          return iframe.eventPromise;\n        })\n      .then(() => {\n          // Reinitialize `iframe.eventPromise` with a new promise\n          // that catches the load event for the document.write() below.\n          bindEvents(iframe);\n\n          iframe.contentDocument.write(frameContent);\n          iframe.contentDocument.close();\n          return iframe.eventPromise;\n        });\n  }\n\n  return promise\n    .then(() => {\n        const promise = bindEvents2(\n            window, \"message\", iframe, \"error\", window, \"error\");\n        iframe.contentWindow.postMessage(\n            {subresource: subresource,\n             sourceContextList: sourceContextList.slice(1)},\n            \"*\");\n        return promise;\n      })\n    .then(event => {\n        if (event.data.error)\n          return Promise.reject(event.data.error);\n        return event.data;\n      });\n}\n\n// SanityChecker does nothing in release mode. See sanity-checker.js for debug\n// mode.\nfunction SanityChecker() {}\nSanityChecker.prototype.checkScenario = function() {};\nSanityChecker.prototype.setFailTimeout = function(test, timeout) {};\nSanityChecker.prototype.checkSubresourceResult = function() {};\n"},{"url":"http://www1.web-platform.test:8888/stash_responder?redirection=no-redirect&action=purge&key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content","request_start":1696742124.2309911,"response_start":1696742124.2345629,"request_end":1696742124.2314894,"response_end":1696742124.2350395,"ts":1696742124.2352602,"body":""},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=4bd1da16-e662-4962-b3a1-79f4b183f767&path=%2Fmixed-content&action=take","request_start":1696742124.2626638,"response_start":1696742124.2676523,"request_end":1696742124.263268,"response_end":1696742124.2684793,"ts":1696742124.2687407,"body":"{\"status\": \"allowed\", \"result\": null}"},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=put&value=4f0be357-dbd8-4ad1-9604-244ae340208d","request_start":1696742124.2947466,"response_start":1696742124.2994497,"request_end":1696742124.2954023,"response_end":1696742124.3000379,"ts":1696742124.3002672,"body":"{\"status\": \"success\", \"result\": \"0312780e-6cd9-4c83-953e-00dc973e454a\"}"},{"url":"https://web-platform.test:8443/common/security-features/scope/worker.py?policyDeliveries=%5B%5D&type=module","request_start":1696742124.3198075,"response_start":1696742124.322512,"request_end":1696742124.3203251,"response_end":1696742124.3231657,"ts":1696742124.323413,"body":"import \"https://web-platform.test:8443/common/security-features/resources/common.sub.js\";\n\nif ('DedicatedWorkerGlobalScope' in self &&\n    self instanceof DedicatedWorkerGlobalScope) {\n  self.onmessage = event => onMessageFromParent(event, self);\n} else if ('SharedWorkerGlobalScope' in self &&\n    self instanceof SharedWorkerGlobalScope) {\n  onconnect = event => {\n    const port = event.ports[0];\n    port.onmessage = event => onMessageFromParent(event, port);\n  };\n}\n\n// Receive a message from the parent and start the test.\nfunction onMessageFromParent(event, port) {\n  const configurationError = \"\";\n  if (configurationError.length > 0) {\n    port.postMessage({error: configurationError});\n    return;\n  }\n\n  invokeRequest(event.data.subresource,\n                event.data.sourceContextList)\n    .then(result => port.postMessage(result))\n    .catch(e => {\n        const message = (e.error && e.error.stack) || e.message || \"Error\";\n        port.postMessage({error: message});\n      });\n}\n"},{"url":"https://web-platform.test:8443/common/security-features/resources/common.sub.js","request_start":1696742124.3327816,"response_start":1696742124.336343,"request_end":1696742124.3334064,"response_end":1696742124.3370564,"ts":1696742124.3373146,"body":"/**\n * @fileoverview Utilities for mixed-content in web-platform-tests.\n * @author burnik@google.com (Kristijan Burnik)\n * Disclaimer: Some methods of other authors are annotated in the corresponding\n *     method's JSDoc.\n */\n\n// ===============================================================\n// Types\n// ===============================================================\n// Objects of the following types are used to represent what kind of\n// subresource requests should be sent with what kind of policies,\n// from what kind of possibly nested source contexts.\n// The objects are represented as JSON objects (not JavaScript/Python classes\n// in a strict sense) to be passed between JavaScript/Python code.\n//\n// See also common/security-features/Types.md for high-level description.\n\n/**\n  @typedef PolicyDelivery\n  @type {object}\n  Referrer policy etc. can be applied/delivered in several ways.\n  A PolicyDelivery object specifies what policy is delivered and how.\n\n  @property {string} deliveryType\n    Specifies how the policy is delivered.\n    The valid deliveryType are:\n\n     \"attr\"\n        [A] DOM attributes e.g. referrerPolicy.\n\n      \"rel-noref\"\n        [A] <link rel=\"noreferrer\"> (referrer-policy only).\n\n      \"http-rp\"\n        [B] HTTP response headers.\n\n      \"meta\"\n        [B] <meta> elements.\n\n  @property {string} key\n  @property {string} value\n    Specifies what policy to be delivered. The valid keys are:\n\n      \"referrerPolicy\"\n        Referrer Policy\n        https://w3c.github.io/webappsec-referrer-policy/\n        Valid values are those listed in\n        https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n        (except that \"\" is represented as null/None)\n\n  A PolicyDelivery can be specified in several ways:\n\n  - (for [A]) Associated with an individual subresource request and\n    specified in `Subresource.policies`,\n    e.g. referrerPolicy attributes of DOM elements.\n    This is handled in invokeRequest().\n\n  - (for [B]) Associated with an nested environmental settings object and\n    specified in `SourceContext.policies`,\n    e.g. HTTP referrer-policy response headers of HTML/worker scripts.\n    This is handled in server-side under /common/security-features/scope/.\n\n  - (for [B]) Associated with the top-level HTML document.\n    This is handled by the generators.d\n*/\n\n/**\n  @typedef Subresource\n  @type {object}\n  A Subresource represents how a subresource request is sent.\n\n  @property{SubresourceType} subresourceType\n    How the subresource request is sent,\n    e.g. \"img-tag\" for sending a request via <img src>.\n    See the keys of `subresourceMap` for valid values.\n\n  @property{string} url\n    subresource's URL.\n    Typically this is constructed by getRequestURLs() below.\n\n  @property{PolicyDelivery} policyDeliveries\n    Policies delivered specific to the subresource request.\n*/\n\n/**\n  @typedef SourceContext\n  @type {object}\n\n  @property {string} sourceContextType\n    Kind of the source context to be used.\n    Valid values are the keys of `sourceContextMap` below.\n\n  @property {Array<PolicyDelivery>} policyDeliveries\n    A list of PolicyDelivery applied to the source context.\n*/\n\n// ===============================================================\n// General utility functions\n// ===============================================================\n\nfunction timeoutPromise(t, ms) {\n  return new Promise(resolve => { t.step_timeout(resolve, ms); });\n}\n\n/**\n * Normalizes the target port for use in a URL. For default ports, this is the\n *     empty string (omitted port), otherwise it's a colon followed by the port\n *     number. Ports 80, 443 and an empty string are regarded as default ports.\n * @param {number} targetPort The port to use\n * @return {string} The port portion for using as part of a URL.\n */\nfunction getNormalizedPort(targetPort) {\n  return ([80, 443, \"\"].indexOf(targetPort) >= 0) ? \"\" : \":\" + targetPort;\n}\n\n/**\n * Creates a GUID.\n *     See: https://en.wikipedia.org/wiki/Globally_unique_identifier\n *     Original author: broofa (http://www.broofa.com/)\n *     Sourced from: http://stackoverflow.com/a/2117523/4949715\n * @return {string} A pseudo-random GUID.\n */\nfunction guid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n/**\n * Initiates a new XHR via GET.\n * @param {string} url The endpoint URL for the XHR.\n * @param {string} responseType Optional - how should the response be parsed.\n *     Default is \"json\".\n *     See: https://xhr.spec.whatwg.org/#dom-xmlhttprequest-responsetype\n * @return {Promise} A promise wrapping the success and error events.\n */\nfunction xhrRequest(url, responseType) {\n  return new Promise(function(resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = responseType || \"json\";\n\n    xhr.addEventListener(\"error\", function() {\n      reject(Error(\"Network Error\"));\n    });\n\n    xhr.addEventListener(\"load\", function() {\n      if (xhr.status != 200)\n        reject(Error(xhr.statusText));\n      else\n        resolve(xhr.response);\n    });\n\n    xhr.send();\n  });\n}\n\n/**\n * Sets attributes on a given DOM element.\n * @param {DOMElement} element The element on which to set the attributes.\n * @param {object} An object with keys (serving as attribute names) and values.\n */\nfunction setAttributes(el, attrs) {\n  attrs = attrs || {}\n  for (var attr in attrs) {\n    if (attr !== 'src')\n      el.setAttribute(attr, attrs[attr]);\n  }\n  // Workaround for Chromium: set <img>'s src attribute after all other\n  // attributes to ensure the policy is applied.\n  for (var attr in attrs) {\n    if (attr === 'src')\n      el.setAttribute(attr, attrs[attr]);\n  }\n}\n\n/**\n * Binds to success and error events of an object wrapping them into a promise\n *     available through {@code element.eventPromise}. The success event\n *     resolves and error event rejects.\n * This method adds event listeners, and then removes all the added listeners\n * when one of listened event is fired.\n * @param {object} element An object supporting events on which to bind the\n *     promise.\n * @param {string} resolveEventName [=\"load\"] The event name to bind resolve to.\n * @param {string} rejectEventName [=\"error\"] The event name to bind reject to.\n */\nfunction bindEvents(element, resolveEventName, rejectEventName) {\n  element.eventPromise =\n      bindEvents2(element, resolveEventName, element, rejectEventName);\n}\n\n// Returns a promise wrapping success and error events of objects.\n// This is a variant of bindEvents that can accept separate objects for each\n// events and two events to reject, and doesn't set `eventPromise`.\n//\n// When `resolveObject`'s `resolveEventName` event (default: \"load\") is\n// fired, the promise is resolved with the event.\n//\n// When `rejectObject`'s `rejectEventName` event (default: \"error\") or\n// `rejectObject2`'s `rejectEventName2` event (default: \"error\") is\n// fired, the promise is rejected.\n//\n// `rejectObject2` is optional.\nfunction bindEvents2(resolveObject, resolveEventName, rejectObject, rejectEventName, rejectObject2, rejectEventName2) {\n  return new Promise(function(resolve, reject) {\n    const actualResolveEventName = resolveEventName || \"load\";\n    const actualRejectEventName = rejectEventName || \"error\";\n    const actualRejectEventName2 = rejectEventName2 || \"error\";\n\n    const resolveHandler = function(event) {\n      cleanup();\n      resolve(event);\n    };\n\n    const rejectHandler = function(event) {\n      // Chromium starts propagating errors from worker.onerror to\n      // window.onerror. This handles the uncaught exceptions in tests.\n      event.preventDefault();\n      cleanup();\n      reject(event);\n    };\n\n    const cleanup = function() {\n      resolveObject.removeEventListener(actualResolveEventName, resolveHandler);\n      rejectObject.removeEventListener(actualRejectEventName, rejectHandler);\n      if (rejectObject2) {\n        rejectObject2.removeEventListener(actualRejectEventName2, rejectHandler);\n      }\n    };\n\n    resolveObject.addEventListener(actualResolveEventName, resolveHandler);\n    rejectObject.addEventListener(actualRejectEventName, rejectHandler);\n    if (rejectObject2) {\n      rejectObject2.addEventListener(actualRejectEventName2, rejectHandler);\n    }\n  });\n}\n\n/**\n * Creates a new DOM element.\n * @param {string} tagName The type of the DOM element.\n * @param {object} attrs A JSON with attributes to apply to the element.\n * @param {DOMElement} parent Optional - an existing DOM element to append to\n *     If not provided, the returned element will remain orphaned.\n * @param {boolean} doBindEvents Optional - Whether to bind to load and error\n *     events and provide the promise wrapping the events via the element's\n *     {@code eventPromise} property. Default value evaluates to false.\n * @return {DOMElement} The newly created DOM element.\n */\nfunction createElement(tagName, attrs, parentNode, doBindEvents) {\n  var element = document.createElement(tagName);\n\n  if (doBindEvents) {\n    bindEvents(element);\n    if (element.tagName == \"IFRAME\" && !('srcdoc' in attrs || 'src' in attrs)) {\n      // If we're loading a frame, ensure we spin the event loop after load to\n      // paper over the different event timing in Gecko vs Blink/WebKit\n      // see https://github.com/whatwg/html/issues/4965\n      element.eventPromise = element.eventPromise.then(() => {\n        return new Promise(resolve => setTimeout(resolve, 0))\n      });\n    }\n  }\n  // We set the attributes after binding to events to catch any\n  // event-triggering attribute changes. E.g. form submission.\n  //\n  // But be careful with images: unlike other elements they will start the load\n  // as soon as the attr is set, even if not in the document yet, and sometimes\n  // complete it synchronously, so the append doesn't have the effect we want.\n  // So for images, we want to set the attrs after appending, whereas for other\n  // elements we want to do it before appending.\n  var isImg = (tagName == \"img\");\n  if (!isImg)\n    setAttributes(element, attrs);\n\n  if (parentNode)\n    parentNode.appendChild(element);\n\n  if (isImg)\n    setAttributes(element, attrs);\n\n  return element;\n}\n\nfunction createRequestViaElement(tagName, attrs, parentNode) {\n  return createElement(tagName, attrs, parentNode, true).eventPromise;\n}\n\nfunction wrapResult(server_data) {\n  if (typeof(server_data) === \"string\") {\n    throw server_data;\n  }\n  return {\n    referrer: server_data.headers.referer,\n    headers: server_data.headers\n  }\n}\n\n// ===============================================================\n// Subresources\n// ===============================================================\n\n/**\n  @typedef RequestResult\n  @type {object}\n  Represents the result of sending an request.\n  All properties are optional. See the comments for\n  requestVia*() and invokeRequest() below to see which properties are set.\n\n  @property {Array<Object<string, string>>} headers\n    HTTP request headers sent to server.\n  @property {string} referrer - Referrer.\n  @property {string} location - The URL of the subresource.\n  @property {string} sourceContextUrl\n    the URL of the global object where the actual request is sent.\n*/\n\n/**\n  requestVia*(url, additionalAttributes) functions send a subresource\n  request from the current environment settings object.\n\n  @param {string} url\n    The URL of the subresource.\n  @param {Object<string, string>} additionalAttributes\n    Additional attributes set to DOM elements\n    (element-initiated requests only).\n\n  @returns {Promise} that are resolved with a RequestResult object\n  on successful requests.\n\n  - Category 1:\n      `headers`: set.\n      `referrer`: set via `document.referrer`.\n      `location`: set via `document.location`.\n      See `template/document.html.template`.\n  - Category 2:\n      `headers`: set.\n      `referrer`: set to `headers.referer` by `wrapResult()`.\n      `location`: not set.\n  - Category 3:\n      All the keys listed above are NOT set.\n  `sourceContextUrl` is not set here.\n\n  -------------------------------- -------- --------------------------\n  Function name                    Category Used in\n                                            -------- ------- ---------\n                                            referrer mixed-  upgrade-\n                                            policy   content insecure-\n                                            policy   content request\n  -------------------------------- -------- -------- ------- ---------\n  requestViaAnchor                 1        Y        Y       -\n  requestViaArea                   1        Y        Y       -\n  requestViaAudio                  3        -        Y       -\n  requestViaDedicatedWorker        2        Y        Y       Y\n  requestViaFetch                  2        Y        Y       -\n  requestViaForm                   2        -        Y       -\n  requestViaIframe                 1        Y        Y       -\n  requestViaImage                  2        Y        Y       -\n  requestViaLinkPrefetch           3        -        Y       -\n  requestViaLinkStylesheet         3        -        Y       -\n  requestViaObject                 3        -        Y       -\n  requestViaPicture                3        -        Y       -\n  requestViaScript                 2        Y        Y       -\n  requestViaSendBeacon             3        -        Y       -\n  requestViaSharedWorker           2        Y        Y       Y\n  requestViaVideo                  3        -        Y       -\n  requestViaWebSocket              3        -        Y       -\n  requestViaWorklet                3        -        Y       Y\n  requestViaXhr                    2        Y        Y       -\n  -------------------------------- -------- -------- ------- ---------\n*/\n\n/**\n * Creates a new iframe, binds load and error events, sets the src attribute and\n *     appends it to {@code document.body} .\n * @param {string} url The src for the iframe.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaIframe(url, additionalAttributes) {\n  const iframe = createElement(\n      \"iframe\",\n      Object.assign({\"src\": url}, additionalAttributes),\n      document.body,\n      false);\n  return bindEvents2(window, \"message\", iframe, \"error\", window, \"error\")\n      .then(event => {\n          if (event.source !== iframe.contentWindow)\n            return Promise.reject(new Error('Unexpected event.source'));\n          return event.data;\n        });\n}\n\n/**\n * Creates a new image, binds load and error events, sets the src attribute and\n *     appends it to {@code document.body} .\n * @param {string} url The src for the image.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaImage(url, additionalAttributes) {\n  const img = createElement(\n      \"img\",\n      // crossOrigin attribute is added to read the pixel data of the response.\n      Object.assign({\"src\": url, \"crossOrigin\": \"Anonymous\"}, additionalAttributes),\n      document.body, true);\n  return img.eventPromise.then(() => wrapResult(decodeImageData(img)));\n}\n\n// Helper for requestViaImage().\nfunction decodeImageData(img) {\n  var canvas = document.createElement(\"canvas\");\n  var context = canvas.getContext('2d');\n  context.drawImage(img, 0, 0);\n  var imgData = context.getImageData(0, 0, img.clientWidth, img.clientHeight);\n  const rgba = imgData.data;\n\n  let decodedBytes = new Uint8ClampedArray(rgba.length);\n  let decodedLength = 0;\n\n  for (var i = 0; i + 12 <= rgba.length; i += 12) {\n    // A single byte is encoded in three pixels. 8 pixel octets (among\n    // 9 octets = 3 pixels * 3 channels) are used to encode 8 bits,\n    // the most significant bit first, where `0` and `255` in pixel values\n    // represent `0` and `1` in bits, respectively.\n    // This encoding is used to avoid errors due to different color spaces.\n    const bits = [];\n    for (let j = 0; j < 3; ++j) {\n      bits.push(rgba[i + j * 4 + 0]);\n      bits.push(rgba[i + j * 4 + 1]);\n      bits.push(rgba[i + j * 4 + 2]);\n      // rgba[i + j * 4 + 3]: Skip alpha channel.\n    }\n    // The last one element is not used.\n    bits.pop();\n\n    // Decode a single byte.\n    let byte = 0;\n    for (let j = 0; j < 8; ++j) {\n      byte <<= 1;\n      if (bits[j] >= 128)\n        byte |= 1;\n    }\n\n    // Zero is the string terminator.\n    if (byte == 0)\n      break;\n\n    decodedBytes[decodedLength++] = byte;\n  }\n\n  // Remove trailing nulls from data.\n  decodedBytes = decodedBytes.subarray(0, decodedLength);\n  var string_data = (new TextDecoder(\"ascii\")).decode(decodedBytes);\n\n  return JSON.parse(string_data);\n}\n\n/**\n * Initiates a new XHR GET request to provided URL.\n * @param {string} url The endpoint URL for the XHR.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaXhr(url) {\n  return xhrRequest(url).then(result => wrapResult(result));\n}\n\n/**\n * Initiates a new GET request to provided URL via the Fetch API.\n * @param {string} url The endpoint URL for the Fetch.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaFetch(url) {\n  return fetch(url)\n    .then(res => res.json())\n    .then(j => wrapResult(j));\n}\n\nfunction dedicatedWorkerUrlThatFetches(url) {\n  return `data:text/javascript,\n    fetch('${url}')\n      .then(r => r.json())\n      .then(j => postMessage(j))\n      .catch((e) => postMessage(e.message));`;\n}\n\nfunction workerUrlThatImports(url, additionalAttributes) {\n  let csp = \"\";\n  if (additionalAttributes && additionalAttributes.contentSecurityPolicy) {\n    csp=`&contentSecurityPolicy=${additionalAttributes.contentSecurityPolicy}`;\n  }\n  return `/common/security-features/subresource/static-import.py` +\n      `?import_url=${encodeURIComponent(url)}${csp}`;\n}\n\nfunction workerDataUrlThatImports(url) {\n  return `data:text/javascript,import '${url}';`;\n}\n\n/**\n * Creates a new Worker, binds message and error events wrapping them into.\n *     {@code worker.eventPromise} and posts an empty string message to start\n *     the worker.\n * @param {string} url The endpoint URL for the worker script.\n * @param {object} options The options for Worker constructor.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaDedicatedWorker(url, options) {\n  var worker;\n  try {\n    worker = new Worker(url, options);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n  worker.postMessage('');\n  return bindEvents2(worker, \"message\", worker, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\nfunction requestViaSharedWorker(url, options) {\n  var worker;\n  try {\n    worker = new SharedWorker(url, options);\n  } catch(e) {\n    return Promise.reject(e);\n  }\n  const promise = bindEvents2(worker.port, \"message\", worker, \"error\")\n    .then(event => wrapResult(event.data));\n  worker.port.start();\n  return promise;\n}\n\n// Returns a reference to a worklet object corresponding to a given type.\nfunction get_worklet(type) {\n  if (type == 'animation')\n    return CSS.animationWorklet;\n  if (type == 'layout')\n    return CSS.layoutWorklet;\n  if (type == 'paint')\n    return CSS.paintWorklet;\n  if (type == 'audio')\n    return new OfflineAudioContext(2,44100*40,44100).audioWorklet;\n\n  throw new Error('unknown worklet type is passed.');\n}\n\nfunction requestViaWorklet(type, url) {\n  try {\n    return get_worklet(type).addModule(url);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Creates a navigable element with the name `navigableElementName`\n * (<a>, <area>, or <form>) under `parentNode`, and\n * performs a navigation by `trigger()` (e.g. clicking <a>).\n * To avoid navigating away from the current execution context,\n * a target attribute is set to point to a new helper iframe.\n * @param {string} navigableElementName\n * @param {object} additionalAttributes The attributes of the navigable element.\n * @param {DOMElement} parentNode\n * @param {function(DOMElement} trigger A callback called after the navigable\n * element is inserted and should trigger navigation using the element.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaNavigable(navigableElementName, additionalAttributes,\n                             parentNode, trigger) {\n  const name = guid();\n\n  const iframe =\n    createElement(\"iframe\", {\"name\": name, \"id\": name}, parentNode, false);\n\n  const navigable = createElement(\n      navigableElementName,\n      Object.assign({\"target\": name}, additionalAttributes),\n      parentNode, false);\n\n  const promise =\n    bindEvents2(window, \"message\", iframe, \"error\", window, \"error\")\n      .then(event => {\n          if (event.source !== iframe.contentWindow)\n            return Promise.reject(new Error('Unexpected event.source'));\n          return event.data;\n        });\n  trigger(navigable);\n  return promise;\n}\n\n/**\n * Creates a new anchor element, appends it to {@code document.body} and\n *     performs the navigation.\n * @param {string} url The URL to navigate to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaAnchor(url, additionalAttributes) {\n  return requestViaNavigable(\n      \"a\",\n      Object.assign({\"href\": url, \"innerHTML\": \"Link to resource\"},\n                    additionalAttributes),\n      document.body, a => a.click());\n}\n\n/**\n * Creates a new area element, appends it to {@code document.body} and performs\n *     the navigation.\n * @param {string} url The URL to navigate to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaArea(url, additionalAttributes) {\n  // TODO(kristijanburnik): Append to map and add image.\n  return requestViaNavigable(\n      \"area\",\n      Object.assign({\"href\": url}, additionalAttributes),\n      document.body, area => area.click());\n}\n\n/**\n * Creates a new script element, sets the src to url, and appends it to\n *     {@code document.body}.\n * @param {string} url The src URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaScript(url, additionalAttributes) {\n  const script = createElement(\n      \"script\",\n      Object.assign({\"src\": url}, additionalAttributes),\n      document.body,\n      false);\n\n  return bindEvents2(window, \"message\", script, \"error\", window, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\n/**\n * Creates a new script element that performs a dynamic import to `url`, and\n * appends the script element to {@code document.body}.\n * @param {string} url The src URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaDynamicImport(url, additionalAttributes) {\n  const scriptUrl = `data:text/javascript,import(\"${url}\");`;\n  const script = createElement(\n      \"script\",\n      Object.assign({\"src\": scriptUrl}, additionalAttributes),\n      document.body,\n      false);\n\n  return bindEvents2(window, \"message\", script, \"error\", window, \"error\")\n    .then(event => wrapResult(event.data));\n}\n\n/**\n * Creates a new form element, sets attributes, appends it to\n *     {@code document.body} and submits the form.\n * @param {string} url The URL to submit to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaForm(url, additionalAttributes) {\n  return requestViaNavigable(\n      \"form\",\n      Object.assign({\"action\": url, \"method\": \"POST\"}, additionalAttributes),\n      document.body, form => form.submit());\n}\n\n/**\n * Creates a new link element for a stylesheet, binds load and error events,\n *     sets the href to url and appends it to {@code document.head}.\n * @param {string} url The URL for a stylesheet.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaLinkStylesheet(url) {\n  return createRequestViaElement(\"link\",\n                                 {\"rel\": \"stylesheet\", \"href\": url},\n                                 document.head);\n}\n\n/**\n * Creates a new link element for a prefetch, binds load and error events, sets\n *     the href to url and appends it to {@code document.head}.\n * @param {string} url The URL of a resource to prefetch.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaLinkPrefetch(url) {\n  var link = document.createElement('link');\n  if (link.relList && link.relList.supports && link.relList.supports(\"prefetch\")) {\n    return createRequestViaElement(\"link\",\n                                   {\"rel\": \"prefetch\", \"href\": url},\n                                   document.head);\n  } else {\n    return Promise.reject(\"This browser does not support 'prefetch'.\");\n  }\n}\n\n/**\n * Initiates a new beacon request.\n * @param {string} url The URL of a resource to prefetch.\n * @return {Promise} The promise for success/error events.\n */\nasync function requestViaSendBeacon(url) {\n  function wait(ms) {\n    return new Promise(resolve => step_timeout(resolve, ms));\n  }\n  if (!navigator.sendBeacon(url)) {\n    // If mixed-content check fails, it should return false.\n    throw new Error('sendBeacon() fails.');\n  }\n  // We don't have a means to see the result of sendBeacon() request\n  // for sure. Let's wait for a while and let the generic test function\n  // ask the server for the result.\n  await wait(500);\n  return 'allowed';\n}\n\n/**\n * Creates a new media element with a child source element, binds loadeddata and\n *     error events, sets attributes and appends to document.body.\n * @param {string} type The type of the media element (audio/video/picture).\n * @param {object} media_attrs The attributes for the media element.\n * @param {object} source_attrs The attributes for the child source element.\n * @return {DOMElement} The newly created media element.\n */\nfunction createMediaElement(type, media_attrs, source_attrs) {\n  var mediaElement = createElement(type, {});\n\n  var sourceElement = createElement(\"source\", {});\n\n  mediaElement.eventPromise = new Promise(function(resolve, reject) {\n    mediaElement.addEventListener(\"loadeddata\", function (e) {\n      resolve(e);\n    });\n\n    // Safari doesn't fire an `error` event when blocking mixed content.\n    mediaElement.addEventListener(\"stalled\", function(e) {\n      reject(e);\n    });\n\n    sourceElement.addEventListener(\"error\", function(e) {\n      reject(e);\n    });\n  });\n\n  setAttributes(mediaElement, media_attrs);\n  setAttributes(sourceElement, source_attrs);\n\n  mediaElement.appendChild(sourceElement);\n  document.body.appendChild(mediaElement);\n\n  return mediaElement;\n}\n\n/**\n * Creates a new video element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}.\n * @param {string} url The URL of the video.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaVideo(url) {\n  return createMediaElement(\"video\",\n                            {},\n                            {\"src\": url}).eventPromise;\n}\n\n/**\n * Creates a new audio element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}.\n * @param {string} url The URL of the audio.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaAudio(url) {\n  return createMediaElement(\"audio\",\n                            {},\n                            {\"type\": \"audio/wav\", \"src\": url}).eventPromise;\n}\n\n/**\n * Creates a new picture element, binds loadeddata and error events, sets\n *     attributes and source URL and appends to {@code document.body}. Also\n *     creates new image element appending it to the picture\n * @param {string} url The URL of the image for the source and image elements.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaPicture(url) {\n  var picture = createMediaElement(\"picture\", {}, {\"srcset\": url,\n                                                \"type\": \"image/png\"});\n  return createRequestViaElement(\"img\", {\"src\": url}, picture);\n}\n\n/**\n * Creates a new object element, binds load and error events, sets the data to\n *     url, and appends it to {@code document.body}.\n * @param {string} url The data URL.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaObject(url) {\n  return createRequestViaElement(\"object\", {\"data\": url, \"type\": \"text/html\"}, document.body);\n}\n\n/**\n * Creates a new WebSocket pointing to {@code url} and sends a message string\n * \"echo\". The {@code message} and {@code error} events are triggering the\n * returned promise resolve/reject events.\n * @param {string} url The URL for WebSocket to connect to.\n * @return {Promise} The promise for success/error events.\n */\nfunction requestViaWebSocket(url) {\n  return new Promise(function(resolve, reject) {\n    var websocket = new WebSocket(url);\n\n    websocket.addEventListener(\"message\", function(e) {\n      resolve(e.data);\n    });\n\n    websocket.addEventListener(\"open\", function(e) {\n      websocket.send(\"echo\");\n    });\n\n    websocket.addEventListener(\"error\", function(e) {\n      reject(e)\n    });\n  })\n  .then(data => {\n      return JSON.parse(data);\n    });\n}\n\n/**\n  @typedef SubresourceType\n  @type {string}\n\n  Represents how a subresource is sent.\n  The keys of `subresourceMap` below are the valid values.\n*/\n\n// Subresource paths and invokers.\nconst subresourceMap = {\n  \"a-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaAnchor,\n  },\n  \"area-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaArea,\n  },\n  \"audio-tag\": {\n    path: \"/common/security-features/subresource/audio.py\",\n    invoker: requestViaAudio,\n  },\n  \"beacon\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaSendBeacon,\n  },\n  \"fetch\": {\n    path: \"/common/security-features/subresource/xhr.py\",\n    invoker: requestViaFetch,\n  },\n  \"form-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaForm,\n  },\n  \"iframe-tag\": {\n    path: \"/common/security-features/subresource/document.py\",\n    invoker: requestViaIframe,\n  },\n  \"img-tag\": {\n    path: \"/common/security-features/subresource/image.py\",\n    invoker: requestViaImage,\n  },\n  \"link-css-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaLinkStylesheet,\n  },\n  \"link-prefetch-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaLinkPrefetch,\n  },\n  \"object-tag\": {\n    path: \"/common/security-features/subresource/empty.py\",\n    invoker: requestViaObject,\n  },\n  \"picture-tag\": {\n    path: \"/common/security-features/subresource/image.py\",\n    invoker: requestViaPicture,\n  },\n  \"script-tag\": {\n    path: \"/common/security-features/subresource/script.py\",\n    invoker: requestViaScript,\n  },\n  \"script-tag-dynamic-import\": {\n    path: \"/common/security-features/subresource/script.py\",\n    invoker: requestViaDynamicImport,\n  },\n  \"video-tag\": {\n    path: \"/common/security-features/subresource/video.py\",\n    invoker: requestViaVideo,\n  },\n  \"xhr\": {\n    path: \"/common/security-features/subresource/xhr.py\",\n    invoker: requestViaXhr,\n  },\n\n  \"worker-classic\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url => requestViaDedicatedWorker(url),\n  },\n  \"worker-module\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url => requestViaDedicatedWorker(url, {type: \"module\"}),\n  },\n  \"worker-import\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: (url, additionalAttributes) =>\n        requestViaDedicatedWorker(workerUrlThatImports(url, additionalAttributes), {type: \"module\"}),\n  },\n  \"worker-import-data\": {\n    path: \"/common/security-features/subresource/worker.py\",\n    invoker: url =>\n        requestViaDedicatedWorker(workerDataUrlThatImports(url), {type: \"module\"}),\n  },\n  \"sharedworker-classic\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url => requestViaSharedWorker(url),\n  },\n  \"sharedworker-module\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url => requestViaSharedWorker(url, {type: \"module\"}),\n  },\n  \"sharedworker-import\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: (url, additionalAttributes) =>\n        requestViaSharedWorker(workerUrlThatImports(url, additionalAttributes), {type: \"module\"}),\n  },\n  \"sharedworker-import-data\": {\n    path: \"/common/security-features/subresource/shared-worker.py\",\n    invoker: url =>\n        requestViaSharedWorker(workerDataUrlThatImports(url), {type: \"module\"}),\n  },\n\n  \"websocket\": {\n    path: \"/stash_responder\",\n    invoker: requestViaWebSocket,\n  },\n};\nfor (const workletType of ['animation', 'audio', 'layout', 'paint']) {\n  subresourceMap[`worklet-${workletType}`] = {\n      path: \"/common/security-features/subresource/worker.py\",\n      invoker: url => requestViaWorklet(workletType, url)\n    };\n  subresourceMap[`worklet-${workletType}-import-data`] = {\n      path: \"/common/security-features/subresource/worker.py\",\n      invoker: url =>\n          requestViaWorklet(workletType, workerDataUrlThatImports(url))\n    };\n}\n\n/**\n  @typedef RedirectionType\n  @type {string}\n\n  Represents what redirects should occur to the subresource request\n  after initial request.\n  See preprocess_redirection() in\n  /common/security-features/subresource/subresource.py for valid values.\n*/\n\n/**\n  Construct subresource (and related) origin.\n\n  @param {string} originType\n  @returns {object} the origin of the subresource.\n*/\nfunction getSubresourceOrigin(originType) {\n  const httpProtocol = \"http\";\n  const httpsProtocol = \"https\";\n  const wsProtocol = \"ws\";\n  const wssProtocol = \"wss\";\n\n  const sameOriginHost = \"web-platform.test\";\n  const crossOriginHost = \"www1.web-platform.test\";\n\n  // These values can evaluate to either empty strings or a \":port\" string.\n  const httpPort = getNormalizedPort(parseInt(\"8000\", 10));\n  const httpsRawPort = parseInt(\"8443\", 10);\n  const httpsPort = getNormalizedPort(httpsRawPort);\n  const wsPort = getNormalizedPort(parseInt(\"8888\", 10));\n  const wssRawPort = parseInt(\"8889\", 10);\n  const wssPort = getNormalizedPort(wssRawPort);\n\n  /**\n    @typedef OriginType\n    @type {string}\n\n    Represents the origin of the subresource request URL.\n    The keys of `originMap` below are the valid values.\n\n    Note that there can be redirects from the specified origin\n    (see RedirectionType), and thus the origin of the subresource\n    response URL might be different from what is specified by OriginType.\n  */\n  const originMap = {\n    \"same-https\": httpsProtocol + \"://\" + sameOriginHost + httpsPort,\n    \"same-http\": httpProtocol + \"://\" + sameOriginHost + httpPort,\n    \"cross-https\": httpsProtocol + \"://\" + crossOriginHost + httpsPort,\n    \"cross-http\": httpProtocol + \"://\" + crossOriginHost + httpPort,\n    \"same-wss\": wssProtocol + \"://\" + sameOriginHost + wssPort,\n    \"same-ws\": wsProtocol + \"://\" + sameOriginHost + wsPort,\n    \"cross-wss\": wssProtocol + \"://\" + crossOriginHost + wssPort,\n    \"cross-ws\": wsProtocol + \"://\" + crossOriginHost + wsPort,\n\n    // The following origin types are used for upgrade-insecure-requests tests:\n    // These rely on some unintuitive cleverness due to WPT's test setup:\n    // 'Upgrade-Insecure-Requests' does not upgrade the port number,\n    // so we use URLs in the form `http://[domain]:[https-port]`,\n    // which will be upgraded to `https://[domain]:[https-port]`.\n    // If the upgrade fails, the load will fail, as we don't serve HTTP over\n    // the secure port.\n    \"same-http-downgrade\":\n        httpProtocol + \"://\" + sameOriginHost + \":\" + httpsRawPort,\n    \"cross-http-downgrade\":\n        httpProtocol + \"://\" + crossOriginHost + \":\" + httpsRawPort,\n    \"same-ws-downgrade\":\n        wsProtocol + \"://\" + sameOriginHost + \":\" + wssRawPort,\n    \"cross-ws-downgrade\":\n        wsProtocol + \"://\" + crossOriginHost + \":\" + wssRawPort,\n  };\n\n  return originMap[originType];\n}\n\n/**\n  Construct subresource (and related) URLs.\n\n  @param {SubresourceType} subresourceType\n  @param {OriginType} originType\n  @param {RedirectionType} redirectionType\n  @returns {object} with following properties:\n    {string} testUrl\n      The subresource request URL.\n    {string} announceUrl\n    {string} assertUrl\n      The URLs to be used for detecting whether `testUrl` is actually sent\n      to the server.\n      1. Fetch `announceUrl` first,\n      2. then possibly fetch `testUrl`, and\n      3. finally fetch `assertUrl`.\n         The fetch result of `assertUrl` should indicate whether\n         `testUrl` is actually sent to the server or not.\n*/\nfunction getRequestURLs(subresourceType, originType, redirectionType) {\n  const key = guid();\n  const value = guid();\n\n  // We use the same stash path for both HTTP/S and WS/S stash requests.\n  const stashPath = encodeURIComponent(\"/mixed-content\");\n\n  const stashEndpoint = \"/common/security-features/subresource/xhr.py?key=\" +\n                        key + \"&path=\" + stashPath;\n  return {\n    testUrl:\n      getSubresourceOrigin(originType) +\n        subresourceMap[subresourceType].path +\n        \"?redirection=\" + encodeURIComponent(redirectionType) +\n        \"&action=purge&key=\" + key +\n        \"&path=\" + stashPath,\n    announceUrl: stashEndpoint + \"&action=put&value=\" + value,\n    assertUrl: stashEndpoint + \"&action=take\",\n  };\n}\n\n// ===============================================================\n// Source Context\n// ===============================================================\n// Requests can be sent from several source contexts,\n// such as the main documents, iframes, workers, or so,\n// possibly nested, and possibly with <meta>/http headers added.\n// invokeRequest() and invokeFrom*() functions handles\n// SourceContext-related setup in client-side.\n\n/**\n  invokeRequest() invokes a subresource request\n  (specified as `subresource`)\n  from a (possibly nested) environment settings object\n  (specified as `sourceContextList`).\n\n  For nested contexts, invokeRequest() calls an invokeFrom*() function\n  that creates a nested environment settings object using\n  /common/security-features/scope/, which calls invokeRequest()\n  again inside the nested environment settings object.\n  This cycle continues until all specified\n  nested environment settings object are created, and\n  finally invokeRequest() calls a requestVia*() function to start the\n  subresource request from the inner-most environment settings object.\n\n  @param {Subresource} subresource\n  @param {Array<SourceContext>} sourceContextList\n\n  @returns {Promise} A promise that is resolved with an RequestResult object.\n  `sourceContextUrl` is always set. For whether other properties are set,\n  see the comments for requestVia*() above.\n*/\nfunction invokeRequest(subresource, sourceContextList) {\n  if (sourceContextList.length === 0) {\n    // No further nested global objects. Send the subresource request here.\n\n    const additionalAttributes = {};\n    /** @type {PolicyDelivery} policyDelivery */\n    for (const policyDelivery of (subresource.policyDeliveries || [])) {\n      // Depending on the delivery method, extend the subresource element with\n      // these attributes.\n      if (policyDelivery.deliveryType === \"attr\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      } else if (policyDelivery.deliveryType === \"rel-noref\") {\n        additionalAttributes[\"rel\"] = \"noreferrer\";\n      } else if (policyDelivery.deliveryType === \"http-rp\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      } else if (policyDelivery.deliveryType === \"meta\") {\n        additionalAttributes[policyDelivery.key] = policyDelivery.value;\n      }\n    }\n\n    return subresourceMap[subresource.subresourceType].invoker(\n        subresource.url,\n        additionalAttributes)\n      .then(result => Object.assign(\n          {sourceContextUrl: location.toString()},\n          result));\n  }\n\n  // Defines invokers for each valid SourceContext.sourceContextType.\n  const sourceContextMap = {\n    \"srcdoc\": { // <iframe srcdoc></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"iframe\": { // <iframe src=\"same-origin-URL\"></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"iframe-blank\": { // <iframe></iframe>\n      invoker: invokeFromIframe,\n    },\n    \"worker-classic\": {\n      // Classic dedicated worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", false, {}),\n    },\n    \"worker-classic-data\": {\n      // Classic dedicated worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", true, {}),\n    },\n    \"worker-module\": {\n      // Module dedicated worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", false, {type: 'module'}),\n    },\n    \"worker-module-data\": {\n      // Module dedicated worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"worker\", true, {type: 'module'}),\n    },\n    \"sharedworker-classic\": {\n      // Classic shared worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", false, {}),\n    },\n    \"sharedworker-classic-data\": {\n      // Classic shared worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", true, {}),\n    },\n    \"sharedworker-module\": {\n      // Module shared worker loaded from same-origin.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", false, {type: 'module'}),\n    },\n    \"sharedworker-module-data\": {\n      // Module shared worker loaded from data: URL.\n      invoker: invokeFromWorker.bind(undefined, \"sharedworker\", true, {type: 'module'}),\n    },\n  };\n\n  return sourceContextMap[sourceContextList[0].sourceContextType].invoker(\n      subresource, sourceContextList);\n}\n\n// Quick hack to expose invokeRequest when common.sub.js is loaded either\n// as a classic or module script.\nself.invokeRequest = invokeRequest;\n\n/**\n  invokeFrom*() functions are helper functions with the same parameters\n  and return values as invokeRequest(), that are tied to specific types\n  of top-most environment settings objects.\n  For example, invokeFromIframe() is the helper function for the cases where\n  sourceContextList[0] is an iframe.\n*/\n\n/**\n  @param {string} workerType\n    \"worker\" (for dedicated worker) or \"sharedworker\".\n  @param {boolean} isDataUrl\n    true if the worker script is loaded from data: URL.\n    Otherwise, the script is loaded from same-origin.\n  @param {object} workerOptions\n    The `options` argument for Worker constructor.\n\n  Other parameters and return values are the same as those of invokeRequest().\n*/\nfunction invokeFromWorker(workerType, isDataUrl, workerOptions,\n                          subresource, sourceContextList) {\n  const currentSourceContext = sourceContextList[0];\n  let workerUrl =\n    \"/common/security-features/scope/worker.py?policyDeliveries=\" +\n    encodeURIComponent(JSON.stringify(\n        currentSourceContext.policyDeliveries || []));\n  if (workerOptions.type === 'module') {\n    workerUrl += \"&type=module\";\n  }\n\n  let promise;\n  if (isDataUrl) {\n    promise = fetch(workerUrl)\n      .then(r => r.text())\n      .then(source => {\n          return 'data:text/javascript;base64,' + btoa(source);\n        });\n  } else {\n    promise = Promise.resolve(workerUrl);\n  }\n\n  return promise\n    .then(url => {\n      if (workerType === \"worker\") {\n        const worker = new Worker(url, workerOptions);\n        worker.postMessage({subresource: subresource,\n                            sourceContextList: sourceContextList.slice(1)});\n        return bindEvents2(worker, \"message\", worker, \"error\", window, \"error\");\n      } else if (workerType === \"sharedworker\") {\n        const worker = new SharedWorker(url, workerOptions);\n        worker.port.start();\n        worker.port.postMessage({subresource: subresource,\n                                 sourceContextList: sourceContextList.slice(1)});\n        return bindEvents2(worker.port, \"message\", worker, \"error\", window, \"error\");\n      } else {\n        throw new Error('Invalid worker type: ' + workerType);\n      }\n    })\n    .then(event => {\n        if (event.data.error)\n          return Promise.reject(event.data.error);\n        return event.data;\n      });\n}\n\nfunction invokeFromIframe(subresource, sourceContextList) {\n  const currentSourceContext = sourceContextList[0];\n  const frameUrl =\n    \"/common/security-features/scope/document.py?policyDeliveries=\" +\n    encodeURIComponent(JSON.stringify(\n        currentSourceContext.policyDeliveries || []));\n\n  let iframe;\n  let promise;\n  if (currentSourceContext.sourceContextType === 'srcdoc') {\n    promise = fetch(frameUrl)\n      .then(r => r.text())\n      .then(srcdoc => {\n          iframe = createElement(\n              \"iframe\", {srcdoc: srcdoc}, document.body, true);\n          return iframe.eventPromise;\n        });\n  } else if (currentSourceContext.sourceContextType === 'iframe') {\n    iframe = createElement(\"iframe\", {src: frameUrl}, document.body, true);\n    promise = iframe.eventPromise;\n  } else if (currentSourceContext.sourceContextType === 'iframe-blank') {\n    let frameContent;\n    promise = fetch(frameUrl)\n      .then(r => r.text())\n      .then(t => {\n          frameContent = t;\n          iframe = createElement(\"iframe\", {}, document.body, true);\n          return iframe.eventPromise;\n        })\n      .then(() => {\n          // Reinitialize `iframe.eventPromise` with a new promise\n          // that catches the load event for the document.write() below.\n          bindEvents(iframe);\n\n          iframe.contentDocument.write(frameContent);\n          iframe.contentDocument.close();\n          return iframe.eventPromise;\n        });\n  }\n\n  return promise\n    .then(() => {\n        const promise = bindEvents2(\n            window, \"message\", iframe, \"error\", window, \"error\");\n        iframe.contentWindow.postMessage(\n            {subresource: subresource,\n             sourceContextList: sourceContextList.slice(1)},\n            \"*\");\n        return promise;\n      })\n    .then(event => {\n        if (event.data.error)\n          return Promise.reject(event.data.error);\n        return event.data;\n      });\n}\n\n// SanityChecker does nothing in release mode. See sanity-checker.js for debug\n// mode.\nfunction SanityChecker() {}\nSanityChecker.prototype.checkScenario = function() {};\nSanityChecker.prototype.setFailTimeout = function(test, timeout) {};\nSanityChecker.prototype.checkSubresourceResult = function() {};\n"},{"url":"http://web-platform.test:8888/stash_responder?redirection=no-redirect&action=purge&key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content","request_start":1696742124.4765775,"response_start":1696742124.4807663,"request_end":1696742124.4770842,"response_end":1696742124.4812918,"ts":1696742124.4815786,"body":""},{"url":"https://web-platform.test:8443/common/security-features/subresource/xhr.py?key=0312780e-6cd9-4c83-953e-00dc973e454a&path=%2Fmixed-content&action=take","request_start":1696742124.55216,"response_start":1696742124.5572817,"request_end":1696742124.5531754,"response_end":1696742124.5578573,"ts":1696742124.558086,"body":"{\"status\": \"allowed\", \"result\": null}"}]}}
