{"network":{"requests":{"2":{"requestId":"2","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"main_frame","timeStamp":1696773111427,"tabId":1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8000"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate"},{"name":"Connection","value":"keep-alive"},{"name":"Upgrade-Insecure-Requests","value":"1"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"3":{"requestId":"3","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"main_frame","timeStamp":1696773111807,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8000"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate"},{"name":"Connection","value":"keep-alive"},{"name":"Upgrade-Insecure-Requests","value":"1"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"4":{"requestId":"4","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/resources/testharness.js","origin":"http://web-platform.test:8000","pathname":"/resources/testharness.js","port":"8000","protocol":"http:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696773111864,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8000"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"5":{"requestId":"5","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/resources/testharnessreport.js","origin":"http://web-platform.test:8000","pathname":"/resources/testharnessreport.js","port":"8000","protocol":"http:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696773111865,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"web-platform.test:8000"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate"},{"name":"Connection","value":"keep-alive"},{"name":"Referer","value":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0},"6":{"requestId":"6","url":{"host":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","hostname":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","href":"http://b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it/download-trace","origin":"http://b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","pathname":"/download-trace","port":"","protocol":"http:","site":"mitm.it"},"originUrl":{"host":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2","hostname":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2","href":"moz-extension://ab8a1f15-c7ef-4bad-a9bb-678a834550b2/_generated_background_page.html","origin":"moz-extension://ab8a1f15-c7ef-4bad-a9bb-678a834550b2","pathname":"/_generated_background_page.html","port":"","protocol":"moz-extension:","site":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2"},"documentUrl":{"host":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2","hostname":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2","href":"moz-extension://ab8a1f15-c7ef-4bad-a9bb-678a834550b2/_generated_background_page.html","origin":"moz-extension://ab8a1f15-c7ef-4bad-a9bb-678a834550b2","pathname":"/_generated_background_page.html","port":"","protocol":"moz-extension:","site":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2"},"method":"GET","type":"xmlhttprequest","timeStamp":1696773113261,"tabId":-1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","requestHeaders":[{"name":"Host","value":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it"},{"name":"User-Agent","value":"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/118.0"},{"name":"Accept","value":"*/*"},{"name":"Accept-Language","value":"en-US,en;q=0.5"},{"name":"Accept-Encoding","value":"gzip, deflate"},{"name":"Connection","value":"keep-alive"}],"proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":null,"frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":0,"responseSize":0}},"responses":{"2":{"requestId":"2","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"main_frame","timeStamp":1696773111460,"tabId":1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/html"},{"name":"Cache-Control","value":"max-age=3600"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 13:51:51 GMT"},{"name":"Content-Length","value":"95"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":398,"responseSize":261},"3":{"requestId":"3","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"main_frame","timeStamp":1696773111827,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/html"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 13:51:51 GMT"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":443,"responseSize":1413},"4":{"requestId":"4","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/resources/testharness.js","origin":"http://web-platform.test:8000","pathname":"/resources/testharness.js","port":"8000","protocol":"http:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696773111915,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/javascript; charset=utf-8"},{"name":"Cache-Control","value":"max-age=3600"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 13:51:51 GMT"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":396,"responseSize":186910},"5":{"requestId":"5","url":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/resources/testharnessreport.js","origin":"http://web-platform.test:8000","pathname":"/resources/testharnessreport.js","port":"8000","protocol":"http:","site":"web-platform.test"},"originUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"documentUrl":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"method":"GET","type":"script","timeStamp":1696773111911,"tabId":2,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"text/javascript;charset=utf8"},{"name":"Cache-Control","value":"max-age=3600"},{"name":"Server","value":"BaseHTTP/0.6 Python/3.8.10"},{"name":"Date","value":"Sun, 08 Oct 2023 13:51:51 GMT"},{"name":"Content-Length","value":"2385"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":402,"responseSize":2572},"6":{"requestId":"6","url":{"host":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","hostname":"b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","href":"http://b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it/download-trace","origin":"http://b1v253vpqwutupjwntfmpc9a4m94s5zm.mitm.it","pathname":"/download-trace","port":"","protocol":"http:","site":"mitm.it"},"originUrl":{"host":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2","hostname":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2","href":"moz-extension://ab8a1f15-c7ef-4bad-a9bb-678a834550b2/_generated_background_page.html","origin":"moz-extension://ab8a1f15-c7ef-4bad-a9bb-678a834550b2","pathname":"/_generated_background_page.html","port":"","protocol":"moz-extension:","site":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2"},"documentUrl":{"host":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2","hostname":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2","href":"moz-extension://ab8a1f15-c7ef-4bad-a9bb-678a834550b2/_generated_background_page.html","origin":"moz-extension://ab8a1f15-c7ef-4bad-a9bb-678a834550b2","pathname":"/_generated_background_page.html","port":"","protocol":"moz-extension:","site":"ab8a1f15-c7ef-4bad-a9bb-678a834550b2"},"method":"GET","type":"xmlhttprequest","timeStamp":1696773113265,"tabId":-1,"frameId":0,"parentFrameId":-1,"incognito":false,"thirdParty":false,"cookieStoreId":"firefox-default","fromCache":false,"responseHeaders":[{"name":"Content-Type","value":"application/json"},{"name":"Access-Control-Allow-Origin","value":"*"},{"name":"content-length","value":"255858"}],"statusCode":200,"statusLine":"HTTP/1.1 200 OK","proxyInfo":{"connectionIsolationKey":"","failoverTimeout":1800,"host":"127.0.0.1","port":65480,"proxyAuthorizationHeader":"","proxyDNS":false,"type":"http","username":""},"ip":"127.0.0.1","frameAncestors":[],"urlClassification":{"firstParty":[],"thirdParty":[]},"requestSize":313,"responseSize":255965}},"redirects":{}},"events":[{"isSecure":false,"wid":"a2d8c2cf-1c14-430e-9716-942f7f9fbf9b","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/testharness_runner.html","origin":"http://web-platform.test:8000","pathname":"/testharness_runner.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"WindowOpen","args":["about:blank","e9291017-1365-4dbc-8fe1-d97a4b7b43bd","noopener"],"ret":null,"timeStamp":1696773111698},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"","timeStamp":1696773111944},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieSet","args":[""],"ret":null,"timeStamp":1696773111966},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"","timeStamp":1696773111986},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"","timeStamp":1696773112007},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieSet","args":["a=b"],"ret":null,"timeStamp":1696773112028},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"a=b","timeStamp":1696773112048},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"a=b","timeStamp":1696773112069},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"a=b","timeStamp":1696773112089},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieSet","args":["a=; expires=Thu, 01 Jan 1970 00:00:00 UTC"],"ret":null,"timeStamp":1696773112109},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"","timeStamp":1696773112129},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieSet","args":["b=A\u0000Z"],"ret":null,"timeStamp":1696773112150},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"b=A","timeStamp":1696773112170},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"b=A","timeStamp":1696773112190},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"b=A","timeStamp":1696773112210},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieSet","args":["b=; expires=Thu, 01 Jan 1970 00:00:00 UTC"],"ret":null,"timeStamp":1696773112230},{"isSecure":false,"wid":"81c4a380-22a8-41b2-8950-6e61bf8573db","orig":{"host":"web-platform.test:8000","hostname":"web-platform.test","href":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","origin":"http://web-platform.test:8000","pathname":"/html/dom/documents/resource-metadata-management/document-cookie.html","port":"8000","protocol":"http:","site":"web-platform.test"},"type":"DocumentCookieGet","args":[],"ret":"","timeStamp":1696773112250}],"cookies":{"1696773111967":[{"removed":false,"cookie":{"name":"","value":"","domain":"web-platform.test","hostOnly":true,"path":"/html/dom/documents/resource-metadata-management","secure":false,"httpOnly":false,"sameSite":"no_restriction","session":true,"firstPartyDomain":"","partitionKey":null,"storeId":"firefox-default"}}],"1696773112030":[{"removed":false,"cookie":{"name":"a","value":"b","domain":"web-platform.test","hostOnly":true,"path":"/html/dom/documents/resource-metadata-management","secure":false,"httpOnly":false,"sameSite":"no_restriction","session":true,"firstPartyDomain":"","partitionKey":null,"storeId":"firefox-default"}}],"1696773112115":[{"removed":true,"cookie":{"name":"a","value":"b","domain":"web-platform.test","hostOnly":true,"path":"/html/dom/documents/resource-metadata-management","secure":false,"httpOnly":false,"sameSite":"no_restriction","session":true,"firstPartyDomain":"","partitionKey":null,"storeId":"firefox-default"}}],"1696773112151":[{"removed":false,"cookie":{"name":"b","value":"A","domain":"web-platform.test","hostOnly":true,"path":"/html/dom/documents/resource-metadata-management","secure":false,"httpOnly":false,"sameSite":"no_restriction","session":true,"firstPartyDomain":"","partitionKey":null,"storeId":"firefox-default"}}],"1696773112232":[{"removed":true,"cookie":{"name":"b","value":"A","domain":"web-platform.test","hostOnly":true,"path":"/html/dom/documents/resource-metadata-management","secure":false,"httpOnly":false,"sameSite":"no_restriction","session":true,"firstPartyDomain":"","partitionKey":null,"storeId":"firefox-default"}}]},"tests":{"document has no cookie":{"start":1696773111923,"end":1696773111945},"document.cookie":{"start":1696773111946,"end":1696773112008},"document.cookie 1":{"start":1696773112008,"end":1696773112130},"document.cookie 2":{"start":1696773112130,"end":1696773112251},"getting cookie for a cookie-averse document returns empty string, setting does nothing":{"start":1696773112252,"end":1696773112253}},"proxy":{"requests":[{"url":"http://web-platform.test:8000/testharness_runner.html","request_start":1696773111.432142,"request_end":1696773111.4328103,"ts":1696773111.433047,"body":""},{"url":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","request_start":1696773111.8140385,"request_end":1696773111.8148673,"ts":1696773111.8151386,"body":""},{"url":"http://web-platform.test:8000/resources/testharness.js","request_start":1696773111.8728943,"request_end":1696773111.8739297,"ts":1696773111.8743663,"body":""},{"url":"http://web-platform.test:8000/resources/testharnessreport.js","request_start":1696773111.873481,"request_end":1696773111.8741693,"ts":1696773111.8749895,"body":""}],"responses":[{"url":"http://web-platform.test:8000/testharness_runner.html","request_start":1696773111.432142,"response_start":1696773111.436521,"request_end":1696773111.4328103,"response_end":1696773111.4371119,"ts":1696773111.4372656,"body":"<!doctype html>\n<title></title>\n<script>\nvar timeout_multiplier = 1;\nvar win = null;\n</script>\n"},{"url":"http://web-platform.test:8000/html/dom/documents/resource-metadata-management/document-cookie.html","request_start":1696773111.8140385,"response_start":1696773111.81695,"request_end":1696773111.8148673,"response_end":1696773111.8175762,"ts":1696773111.817797,"body":"<!DOCTYPE html>\n<meta charset=utf-8>\n<title>document.cookie</title>\n<link rel=\"author\" title=\"Denis Ah-Kang\" href=\"mailto:denis@w3.org\">\n<link rel=help href=\"https://html.spec.whatwg.org/multipage/#resource-metadata-management\">\n<script src=\"/resources/testharness.js\"></script>\n<script src=\"/resources/testharnessreport.js\"></script>\n<div id=\"log\"></div>\n<script>\n\nconst TEST_CASES = [\n  {value: \"\", expected: \"\", test: \"Empty value\"},\n  {value: \"a=b\", expected: \"a=b\", test: \"A simple cookie\"},\n  {value: \"b=A\\0Z\", expected: \"\", test: \"A null char\"},\n];\n\ntest(function(){\n  assert_equals(document.cookie, \"\");\n}, \"document has no cookie\");\n\nfor (const i in TEST_CASES) {\n  const t = TEST_CASES[i];\n  test(() => {\n    document.cookie = t.value;\n    assert_equals(document.cookie, t.expected);\n\n    // Cleanup\n    if (document.cookie.includes(\"=\")) {\n      document.cookie = document.cookie.split(\"=\")[0] + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n      assert_equals(document.cookie, \"\");\n    }\n  }, t.name);\n}\n\ntest(function(){\n  var doc = document.implementation.createHTMLDocument(\"doc\");\n  assert_equals(doc.cookie, \"\");\n  doc.cookie = \"test=foobar\";\n  assert_equals(doc.cookie, \"\");\n}, \"getting cookie for a cookie-averse document returns empty string, setting does nothing\");\n</script>\n"},{"url":"http://web-platform.test:8000/resources/testharnessreport.js","request_start":1696773111.873481,"response_start":1696773111.8840094,"request_end":1696773111.8741693,"response_end":1696773111.8846202,"ts":1696773111.8848236,"body":"class MessageQueue {\n  constructor() {\n    this.item_id = 0;\n    this._queue = [];\n  }\n\n  push(item) {\n    let cmd_id = this.item_id++;\n    item.id = cmd_id;\n    this._queue.push(item);\n    __wptrunner_process_next_event();\n    return cmd_id;\n  }\n\n  shift() {\n    return this._queue.shift();\n  }\n}\n\nwindow.__wptrunner_testdriver_callback = null;\nwindow.__wptrunner_message_queue = new MessageQueue();\nwindow.__wptrunner_url = null;\n\nwindow.__wptrunner_process_next_event = function() {\n  /* This function handles the next testdriver event. The presence of\n     window.testdriver_callback is used as a switch; when that function\n     is present we are able to handle the next event and when is is not\n     present we must wait. Therefore to drive the event processing, this\n     function must be called in two circumstances:\n       * Every time there is a new event that we may be able to handle\n       * Every time we set the callback function\n     This function unsets the callback, so no further testdriver actions\n     will be run until it is reset, which wptrunner does after it has\n     completed handling the current action.\n   */\n\n  if (!window.__wptrunner_testdriver_callback) {\n    return;\n  }\n  var data = window.__wptrunner_message_queue.shift();\n  if (!data) {\n    return;\n  }\n\n  var payload = undefined;\n\n  switch(data.type) {\n  case \"complete\":\n    var tests = data.tests;\n    var status = data.status;\n\n    var subtest_results = tests.map(function(x) {\n      return [x.name, x.status, x.message, x.stack];\n    });\n    payload = [status.status,\n               status.message,\n               status.stack,\n               subtest_results];\n    clearTimeout(window.__wptrunner_timer);\n    break;\n  case \"action\":\n    payload = data;\n    break;\n  default:\n    return;\n  }\n  var callback = window.__wptrunner_testdriver_callback;\n  window.__wptrunner_testdriver_callback = null;\n  callback([__wptrunner_url, data.type, payload]);\n};\n\n(function() {\n  var props = {output: 1,\n               timeout_multiplier: 1,\n               explicit_timeout: false,\n               debug: false,\n               message_events: [\"completion\"]};\n\n  add_completion_callback(function(tests, harness_status) {\n    __wptrunner_message_queue.push({\n      \"type\": \"complete\",\n      \"tests\": tests,\n      \"status\": harness_status});\n    __wptrunner_process_next_event();\n  });\n  setup(props);\n})();\n\n"},{"url":"http://web-platform.test:8000/resources/testharness.js","request_start":1696773111.8728943,"response_start":1696773111.8856068,"request_end":1696773111.8739297,"response_end":1696773111.8865247,"ts":1696773111.8866994,"body":"/*global self*/\n/*jshint latedef: nofunc*/\n\n/* Documentation: https://web-platform-tests.org/writing-tests/testharness-api.html\n * (../docs/_writing-tests/testharness-api.md) */\n\n(function (global_scope)\n{\n    // default timeout is 10 seconds, test can override if needed\n    var settings = {\n        output:true,\n        harness_timeout:{\n            \"normal\":10000,\n            \"long\":60000\n        },\n        test_timeout:null,\n        message_events: [\"start\", \"test_state\", \"result\", \"completion\"],\n        debug: false,\n    };\n\n    var xhtml_ns = \"http://www.w3.org/1999/xhtml\";\n\n    /*\n     * TestEnvironment is an abstraction for the environment in which the test\n     * harness is used. Each implementation of a test environment has to provide\n     * the following interface:\n     *\n     * interface TestEnvironment {\n     *   // Invoked after the global 'tests' object has been created and it's\n     *   // safe to call add_*_callback() to register event handlers.\n     *   void on_tests_ready();\n     *\n     *   // Invoked after setup() has been called to notify the test environment\n     *   // of changes to the test harness properties.\n     *   void on_new_harness_properties(object properties);\n     *\n     *   // Should return a new unique default test name.\n     *   DOMString next_default_test_name();\n     *\n     *   // Should return the test harness timeout duration in milliseconds.\n     *   float test_timeout();\n     * };\n     */\n\n    /*\n     * A test environment with a DOM. The global object is 'window'. By default\n     * test results are displayed in a table. Any parent windows receive\n     * callbacks or messages via postMessage() when test events occur. See\n     * apisample11.html and apisample12.html.\n     */\n    function WindowTestEnvironment() {\n        this.name_counter = 0;\n        this.window_cache = null;\n        this.output_handler = null;\n        this.all_loaded = false;\n        var this_obj = this;\n        this.message_events = [];\n        this.dispatched_messages = [];\n\n        this.message_functions = {\n            start: [add_start_callback, remove_start_callback,\n                    function (properties) {\n                        this_obj._dispatch(\"start_callback\", [properties],\n                                           {type: \"start\", properties: properties});\n                    }],\n\n            test_state: [add_test_state_callback, remove_test_state_callback,\n                         function(test) {\n                             this_obj._dispatch(\"test_state_callback\", [test],\n                                                {type: \"test_state\",\n                                                 test: test.structured_clone()});\n                         }],\n            result: [add_result_callback, remove_result_callback,\n                     function (test) {\n                         this_obj.output_handler.show_status();\n                         this_obj._dispatch(\"result_callback\", [test],\n                                            {type: \"result\",\n                                             test: test.structured_clone()});\n                     }],\n            completion: [add_completion_callback, remove_completion_callback,\n                         function (tests, harness_status, asserts) {\n                             var cloned_tests = map(tests, function(test) {\n                                 return test.structured_clone();\n                             });\n                             this_obj._dispatch(\"completion_callback\", [tests, harness_status],\n                                                {type: \"complete\",\n                                                 tests: cloned_tests,\n                                                 status: harness_status.structured_clone(),\n                                                 asserts: asserts.map(assert => assert.structured_clone())});\n                         }]\n        }\n\n        on_event(window, 'load', function() {\n            this_obj.all_loaded = true;\n        });\n\n        on_event(window, 'message', function(event) {\n            if (event.data && event.data.type === \"getmessages\" && event.source) {\n                // A window can post \"getmessages\" to receive a duplicate of every\n                // message posted by this environment so far. This allows subscribers\n                // from fetch_tests_from_window to 'catch up' to the current state of\n                // this environment.\n                for (var i = 0; i < this_obj.dispatched_messages.length; ++i)\n                {\n                    event.source.postMessage(this_obj.dispatched_messages[i], \"*\");\n                }\n            }\n        });\n    }\n\n    WindowTestEnvironment.prototype._dispatch = function(selector, callback_args, message_arg) {\n        this.dispatched_messages.push(message_arg);\n        this._forEach_windows(\n                function(w, same_origin) {\n                    if (same_origin) {\n                        try {\n                            var has_selector = selector in w;\n                        } catch(e) {\n                            // If document.domain was set at some point same_origin can be\n                            // wrong and the above will fail.\n                            has_selector = false;\n                        }\n                        if (has_selector) {\n                            try {\n                                w[selector].apply(undefined, callback_args);\n                            } catch (e) {}\n                        }\n                    }\n                    if (w !== self) {\n                        w.postMessage(message_arg, \"*\");\n                    }\n                });\n    };\n\n    WindowTestEnvironment.prototype._forEach_windows = function(callback) {\n        // Iterate over the windows [self ... top, opener]. The callback is passed\n        // two objects, the first one is the window object itself, the second one\n        // is a boolean indicating whether or not it's on the same origin as the\n        // current window.\n        var cache = this.window_cache;\n        if (!cache) {\n            cache = [[self, true]];\n            var w = self;\n            var i = 0;\n            var so;\n            while (w != w.parent) {\n                w = w.parent;\n                so = is_same_origin(w);\n                cache.push([w, so]);\n                i++;\n            }\n            w = window.opener;\n            if (w) {\n                cache.push([w, is_same_origin(w)]);\n            }\n            this.window_cache = cache;\n        }\n\n        forEach(cache,\n                function(a) {\n                    callback.apply(null, a);\n                });\n    };\n\n    WindowTestEnvironment.prototype.on_tests_ready = function() {\n        var output = new Output();\n        this.output_handler = output;\n\n        var this_obj = this;\n\n        add_start_callback(function (properties) {\n            this_obj.output_handler.init(properties);\n        });\n\n        add_test_state_callback(function(test) {\n            this_obj.output_handler.show_status();\n        });\n\n        add_result_callback(function (test) {\n            this_obj.output_handler.show_status();\n        });\n\n        add_completion_callback(function (tests, harness_status, asserts_run) {\n            this_obj.output_handler.show_results(tests, harness_status, asserts_run);\n        });\n        this.setup_messages(settings.message_events);\n    };\n\n    WindowTestEnvironment.prototype.setup_messages = function(new_events) {\n        var this_obj = this;\n        forEach(settings.message_events, function(x) {\n            var current_dispatch = this_obj.message_events.indexOf(x) !== -1;\n            var new_dispatch = new_events.indexOf(x) !== -1;\n            if (!current_dispatch && new_dispatch) {\n                this_obj.message_functions[x][0](this_obj.message_functions[x][2]);\n            } else if (current_dispatch && !new_dispatch) {\n                this_obj.message_functions[x][1](this_obj.message_functions[x][2]);\n            }\n        });\n        this.message_events = new_events;\n    }\n\n    WindowTestEnvironment.prototype.next_default_test_name = function() {\n        var suffix = this.name_counter > 0 ? \" \" + this.name_counter : \"\";\n        this.name_counter++;\n        return get_title() + suffix;\n    };\n\n    WindowTestEnvironment.prototype.on_new_harness_properties = function(properties) {\n        this.output_handler.setup(properties);\n        if (properties.hasOwnProperty(\"message_events\")) {\n            this.setup_messages(properties.message_events);\n        }\n    };\n\n    WindowTestEnvironment.prototype.add_on_loaded_callback = function(callback) {\n        on_event(window, 'load', callback);\n    };\n\n    WindowTestEnvironment.prototype.test_timeout = function() {\n        var metas = document.getElementsByTagName(\"meta\");\n        for (var i = 0; i < metas.length; i++) {\n            if (metas[i].name == \"timeout\") {\n                if (metas[i].content == \"long\") {\n                    return settings.harness_timeout.long;\n                }\n                break;\n            }\n        }\n        return settings.harness_timeout.normal;\n    };\n\n    /*\n     * Base TestEnvironment implementation for a generic web worker.\n     *\n     * Workers accumulate test results. One or more clients can connect and\n     * retrieve results from a worker at any time.\n     *\n     * WorkerTestEnvironment supports communicating with a client via a\n     * MessagePort.  The mechanism for determining the appropriate MessagePort\n     * for communicating with a client depends on the type of worker and is\n     * implemented by the various specializations of WorkerTestEnvironment\n     * below.\n     *\n     * A client document using testharness can use fetch_tests_from_worker() to\n     * retrieve results from a worker. See apisample16.html.\n     */\n    function WorkerTestEnvironment() {\n        this.name_counter = 0;\n        this.all_loaded = true;\n        this.message_list = [];\n        this.message_ports = [];\n    }\n\n    WorkerTestEnvironment.prototype._dispatch = function(message) {\n        this.message_list.push(message);\n        for (var i = 0; i < this.message_ports.length; ++i)\n        {\n            this.message_ports[i].postMessage(message);\n        }\n    };\n\n    // The only requirement is that port has a postMessage() method. It doesn't\n    // have to be an instance of a MessagePort, and often isn't.\n    WorkerTestEnvironment.prototype._add_message_port = function(port) {\n        this.message_ports.push(port);\n        for (var i = 0; i < this.message_list.length; ++i)\n        {\n            port.postMessage(this.message_list[i]);\n        }\n    };\n\n    WorkerTestEnvironment.prototype.next_default_test_name = function() {\n        var suffix = this.name_counter > 0 ? \" \" + this.name_counter : \"\";\n        this.name_counter++;\n        return get_title() + suffix;\n    };\n\n    WorkerTestEnvironment.prototype.on_new_harness_properties = function() {};\n\n    WorkerTestEnvironment.prototype.on_tests_ready = function() {\n        var this_obj = this;\n        add_start_callback(\n                function(properties) {\n                    this_obj._dispatch({\n                        type: \"start\",\n                        properties: properties,\n                    });\n                });\n        add_test_state_callback(\n                function(test) {\n                    this_obj._dispatch({\n                        type: \"test_state\",\n                        test: test.structured_clone()\n                    });\n                });\n        add_result_callback(\n                function(test) {\n                    this_obj._dispatch({\n                        type: \"result\",\n                        test: test.structured_clone()\n                    });\n                });\n        add_completion_callback(\n                function(tests, harness_status, asserts) {\n                    this_obj._dispatch({\n                        type: \"complete\",\n                        tests: map(tests,\n                            function(test) {\n                                return test.structured_clone();\n                            }),\n                        status: harness_status.structured_clone(),\n                        asserts: asserts.map(assert => assert.structured_clone()),\n                    });\n                });\n    };\n\n    WorkerTestEnvironment.prototype.add_on_loaded_callback = function() {};\n\n    WorkerTestEnvironment.prototype.test_timeout = function() {\n        // Tests running in a worker don't have a default timeout. I.e. all\n        // worker tests behave as if settings.explicit_timeout is true.\n        return null;\n    };\n\n    /*\n     * Dedicated web workers.\n     * https://html.spec.whatwg.org/multipage/workers.html#dedicatedworkerglobalscope\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a dedicated worker.\n     */\n    function DedicatedWorkerTestEnvironment() {\n        WorkerTestEnvironment.call(this);\n        // self is an instance of DedicatedWorkerGlobalScope which exposes\n        // a postMessage() method for communicating via the message channel\n        // established when the worker is created.\n        this._add_message_port(self);\n    }\n    DedicatedWorkerTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);\n\n    DedicatedWorkerTestEnvironment.prototype.on_tests_ready = function() {\n        WorkerTestEnvironment.prototype.on_tests_ready.call(this);\n        // In the absence of an onload notification, we a require dedicated\n        // workers to explicitly signal when the tests are done.\n        tests.wait_for_finish = true;\n    };\n\n    /*\n     * Shared web workers.\n     * https://html.spec.whatwg.org/multipage/workers.html#sharedworkerglobalscope\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a shared web worker.\n     */\n    function SharedWorkerTestEnvironment() {\n        WorkerTestEnvironment.call(this);\n        var this_obj = this;\n        // Shared workers receive message ports via the 'onconnect' event for\n        // each connection.\n        self.addEventListener(\"connect\",\n                function(message_event) {\n                    this_obj._add_message_port(message_event.source);\n                }, false);\n    }\n    SharedWorkerTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);\n\n    SharedWorkerTestEnvironment.prototype.on_tests_ready = function() {\n        WorkerTestEnvironment.prototype.on_tests_ready.call(this);\n        // In the absence of an onload notification, we a require shared\n        // workers to explicitly signal when the tests are done.\n        tests.wait_for_finish = true;\n    };\n\n    /*\n     * Service workers.\n     * http://www.w3.org/TR/service-workers/\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a service worker.\n     */\n    function ServiceWorkerTestEnvironment() {\n        WorkerTestEnvironment.call(this);\n        this.all_loaded = false;\n        this.on_loaded_callback = null;\n        var this_obj = this;\n        self.addEventListener(\"message\",\n                function(event) {\n                    if (event.data && event.data.type && event.data.type === \"connect\") {\n                        this_obj._add_message_port(event.source);\n                    }\n                }, false);\n\n        // The oninstall event is received after the service worker script and\n        // all imported scripts have been fetched and executed. It's the\n        // equivalent of an onload event for a document. All tests should have\n        // been added by the time this event is received, thus it's not\n        // necessary to wait until the onactivate event. However, tests for\n        // installed service workers need another event which is equivalent to\n        // the onload event because oninstall is fired only on installation. The\n        // onmessage event is used for that purpose since tests using\n        // testharness.js should ask the result to its service worker by\n        // PostMessage. If the onmessage event is triggered on the service\n        // worker's context, that means the worker's script has been evaluated.\n        on_event(self, \"install\", on_all_loaded);\n        on_event(self, \"message\", on_all_loaded);\n        function on_all_loaded() {\n            if (this_obj.all_loaded)\n                return;\n            this_obj.all_loaded = true;\n            if (this_obj.on_loaded_callback) {\n              this_obj.on_loaded_callback();\n            }\n        }\n    }\n\n    ServiceWorkerTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);\n\n    ServiceWorkerTestEnvironment.prototype.add_on_loaded_callback = function(callback) {\n        if (this.all_loaded) {\n            callback();\n        } else {\n            this.on_loaded_callback = callback;\n        }\n    };\n\n    /*\n     * Shadow realms.\n     * https://github.com/tc39/proposal-shadowrealm\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a shadow realm.\n     */\n    function ShadowRealmTestEnvironment() {\n        WorkerTestEnvironment.call(this);\n        this.all_loaded = false;\n        this.on_loaded_callback = null;\n    }\n\n    ShadowRealmTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);\n\n    /**\n     * Signal to the test environment that the tests are ready and the on-loaded\n     * callback should be run.\n     *\n     * Shadow realms are not *really* a DOM context: they have no `onload` or similar\n     * event for us to use to set up the test environment; so, instead, this method\n     * is manually triggered from the incubating realm\n     *\n     * @param {Function} message_destination - a function that receives JSON-serializable\n     * data to send to the incubating realm, in the same format as used by RemoteContext\n     */\n    ShadowRealmTestEnvironment.prototype.begin = function(message_destination) {\n        if (this.all_loaded) {\n            throw new Error(\"Tried to start a shadow realm test environment after it has already started\");\n        }\n        var fakeMessagePort = {};\n        fakeMessagePort.postMessage = message_destination;\n        this._add_message_port(fakeMessagePort);\n        this.all_loaded = true;\n        if (this.on_loaded_callback) {\n            this.on_loaded_callback();\n        }\n    };\n\n    ShadowRealmTestEnvironment.prototype.add_on_loaded_callback = function(callback) {\n        if (this.all_loaded) {\n            callback();\n        } else {\n            this.on_loaded_callback = callback;\n        }\n    };\n\n    /*\n     * JavaScript shells.\n     *\n     * This class is used as the test_environment when testharness is running\n     * inside a JavaScript shell.\n     */\n    function ShellTestEnvironment() {\n        this.name_counter = 0;\n        this.all_loaded = false;\n        this.on_loaded_callback = null;\n        Promise.resolve().then(function() {\n            this.all_loaded = true\n            if (this.on_loaded_callback) {\n                this.on_loaded_callback();\n            }\n        }.bind(this));\n        this.message_list = [];\n        this.message_ports = [];\n    }\n\n    ShellTestEnvironment.prototype.next_default_test_name = function() {\n        var suffix = this.name_counter > 0 ? \" \" + this.name_counter : \"\";\n        this.name_counter++;\n        return get_title() + suffix;\n    };\n\n    ShellTestEnvironment.prototype.on_new_harness_properties = function() {};\n\n    ShellTestEnvironment.prototype.on_tests_ready = function() {};\n\n    ShellTestEnvironment.prototype.add_on_loaded_callback = function(callback) {\n        if (this.all_loaded) {\n            callback();\n        } else {\n            this.on_loaded_callback = callback;\n        }\n    };\n\n    ShellTestEnvironment.prototype.test_timeout = function() {\n        // Tests running in a shell don't have a default timeout, so behave as\n        // if settings.explicit_timeout is true.\n        return null;\n    };\n\n    function create_test_environment() {\n        if ('document' in global_scope) {\n            return new WindowTestEnvironment();\n        }\n        if ('DedicatedWorkerGlobalScope' in global_scope &&\n            global_scope instanceof DedicatedWorkerGlobalScope) {\n            return new DedicatedWorkerTestEnvironment();\n        }\n        if ('SharedWorkerGlobalScope' in global_scope &&\n            global_scope instanceof SharedWorkerGlobalScope) {\n            return new SharedWorkerTestEnvironment();\n        }\n        if ('ServiceWorkerGlobalScope' in global_scope &&\n            global_scope instanceof ServiceWorkerGlobalScope) {\n            return new ServiceWorkerTestEnvironment();\n        }\n        if ('WorkerGlobalScope' in global_scope &&\n            global_scope instanceof WorkerGlobalScope) {\n            return new DedicatedWorkerTestEnvironment();\n        }\n        /* Shadow realm global objects are _ordinary_ objects (i.e. their prototype is\n         * Object) so we don't have a nice `instanceof` test to use; instead, we\n         * check if the there is a GLOBAL.isShadowRealm() property\n         * on the global object. that was set by the test harness when it\n         * created the ShadowRealm.\n         */\n        if (global_scope.GLOBAL && global_scope.GLOBAL.isShadowRealm()) {\n            return new ShadowRealmTestEnvironment();\n        }\n\n        return new ShellTestEnvironment();\n    }\n\n    var test_environment = create_test_environment();\n\n    function is_shared_worker(worker) {\n        return 'SharedWorker' in global_scope && worker instanceof SharedWorker;\n    }\n\n    function is_service_worker(worker) {\n        // The worker object may be from another execution context,\n        // so do not use instanceof here.\n        return 'ServiceWorker' in global_scope &&\n            Object.prototype.toString.call(worker) == '[object ServiceWorker]';\n    }\n\n    var seen_func_name = Object.create(null);\n\n    function get_test_name(func, name)\n    {\n        if (name) {\n            return name;\n        }\n\n        if (func) {\n            var func_code = func.toString();\n\n            // Try and match with brackets, but fallback to matching without\n            var arrow = func_code.match(/^\\(\\)\\s*=>\\s*(?:{(.*)}\\s*|(.*))$/);\n\n            // Check for JS line separators\n            if (arrow !== null && !/[\\u000A\\u000D\\u2028\\u2029]/.test(func_code)) {\n                var trimmed = (arrow[1] !== undefined ? arrow[1] : arrow[2]).trim();\n                // drop trailing ; if there's no earlier ones\n                trimmed = trimmed.replace(/^([^;]*)(;\\s*)+$/, \"$1\");\n\n                if (trimmed) {\n                    let name = trimmed;\n                    if (seen_func_name[trimmed]) {\n                        // This subtest name already exists, so add a suffix.\n                        name += \" \" + seen_func_name[trimmed];\n                    } else {\n                        seen_func_name[trimmed] = 0;\n                    }\n                    seen_func_name[trimmed] += 1;\n                    return name;\n                }\n            }\n        }\n\n        return test_environment.next_default_test_name();\n    }\n\n    /**\n     * @callback TestFunction\n     * @param {Test} test - The test currnetly being run.\n     * @param {Any[]} args - Additional args to pass to function.\n     *\n     */\n\n    /**\n     * Create a synchronous test\n     *\n     * @param {TestFunction} func - Test function. This is executed\n     * immediately. If it returns without error, the test status is\n     * set to ``PASS``. If it throws an :js:class:`AssertionError`, or\n     * any other exception, the test status is set to ``FAIL``\n     * (typically from an `assert` function).\n     * @param {String} name - Test name. This must be unique in a\n     * given file and must be invariant between runs.\n     */\n    function test(func, name, properties)\n    {\n        if (tests.promise_setup_called) {\n            tests.status.status = tests.status.ERROR;\n            tests.status.message = '`test` invoked after `promise_setup`';\n            tests.complete();\n        }\n        var test_name = get_test_name(func, name);\n        var test_obj = new Test(test_name, properties);\n        var value = test_obj.step(func, test_obj, test_obj);\n\n        if (value !== undefined) {\n            var msg = 'Test named \"' + test_name +\n                '\" passed a function to `test` that returned a value.';\n\n            try {\n                if (value && typeof value.then === 'function') {\n                    msg += ' Consider using `promise_test` instead when ' +\n                        'using Promises or async/await.';\n                }\n            } catch (err) {}\n\n            tests.status.status = tests.status.ERROR;\n            tests.status.message = msg;\n        }\n\n        if (test_obj.phase === test_obj.phases.STARTED) {\n            test_obj.done();\n        }\n    }\n\n    /**\n     * Create an asynchronous test\n     *\n     * @param {TestFunction|string} funcOrName - Initial step function\n     * to call immediately with the test name as an argument (if any),\n     * or name of the test.\n     * @param {String} name - Test name (if a test function was\n     * provided). This must be unique in a given file and must be\n     * invariant between runs.\n     * @returns {Test} An object representing the ongoing test.\n     */\n    function async_test(func, name, properties)\n    {\n        if (tests.promise_setup_called) {\n            tests.status.status = tests.status.ERROR;\n            tests.status.message = '`async_test` invoked after `promise_setup`';\n            tests.complete();\n        }\n        if (typeof func !== \"function\") {\n            properties = name;\n            name = func;\n            func = null;\n        }\n        var test_name = get_test_name(func, name);\n        var test_obj = new Test(test_name, properties);\n        if (func) {\n            var value = test_obj.step(func, test_obj, test_obj);\n\n            // Test authors sometimes return values to async_test, expecting us\n            // to handle the value somehow. Make doing so a harness error to be\n            // clear this is invalid, and point authors to promise_test if it\n            // may be appropriate.\n            //\n            // Note that we only perform this check on the initial function\n            // passed to async_test, not on any later steps - we haven't seen a\n            // consistent problem with those (and it's harder to check).\n            if (value !== undefined) {\n                var msg = 'Test named \"' + test_name +\n                    '\" passed a function to `async_test` that returned a value.';\n\n                try {\n                    if (value && typeof value.then === 'function') {\n                        msg += ' Consider using `promise_test` instead when ' +\n                            'using Promises or async/await.';\n                    }\n                } catch (err) {}\n\n                tests.set_status(tests.status.ERROR, msg);\n                tests.complete();\n            }\n        } else {\n            // In his case, the test might not be stepped at all, and it even if it is, only the first START event counts for each test\n            window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"START\", content: {'isSecure': window.isSecureContext, 'wid': window.__id__, 'name': test_name}, ts: Date.now()}}))\n        }\n        return test_obj;\n    }\n\n    /**\n     * Create a promise test.\n     *\n     * Promise tests are tests which are represented by a promise\n     * object. If the promise is fulfilled the test passes, if it's\n     * rejected the test fails, otherwise the test passes.\n     *\n     * @param {TestFunction} func - Test function. This must return a\n     * promise. The test is automatically marked as complete once the\n     * promise settles.\n     * @param {String} name - Test name. This must be unique in a\n     * given file and must be invariant between runs.\n     */\n    function promise_test(func, name, properties) {\n        if (typeof func !== \"function\") {\n            properties = name;\n            name = func;\n            func = null;\n        }\n        var test_name = get_test_name(func, name);\n        var test = new Test(test_name, properties);\n        test._is_promise_test = true;\n\n        // If there is no promise tests queue make one.\n        if (!tests.promise_tests) {\n            tests.promise_tests = Promise.resolve();\n        }\n        tests.promise_tests = tests.promise_tests.then(function() {\n            return new Promise(function(resolve) {\n                var promise = test.step(func, test, test);\n\n                test.step(function() {\n                    assert(!!promise, \"promise_test\", null,\n                           \"test body must return a 'thenable' object (received ${value})\",\n                           {value:promise});\n                    assert(typeof promise.then === \"function\", \"promise_test\", null,\n                           \"test body must return a 'thenable' object (received an object with no `then` method)\",\n                           null);\n                });\n\n                // Test authors may use the `step` method within a\n                // `promise_test` even though this reflects a mixture of\n                // asynchronous control flow paradigms. The \"done\" callback\n                // should be registered prior to the resolution of the\n                // user-provided Promise to avoid timeouts in cases where the\n                // Promise does not settle but a `step` function has thrown an\n                // error.\n                add_test_done_callback(test, resolve);\n\n                Promise.resolve(promise)\n                    .catch(test.step_func(\n                        function(value) {\n                            if (value instanceof AssertionError) {\n                                throw value;\n                            }\n                            assert(false, \"promise_test\", null,\n                                   \"Unhandled rejection with value: ${value}\", {value:value});\n                        }))\n                    .then(function() {\n                        test.done();\n                    });\n                });\n        });\n    }\n\n    /**\n     * Make a copy of a Promise in the current realm.\n     *\n     * @param {Promise} promise the given promise that may be from a different\n     *                          realm\n     * @returns {Promise}\n     *\n     * An arbitrary promise provided by the caller may have originated\n     * in another frame that have since navigated away, rendering the\n     * frame's document inactive. Such a promise cannot be used with\n     * `await` or Promise.resolve(), as microtasks associated with it\n     * may be prevented from being run. See `issue\n     * 5319<https://github.com/whatwg/html/issues/5319>`_ for a\n     * particular case.\n     *\n     * In functions we define here, there is an expectation from the caller\n     * that the promise is from the current realm, that can always be used with\n     * `await`, etc. We therefore create a new promise in this realm that\n     * inherit the value and status from the given promise.\n     */\n\n    function bring_promise_to_current_realm(promise) {\n        return new Promise(promise.then.bind(promise));\n    }\n\n    /**\n     * Assert that a Promise is rejected with the right ECMAScript exception.\n     *\n     * @param {Test} test - the `Test` to use for the assertion.\n     * @param {Function} constructor - The expected exception constructor.\n     * @param {Promise} promise - The promise that's expected to\n     * reject with the given exception.\n     * @param {string} [description] Error message to add to assert in case of\n     *                               failure.\n     */\n    function promise_rejects_js(test, constructor, promise, description) {\n        return bring_promise_to_current_realm(promise)\n            .then(test.unreached_func(\"Should have rejected: \" + description))\n            .catch(function(e) {\n                assert_throws_js_impl(constructor, function() { throw e },\n                                      description, \"promise_rejects_js\");\n            });\n    }\n\n    /**\n     * Assert that a Promise is rejected with the right DOMException.\n     *\n     * For the remaining arguments, there are two ways of calling\n     * promise_rejects_dom:\n     *\n     * 1) If the DOMException is expected to come from the current global, the\n     * third argument should be the promise expected to reject, and a fourth,\n     * optional, argument is the assertion description.\n     *\n     * 2) If the DOMException is expected to come from some other global, the\n     * third argument should be the DOMException constructor from that global,\n     * the fourth argument the promise expected to reject, and the fifth,\n     * optional, argument the assertion description.\n     *\n     * @param {Test} test - the `Test` to use for the assertion.\n     * @param {number|string} type - See documentation for\n     * `assert_throws_dom <#assert_throws_dom>`_.\n     * @param {Function} promiseOrConstructor - Either the constructor\n     * for the expected exception (if the exception comes from another\n     * global), or the promise that's expected to reject (if the\n     * exception comes from the current global).\n     * @param {Function|string} descriptionOrPromise - Either the\n     * promise that's expected to reject (if the exception comes from\n     * another global), or the optional description of the condition\n     * being tested (if the exception comes from the current global).\n     * @param {string} [description] - Description of the condition\n     * being tested (if the exception comes from another global).\n     *\n     */\n    function promise_rejects_dom(test, type, promiseOrConstructor, descriptionOrPromise, maybeDescription) {\n        let constructor, promise, description;\n        if (typeof promiseOrConstructor === \"function\" &&\n            promiseOrConstructor.name === \"DOMException\") {\n            constructor = promiseOrConstructor;\n            promise = descriptionOrPromise;\n            description = maybeDescription;\n        } else {\n            constructor = self.DOMException;\n            promise = promiseOrConstructor;\n            description = descriptionOrPromise;\n            assert(maybeDescription === undefined,\n                   \"Too many args pased to no-constructor version of promise_rejects_dom\");\n        }\n        return bring_promise_to_current_realm(promise)\n            .then(test.unreached_func(\"Should have rejected: \" + description))\n            .catch(function(e) {\n                assert_throws_dom_impl(type, function() { throw e }, description,\n                                       \"promise_rejects_dom\", constructor);\n            });\n    }\n\n    /**\n     * Assert that a Promise is rejected with the provided value.\n     *\n     * @param {Test} test - the `Test` to use for the assertion.\n     * @param {Any} exception - The expected value of the rejected promise.\n     * @param {Promise} promise - The promise that's expected to\n     * reject.\n     * @param {string} [description] Error message to add to assert in case of\n     *                               failure.\n     */\n    function promise_rejects_exactly(test, exception, promise, description) {\n        return bring_promise_to_current_realm(promise)\n            .then(test.unreached_func(\"Should have rejected: \" + description))\n            .catch(function(e) {\n                assert_throws_exactly_impl(exception, function() { throw e },\n                                           description, \"promise_rejects_exactly\");\n            });\n    }\n\n    /**\n     * Allow DOM events to be handled using Promises.\n     *\n     * This can make it a lot easier to test a very specific series of events,\n     * including ensuring that unexpected events are not fired at any point.\n     *\n     * `EventWatcher` will assert if an event occurs while there is no `wait_for`\n     * created Promise waiting to be fulfilled, or if the event is of a different type\n     * to the type currently expected. This ensures that only the events that are\n     * expected occur, in the correct order, and with the correct timing.\n     *\n     * @constructor\n     * @param {Test} test - The `Test` to use for the assertion.\n     * @param {EventTarget} watchedNode - The target expected to receive the events.\n     * @param {string[]} eventTypes - List of events to watch for.\n     * @param {Promise} timeoutPromise - Promise that will cause the\n     * test to be set to `TIMEOUT` once fulfilled.\n     *\n     */\n    function EventWatcher(test, watchedNode, eventTypes, timeoutPromise)\n    {\n        if (typeof eventTypes == 'string') {\n            eventTypes = [eventTypes];\n        }\n\n        var waitingFor = null;\n\n        // This is null unless we are recording all events, in which case it\n        // will be an Array object.\n        var recordedEvents = null;\n\n        var eventHandler = test.step_func(function(evt) {\n            assert_true(!!waitingFor,\n                        'Not expecting event, but got ' + evt.type + ' event');\n            assert_equals(evt.type, waitingFor.types[0],\n                          'Expected ' + waitingFor.types[0] + ' event, but got ' +\n                          evt.type + ' event instead');\n\n            if (Array.isArray(recordedEvents)) {\n                recordedEvents.push(evt);\n            }\n\n            if (waitingFor.types.length > 1) {\n                // Pop first event from array\n                waitingFor.types.shift();\n                return;\n            }\n            // We need to null out waitingFor before calling the resolve function\n            // since the Promise's resolve handlers may call wait_for() which will\n            // need to set waitingFor.\n            var resolveFunc = waitingFor.resolve;\n            waitingFor = null;\n            // Likewise, we should reset the state of recordedEvents.\n            var result = recordedEvents || evt;\n            recordedEvents = null;\n            resolveFunc(result);\n        });\n\n        for (var i = 0; i < eventTypes.length; i++) {\n            watchedNode.addEventListener(eventTypes[i], eventHandler, false);\n        }\n\n        /**\n         * Returns a Promise that will resolve after the specified event or\n         * series of events has occurred.\n         *\n         * @param {Object} options An optional options object. If the 'record' property\n         *                 on this object has the value 'all', when the Promise\n         *                 returned by this function is resolved,  *all* Event\n         *                 objects that were waited for will be returned as an\n         *                 array.\n         *\n         * @example\n         * const watcher = new EventWatcher(t, div, [ 'animationstart',\n         *                                            'animationiteration',\n         *                                            'animationend' ]);\n         * return watcher.wait_for([ 'animationstart', 'animationend' ],\n         *                         { record: 'all' }).then(evts => {\n         *   assert_equals(evts[0].elapsedTime, 0.0);\n         *   assert_equals(evts[1].elapsedTime, 2.0);\n         * });\n         */\n        this.wait_for = function(types, options) {\n            if (waitingFor) {\n                return Promise.reject('Already waiting for an event or events');\n            }\n            if (typeof types == 'string') {\n                types = [types];\n            }\n            if (options && options.record && options.record === 'all') {\n                recordedEvents = [];\n            }\n            return new Promise(function(resolve, reject) {\n                var timeout = test.step_func(function() {\n                    // If the timeout fires after the events have been received\n                    // or during a subsequent call to wait_for, ignore it.\n                    if (!waitingFor || waitingFor.resolve !== resolve)\n                        return;\n\n                    // This should always fail, otherwise we should have\n                    // resolved the promise.\n                    assert_true(waitingFor.types.length == 0,\n                                'Timed out waiting for ' + waitingFor.types.join(', '));\n                    var result = recordedEvents;\n                    recordedEvents = null;\n                    var resolveFunc = waitingFor.resolve;\n                    waitingFor = null;\n                    resolveFunc(result);\n                });\n\n                if (timeoutPromise) {\n                    timeoutPromise().then(timeout);\n                }\n\n                waitingFor = {\n                    types: types,\n                    resolve: resolve,\n                    reject: reject\n                };\n            });\n        };\n\n        /**\n         * Stop listening for events\n         */\n        function stop_watching() {\n            for (var i = 0; i < eventTypes.length; i++) {\n                watchedNode.removeEventListener(eventTypes[i], eventHandler, false);\n            }\n        };\n\n        test._add_cleanup(stop_watching);\n\n        return this;\n    }\n    expose(EventWatcher, 'EventWatcher');\n\n    /**\n     * @typedef {Object} SettingsObject\n     * @property {bool} single_test - Use the single-page-test\n     * mode. In this mode the Document represents a single\n     * `async_test`. Asserts may be used directly without requiring\n     * `Test.step` or similar wrappers, and any exceptions set the\n     * status of the test rather than the status of the harness.\n     * @property {bool} allow_uncaught_exception - don't treat an\n     * uncaught exception as an error; needed when e.g. testing the\n     * `window.onerror` handler.\n     * @property {boolean} explicit_done - Wait for a call to `done()`\n     * before declaring all tests complete (this is always true for\n     * single-page tests).\n     * @property hide_test_state - hide the test state output while\n     * the test is running; This is helpful when the output of the test state\n     * may interfere the test results.\n     * @property {bool} explicit_timeout - disable file timeout; only\n     * stop waiting for results when the `timeout()` function is\n     * called This should typically only be set for manual tests, or\n     * by a test runner that providees its own timeout mechanism.\n     * @property {number} timeout_multiplier - Multiplier to apply to\n     * per-test timeouts. This should only be set by a test runner.\n     * @property {Document} output_document - The document to which\n     * results should be logged. By default this is the current\n     * document but could be an ancestor document in some cases e.g. a\n     * SVG test loaded in an HTML wrapper\n     *\n     */\n\n    /**\n     * Configure the harness\n     *\n     * @param {Function|SettingsObject} funcOrProperties - Either a\n     * setup function to run, or a set of properties. If this is a\n     * function that function is run synchronously. Any exception in\n     * the function will set the overall harness status to `ERROR`.\n     * @param {SettingsObject} maybeProperties - An object containing\n     * the settings to use, if the first argument is a function.\n     *\n     */\n    function setup(func_or_properties, maybe_properties)\n    {\n        var func = null;\n        var properties = {};\n        if (arguments.length === 2) {\n            func = func_or_properties;\n            properties = maybe_properties;\n        } else if (func_or_properties instanceof Function) {\n            func = func_or_properties;\n        } else {\n            properties = func_or_properties;\n        }\n        tests.setup(func, properties);\n        test_environment.on_new_harness_properties(properties);\n    }\n\n    /**\n     * Configure the harness, waiting for a promise to resolve\n     * before running any `promise_test` tests.\n     *\n     * @param {Function} func - Function returning a promise that's\n     * run synchronously. Promise tests are not run until after this\n     * function has resolved.\n     * @param {SettingsObject} [properties] - An object containing\n     * the harness settings to use.\n     *\n     */\n    function promise_setup(func, properties={})\n    {\n        if (typeof func !== \"function\") {\n            tests.set_status(tests.status.ERROR,\n                             \"promise_test invoked without a function\");\n            tests.complete();\n            return;\n        }\n        tests.promise_setup_called = true;\n\n        if (!tests.promise_tests) {\n            tests.promise_tests = Promise.resolve();\n        }\n\n        tests.promise_tests = tests.promise_tests\n            .then(function()\n                  {\n                      var result;\n\n                      tests.setup(null, properties);\n                      result = func();\n                      test_environment.on_new_harness_properties(properties);\n\n                      if (!result || typeof result.then !== \"function\") {\n                          throw \"Non-thenable returned by function passed to `promise_setup`\";\n                      }\n                      return result;\n                  })\n            .catch(function(e)\n                   {\n                       tests.set_status(tests.status.ERROR,\n                                        String(e),\n                                        e && e.stack);\n                       tests.complete();\n                   });\n    }\n\n    /**\n     * Mark test loading as complete.\n     *\n     * Typically this function is called implicitly on page load; it's\n     * only necessary for users to call this when either the\n     * ``explicit_done`` or ``single_page`` properties have been set\n     * via the :js:func:`setup` function.\n     *\n     * For single page tests this marks the test as complete and sets its status.\n     * For other tests, this marks test loading as complete, but doesn't affect ongoing tests.\n     */\n    function done() {\n        if (tests.tests.length === 0) {\n            // `done` is invoked after handling uncaught exceptions, so if the\n            // harness status is already set, the corresponding message is more\n            // descriptive than the generic message defined here.\n            if (tests.status.status === null) {\n                tests.status.status = tests.status.ERROR;\n                tests.status.message = \"done() was called without first defining any tests\";\n            }\n\n            tests.complete();\n            return;\n        }\n        if (tests.file_is_test) {\n            // file is test files never have asynchronous cleanup logic,\n            // meaning the fully-synchronous `done` function can be used here.\n            tests.tests[0].done();\n        }\n        tests.end_wait();\n    }\n\n    /**\n     * @deprecated generate a list of tests from a function and list of arguments\n     *\n     * This is deprecated because it runs all the tests outside of the test functions\n     * and as a result any test throwing an exception will result in no tests being\n     * run. In almost all cases, you should simply call test within the loop you would\n     * use to generate the parameter list array.\n     *\n     * @param {Function} func - The function that will be called for each generated tests.\n     * @param {Any[][]} args - An array of arrays. Each nested array\n     * has the structure `[testName, ...testArgs]`. For each of these nested arrays\n     * array, a test is generated with name `testName` and test function equivalent to\n     * `func(..testArgs)`.\n     */\n    function generate_tests(func, args, properties) {\n        forEach(args, function(x, i)\n                {\n                    var name = x[0];\n                    test(function()\n                         {\n                             func.apply(this, x.slice(1));\n                         },\n                         name,\n                         Array.isArray(properties) ? properties[i] : properties);\n                });\n    }\n\n    /**\n     * @deprecated\n     *\n     * Register a function as a DOM event listener to the\n     * given object for the event bubbling phase.\n     *\n     * @param {EventTarget} object - Event target\n     * @param {string} event - Event name\n     * @param {Function} callback - Event handler.\n     */\n    function on_event(object, event, callback)\n    {\n        object.addEventListener(event, callback, false);\n    }\n\n    /**\n     * Global version of :js:func:`Test.step_timeout` for use in single page tests.\n     *\n     * @param {Function} func - Function to run after the timeout\n     * @param {number} timeout - Time in ms to wait before running the\n     * test step. The actual wait time is ``timeout`` x\n     * ``timeout_multiplier``.\n     */\n    function step_timeout(func, timeout) {\n        var outer_this = this;\n        var args = Array.prototype.slice.call(arguments, 2);\n        return setTimeout(function() {\n            func.apply(outer_this, args);\n        }, timeout * tests.timeout_multiplier);\n    }\n\n    expose(test, 'test');\n    expose(async_test, 'async_test');\n    expose(promise_test, 'promise_test');\n    expose(promise_rejects_js, 'promise_rejects_js');\n    expose(promise_rejects_dom, 'promise_rejects_dom');\n    expose(promise_rejects_exactly, 'promise_rejects_exactly');\n    expose(generate_tests, 'generate_tests');\n    expose(setup, 'setup');\n    expose(promise_setup, 'promise_setup');\n    expose(done, 'done');\n    expose(on_event, 'on_event');\n    expose(step_timeout, 'step_timeout');\n\n    /*\n     * Return a string truncated to the given length, with ... added at the end\n     * if it was longer.\n     */\n    function truncate(s, len)\n    {\n        if (s.length > len) {\n            return s.substring(0, len - 3) + \"...\";\n        }\n        return s;\n    }\n\n    /*\n     * Return true if object is probably a Node object.\n     */\n    function is_node(object)\n    {\n        // I use duck-typing instead of instanceof, because\n        // instanceof doesn't work if the node is from another window (like an\n        // iframe's contentWindow):\n        // http://www.w3.org/Bugs/Public/show_bug.cgi?id=12295\n        try {\n            var has_node_properties = (\"nodeType\" in object &&\n                                       \"nodeName\" in object &&\n                                       \"nodeValue\" in object &&\n                                       \"childNodes\" in object);\n        } catch (e) {\n            // We're probably cross-origin, which means we aren't a node\n            return false;\n        }\n\n        if (has_node_properties) {\n            try {\n                object.nodeType;\n            } catch (e) {\n                // The object is probably Node.prototype or another prototype\n                // object that inherits from it, and not a Node instance.\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    var replacements = {\n        \"0\": \"0\",\n        \"1\": \"x01\",\n        \"2\": \"x02\",\n        \"3\": \"x03\",\n        \"4\": \"x04\",\n        \"5\": \"x05\",\n        \"6\": \"x06\",\n        \"7\": \"x07\",\n        \"8\": \"b\",\n        \"9\": \"t\",\n        \"10\": \"n\",\n        \"11\": \"v\",\n        \"12\": \"f\",\n        \"13\": \"r\",\n        \"14\": \"x0e\",\n        \"15\": \"x0f\",\n        \"16\": \"x10\",\n        \"17\": \"x11\",\n        \"18\": \"x12\",\n        \"19\": \"x13\",\n        \"20\": \"x14\",\n        \"21\": \"x15\",\n        \"22\": \"x16\",\n        \"23\": \"x17\",\n        \"24\": \"x18\",\n        \"25\": \"x19\",\n        \"26\": \"x1a\",\n        \"27\": \"x1b\",\n        \"28\": \"x1c\",\n        \"29\": \"x1d\",\n        \"30\": \"x1e\",\n        \"31\": \"x1f\",\n        \"0xfffd\": \"ufffd\",\n        \"0xfffe\": \"ufffe\",\n        \"0xffff\": \"uffff\",\n    };\n\n    /**\n     * Convert a value to a nice, human-readable string\n     *\n     * When many JavaScript Object values are coerced to a String, the\n     * resulting value will be ``\"[object Object]\"``. This obscures\n     * helpful information, making the coerced value unsuitable for\n     * use in assertion messages, test names, and debugging\n     * statements. `format_value` produces more distinctive string\n     * representations of many kinds of objects, including arrays and\n     * the more important DOM Node types. It also translates String\n     * values containing control characters to include human-readable\n     * representations.\n     *\n     * @example\n     * // \"Document node with 2 children\"\n     * format_value(document);\n     * @example\n     * // \"\\\"foo\\\\uffffbar\\\"\"\n     * format_value(\"foo\\uffffbar\");\n     * @example\n     * // \"[-0, Infinity]\"\n     * format_value([-0, Infinity]);\n     * @param {Any} val - The value to convert to a string.\n     * @returns {string} - A string representation of ``val``, optimised for human readability.\n     */\n    function format_value(val, seen)\n    {\n        if (!seen) {\n            seen = [];\n        }\n        if (typeof val === \"object\" && val !== null) {\n            if (seen.indexOf(val) >= 0) {\n                return \"[...]\";\n            }\n            seen.push(val);\n        }\n        if (Array.isArray(val)) {\n            let output = \"[\";\n            if (val.beginEllipsis !== undefined) {\n                output += \"â¦, \";\n            }\n            output += val.map(function(x) {return format_value(x, seen);}).join(\", \");\n            if (val.endEllipsis !== undefined) {\n                output += \", â¦\";\n            }\n            return output + \"]\";\n        }\n\n        switch (typeof val) {\n        case \"string\":\n            val = val.replace(/\\\\/g, \"\\\\\\\\\");\n            for (var p in replacements) {\n                var replace = \"\\\\\" + replacements[p];\n                val = val.replace(RegExp(String.fromCharCode(p), \"g\"), replace);\n            }\n            return '\"' + val.replace(/\"/g, '\\\\\"') + '\"';\n        case \"boolean\":\n        case \"undefined\":\n            return String(val);\n        case \"number\":\n            // In JavaScript, -0 === 0 and String(-0) == \"0\", so we have to\n            // special-case.\n            if (val === -0 && 1/val === -Infinity) {\n                return \"-0\";\n            }\n            return String(val);\n        case \"object\":\n            if (val === null) {\n                return \"null\";\n            }\n\n            // Special-case Node objects, since those come up a lot in my tests.  I\n            // ignore namespaces.\n            if (is_node(val)) {\n                switch (val.nodeType) {\n                case Node.ELEMENT_NODE:\n                    var ret = \"<\" + val.localName;\n                    for (var i = 0; i < val.attributes.length; i++) {\n                        ret += \" \" + val.attributes[i].name + '=\"' + val.attributes[i].value + '\"';\n                    }\n                    ret += \">\" + val.innerHTML + \"</\" + val.localName + \">\";\n                    return \"Element node \" + truncate(ret, 60);\n                case Node.TEXT_NODE:\n                    return 'Text node \"' + truncate(val.data, 60) + '\"';\n                case Node.PROCESSING_INSTRUCTION_NODE:\n                    return \"ProcessingInstruction node with target \" + format_value(truncate(val.target, 60)) + \" and data \" + format_value(truncate(val.data, 60));\n                case Node.COMMENT_NODE:\n                    return \"Comment node <!--\" + truncate(val.data, 60) + \"-->\";\n                case Node.DOCUMENT_NODE:\n                    return \"Document node with \" + val.childNodes.length + (val.childNodes.length == 1 ? \" child\" : \" children\");\n                case Node.DOCUMENT_TYPE_NODE:\n                    return \"DocumentType node\";\n                case Node.DOCUMENT_FRAGMENT_NODE:\n                    return \"DocumentFragment node with \" + val.childNodes.length + (val.childNodes.length == 1 ? \" child\" : \" children\");\n                default:\n                    return \"Node object of unknown type\";\n                }\n            }\n\n        /* falls through */\n        default:\n            try {\n                return typeof val + ' \"' + truncate(String(val), 1000) + '\"';\n            } catch(e) {\n                return (\"[stringifying object threw \" + String(e) +\n                        \" with type \" + String(typeof e) + \"]\");\n            }\n        }\n    }\n    expose(format_value, \"format_value\");\n\n    /*\n     * Assertions\n     */\n\n    function expose_assert(f, name) {\n        function assert_wrapper(...args) {\n            let status = Test.statuses.TIMEOUT;\n            let stack = null;\n            try {\n                if (settings.debug) {\n                    console.debug(\"ASSERT\", name, tests.current_test && tests.current_test.name, args);\n                }\n                if (tests.output) {\n                    tests.set_assert(name, args);\n                }\n                const rv = f.apply(undefined, args);\n                status = Test.statuses.PASS;\n                return rv;\n            } catch(e) {\n                status = Test.statuses.FAIL;\n                stack = e.stack ? e.stack : null;\n                throw e;\n            } finally {\n                if (tests.output && !stack) {\n                    stack = get_stack();\n                }\n                if (tests.output) {\n                    tests.set_assert_status(status, stack);\n                }\n            }\n        }\n        expose(assert_wrapper, name);\n    }\n\n    /**\n     * Assert that ``actual`` is strictly true\n     *\n     * @param {Any} actual - Value that is asserted to be true\n     * @param {string} [description] - Description of the condition being tested\n     */\n    function assert_true(actual, description)\n    {\n        assert(actual === true, \"assert_true\", description,\n                                \"expected true got ${actual}\", {actual:actual});\n    }\n    expose_assert(assert_true, \"assert_true\");\n\n    /**\n     * Assert that ``actual`` is strictly false\n     *\n     * @param {Any} actual - Value that is asserted to be false\n     * @param {string} [description] - Description of the condition being tested\n     */\n    function assert_false(actual, description)\n    {\n        assert(actual === false, \"assert_false\", description,\n                                 \"expected false got ${actual}\", {actual:actual});\n    }\n    expose_assert(assert_false, \"assert_false\");\n\n    function same_value(x, y) {\n        if (y !== y) {\n            //NaN case\n            return x !== x;\n        }\n        if (x === 0 && y === 0) {\n            //Distinguish +0 and -0\n            return 1/x === 1/y;\n        }\n        return x === y;\n    }\n\n    /**\n     * Assert that ``actual`` is the same value as ``expected``.\n     *\n     * For objects this compares by cobject identity; for primitives\n     * this distinguishes between 0 and -0, and has correct handling\n     * of NaN.\n     *\n     * @param {Any} actual - Test value.\n     * @param {Any} expected - Expected value.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_equals(actual, expected, description)\n    {\n         /*\n          * Test if two primitives are equal or two objects\n          * are the same object\n          */\n        if (typeof actual != typeof expected) {\n            assert(false, \"assert_equals\", description,\n                          \"expected (\" + typeof expected + \") ${expected} but got (\" + typeof actual + \") ${actual}\",\n                          {expected:expected, actual:actual});\n            return;\n        }\n        assert(same_value(actual, expected), \"assert_equals\", description,\n                                             \"expected ${expected} but got ${actual}\",\n                                             {expected:expected, actual:actual});\n    }\n    expose_assert(assert_equals, \"assert_equals\");\n\n    /**\n     * Assert that ``actual`` is not the same value as ``expected``.\n     *\n     * Comparison is as for :js:func:`assert_equals`.\n     *\n     * @param {Any} actual - Test value.\n     * @param {Any} expected - The value ``actual`` is expected to be different to.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_not_equals(actual, expected, description)\n    {\n        assert(!same_value(actual, expected), \"assert_not_equals\", description,\n                                              \"got disallowed value ${actual}\",\n                                              {actual:actual});\n    }\n    expose_assert(assert_not_equals, \"assert_not_equals\");\n\n    /**\n     * Assert that ``expected`` is an array and ``actual`` is one of the members.\n     * This is implemented using ``indexOf``, so doesn't handle NaN or Â±0 correctly.\n     *\n     * @param {Any} actual - Test value.\n     * @param {Array} expected - An array that ``actual`` is expected to\n     * be a member of.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_in_array(actual, expected, description)\n    {\n        assert(expected.indexOf(actual) != -1, \"assert_in_array\", description,\n                                               \"value ${actual} not in array ${expected}\",\n                                               {actual:actual, expected:expected});\n    }\n    expose_assert(assert_in_array, \"assert_in_array\");\n\n    // This function was deprecated in July of 2015.\n    // See https://github.com/web-platform-tests/wpt/issues/2033\n    /**\n     * @deprecated\n     * Recursively compare two objects for equality.\n     *\n     * See `Issue 2033\n     * <https://github.com/web-platform-tests/wpt/issues/2033>`_ for\n     * more information.\n     *\n     * @param {Object} actual - Test value.\n     * @param {Object} expected - Expected value.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_object_equals(actual, expected, description)\n    {\n         assert(typeof actual === \"object\" && actual !== null, \"assert_object_equals\", description,\n                                                               \"value is ${actual}, expected object\",\n                                                               {actual: actual});\n         //This needs to be improved a great deal\n         function check_equal(actual, expected, stack)\n         {\n             stack.push(actual);\n\n             var p;\n             for (p in actual) {\n                 assert(expected.hasOwnProperty(p), \"assert_object_equals\", description,\n                                                    \"unexpected property ${p}\", {p:p});\n\n                 if (typeof actual[p] === \"object\" && actual[p] !== null) {\n                     if (stack.indexOf(actual[p]) === -1) {\n                         check_equal(actual[p], expected[p], stack);\n                     }\n                 } else {\n                     assert(same_value(actual[p], expected[p]), \"assert_object_equals\", description,\n                                                       \"property ${p} expected ${expected} got ${actual}\",\n                                                       {p:p, expected:expected[p], actual:actual[p]});\n                 }\n             }\n             for (p in expected) {\n                 assert(actual.hasOwnProperty(p),\n                        \"assert_object_equals\", description,\n                        \"expected property ${p} missing\", {p:p});\n             }\n             stack.pop();\n         }\n         check_equal(actual, expected, []);\n    }\n    expose_assert(assert_object_equals, \"assert_object_equals\");\n\n    /**\n     * Assert that ``actual`` and ``expected`` are both arrays, and that the array properties of\n     * ``actual`` and ``expected`` are all the same value (as for :js:func:`assert_equals`).\n     *\n     * @param {Array} actual - Test array.\n     * @param {Array} expected - Array that is expected to contain the same values as ``actual``.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_array_equals(actual, expected, description)\n    {\n        const max_array_length = 20;\n        function shorten_array(arr, offset = 0) {\n            // Make \", â¦\" only show up when it would likely reduce the length, not accounting for\n            // fonts.\n            if (arr.length < max_array_length + 2) {\n                return arr;\n            }\n            // By default we want half the elements after the offset and half before\n            // But if that takes us past the end of the array, we have more before, and\n            // if it takes us before the start we have more after.\n            const length_after_offset = Math.floor(max_array_length / 2);\n            let upper_bound = Math.min(length_after_offset + offset, arr.length);\n            const lower_bound = Math.max(upper_bound - max_array_length, 0);\n\n            if (lower_bound === 0) {\n                upper_bound = max_array_length;\n            }\n\n            const output = arr.slice(lower_bound, upper_bound);\n            if (lower_bound > 0) {\n                output.beginEllipsis = true;\n            }\n            if (upper_bound < arr.length) {\n                output.endEllipsis = true;\n            }\n            return output;\n        }\n\n        assert(typeof actual === \"object\" && actual !== null && \"length\" in actual,\n               \"assert_array_equals\", description,\n               \"value is ${actual}, expected array\",\n               {actual:actual});\n        assert(actual.length === expected.length,\n               \"assert_array_equals\", description,\n               \"lengths differ, expected array ${expected} length ${expectedLength}, got ${actual} length ${actualLength}\",\n               {expected:shorten_array(expected, expected.length - 1), expectedLength:expected.length,\n                actual:shorten_array(actual, actual.length - 1), actualLength:actual.length\n               });\n\n        for (var i = 0; i < actual.length; i++) {\n            assert(actual.hasOwnProperty(i) === expected.hasOwnProperty(i),\n                   \"assert_array_equals\", description,\n                   \"expected property ${i} to be ${expected} but was ${actual} (expected array ${arrayExpected} got ${arrayActual})\",\n                   {i:i, expected:expected.hasOwnProperty(i) ? \"present\" : \"missing\",\n                    actual:actual.hasOwnProperty(i) ? \"present\" : \"missing\",\n                    arrayExpected:shorten_array(expected, i), arrayActual:shorten_array(actual, i)});\n            assert(same_value(expected[i], actual[i]),\n                   \"assert_array_equals\", description,\n                   \"expected property ${i} to be ${expected} but got ${actual} (expected array ${arrayExpected} got ${arrayActual})\",\n                   {i:i, expected:expected[i], actual:actual[i],\n                    arrayExpected:shorten_array(expected, i), arrayActual:shorten_array(actual, i)});\n        }\n    }\n    expose_assert(assert_array_equals, \"assert_array_equals\");\n\n    /**\n     * Assert that each array property in ``actual`` is a number within\n     * Â± `epsilon` of the corresponding property in `expected`.\n     *\n     * @param {Array} actual - Array of test values.\n     * @param {Array} expected - Array of values expected to be close to the values in ``actual``.\n     * @param {number} epsilon - Magnitude of allowed difference\n     * between each value in ``actual`` and ``expected``.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_array_approx_equals(actual, expected, epsilon, description)\n    {\n        /*\n         * Test if two primitive arrays are equal within +/- epsilon\n         */\n        assert(actual.length === expected.length,\n               \"assert_array_approx_equals\", description,\n               \"lengths differ, expected ${expected} got ${actual}\",\n               {expected:expected.length, actual:actual.length});\n\n        for (var i = 0; i < actual.length; i++) {\n            assert(actual.hasOwnProperty(i) === expected.hasOwnProperty(i),\n                   \"assert_array_approx_equals\", description,\n                   \"property ${i}, property expected to be ${expected} but was ${actual}\",\n                   {i:i, expected:expected.hasOwnProperty(i) ? \"present\" : \"missing\",\n                    actual:actual.hasOwnProperty(i) ? \"present\" : \"missing\"});\n            assert(typeof actual[i] === \"number\",\n                   \"assert_array_approx_equals\", description,\n                   \"property ${i}, expected a number but got a ${type_actual}\",\n                   {i:i, type_actual:typeof actual[i]});\n            assert(Math.abs(actual[i] - expected[i]) <= epsilon,\n                   \"assert_array_approx_equals\", description,\n                   \"property ${i}, expected ${expected} +/- ${epsilon}, expected ${expected} but got ${actual}\",\n                   {i:i, expected:expected[i], actual:actual[i], epsilon:epsilon});\n        }\n    }\n    expose_assert(assert_array_approx_equals, \"assert_array_approx_equals\");\n\n    /**\n     * Assert that ``actual`` is within Â± ``epsilon`` of ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Value number is expected to be close to.\n     * @param {number} epsilon - Magnitude of allowed difference between ``actual`` and ``expected``.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_approx_equals(actual, expected, epsilon, description)\n    {\n        /*\n         * Test if two primitive numbers are equal within +/- epsilon\n         */\n        assert(typeof actual === \"number\",\n               \"assert_approx_equals\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        // The epsilon math below does not place nice with NaN and Infinity\n        // But in this case Infinity = Infinity and NaN = NaN\n        if (isFinite(actual) || isFinite(expected)) {\n            assert(Math.abs(actual - expected) <= epsilon,\n                   \"assert_approx_equals\", description,\n                   \"expected ${expected} +/- ${epsilon} but got ${actual}\",\n                   {expected:expected, actual:actual, epsilon:epsilon});\n        } else {\n            assert_equals(actual, expected);\n        }\n    }\n    expose_assert(assert_approx_equals, \"assert_approx_equals\");\n\n    /**\n     * Assert that ``actual`` is a number less than ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Number that ``actual`` must be less than.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_less_than(actual, expected, description)\n    {\n        /*\n         * Test if a primitive number is less than another\n         */\n        assert(typeof actual === \"number\",\n               \"assert_less_than\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual < expected,\n               \"assert_less_than\", description,\n               \"expected a number less than ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_less_than, \"assert_less_than\");\n\n    /**\n     * Assert that ``actual`` is a number greater than ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Number that ``actual`` must be greater than.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_greater_than(actual, expected, description)\n    {\n        /*\n         * Test if a primitive number is greater than another\n         */\n        assert(typeof actual === \"number\",\n               \"assert_greater_than\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual > expected,\n               \"assert_greater_than\", description,\n               \"expected a number greater than ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_greater_than, \"assert_greater_than\");\n\n    /**\n     * Assert that ``actual`` is a number greater than ``lower`` and less\n     * than ``upper`` but not equal to either.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} lower - Number that ``actual`` must be greater than.\n     * @param {number} upper - Number that ``actual`` must be less than.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_between_exclusive(actual, lower, upper, description)\n    {\n        /*\n         * Test if a primitive number is between two others\n         */\n        assert(typeof actual === \"number\",\n               \"assert_between_exclusive\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual > lower && actual < upper,\n               \"assert_between_exclusive\", description,\n               \"expected a number greater than ${lower} \" +\n               \"and less than ${upper} but got ${actual}\",\n               {lower:lower, upper:upper, actual:actual});\n    }\n    expose_assert(assert_between_exclusive, \"assert_between_exclusive\");\n\n    /**\n     * Assert that ``actual`` is a number less than or equal to ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Number that ``actual`` must be less\n     * than or equal to.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_less_than_equal(actual, expected, description)\n    {\n        /*\n         * Test if a primitive number is less than or equal to another\n         */\n        assert(typeof actual === \"number\",\n               \"assert_less_than_equal\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual <= expected,\n               \"assert_less_than_equal\", description,\n               \"expected a number less than or equal to ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_less_than_equal, \"assert_less_than_equal\");\n\n    /**\n     * Assert that ``actual`` is a number greater than or equal to ``expected``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} expected - Number that ``actual`` must be greater\n     * than or equal to.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_greater_than_equal(actual, expected, description)\n    {\n        /*\n         * Test if a primitive number is greater than or equal to another\n         */\n        assert(typeof actual === \"number\",\n               \"assert_greater_than_equal\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual >= expected,\n               \"assert_greater_than_equal\", description,\n               \"expected a number greater than or equal to ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_greater_than_equal, \"assert_greater_than_equal\");\n\n    /**\n     * Assert that ``actual`` is a number greater than or equal to ``lower`` and less\n     * than or equal to ``upper``.\n     *\n     * @param {number} actual - Test value.\n     * @param {number} lower - Number that ``actual`` must be greater than or equal to.\n     * @param {number} upper - Number that ``actual`` must be less than or equal to.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_between_inclusive(actual, lower, upper, description)\n    {\n        /*\n         * Test if a primitive number is between to two others or equal to either of them\n         */\n        assert(typeof actual === \"number\",\n               \"assert_between_inclusive\", description,\n               \"expected a number but got a ${type_actual}\",\n               {type_actual:typeof actual});\n\n        assert(actual >= lower && actual <= upper,\n               \"assert_between_inclusive\", description,\n               \"expected a number greater than or equal to ${lower} \" +\n               \"and less than or equal to ${upper} but got ${actual}\",\n               {lower:lower, upper:upper, actual:actual});\n    }\n    expose_assert(assert_between_inclusive, \"assert_between_inclusive\");\n\n    /**\n     * Assert that ``actual`` matches the RegExp ``expected``.\n     *\n     * @param {String} actual - Test string.\n     * @param {RegExp} expected - RegExp ``actual`` must match.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_regexp_match(actual, expected, description) {\n        /*\n         * Test if a string (actual) matches a regexp (expected)\n         */\n        assert(expected.test(actual),\n               \"assert_regexp_match\", description,\n               \"expected ${expected} but got ${actual}\",\n               {expected:expected, actual:actual});\n    }\n    expose_assert(assert_regexp_match, \"assert_regexp_match\");\n\n    /**\n     * Assert that the class string of ``object`` as returned in\n     * ``Object.prototype.toString`` is equal to ``class_name``.\n     *\n     * @param {Object} object - Object to stringify.\n     * @param {string} class_string - Expected class string for ``object``.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_class_string(object, class_string, description) {\n        var actual = {}.toString.call(object);\n        var expected = \"[object \" + class_string + \"]\";\n        assert(same_value(actual, expected), \"assert_class_string\", description,\n                                             \"expected ${expected} but got ${actual}\",\n                                             {expected:expected, actual:actual});\n    }\n    expose_assert(assert_class_string, \"assert_class_string\");\n\n    /**\n     * Assert that ``object`` has an own property with name ``property_name``.\n     *\n     * @param {Object} object - Object that should have the given property.\n     * @param {string} property_name - Expected property name.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_own_property(object, property_name, description) {\n        assert(object.hasOwnProperty(property_name),\n               \"assert_own_property\", description,\n               \"expected property ${p} missing\", {p:property_name});\n    }\n    expose_assert(assert_own_property, \"assert_own_property\");\n\n    /**\n     * Assert that ``object`` does not have an own property with name ``property_name``.\n     *\n     * @param {Object} object - Object that should not have the given property.\n     * @param {string} property_name - Property name to test.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_not_own_property(object, property_name, description) {\n        assert(!object.hasOwnProperty(property_name),\n               \"assert_not_own_property\", description,\n               \"unexpected property ${p} is found on object\", {p:property_name});\n    }\n    expose_assert(assert_not_own_property, \"assert_not_own_property\");\n\n    function _assert_inherits(name) {\n        return function (object, property_name, description)\n        {\n            assert((typeof object === \"object\" && object !== null) ||\n                   typeof object === \"function\" ||\n                   // Or has [[IsHTMLDDA]] slot\n                   String(object) === \"[object HTMLAllCollection]\",\n                   name, description,\n                   \"provided value is not an object\");\n\n            assert(\"hasOwnProperty\" in object,\n                   name, description,\n                   \"provided value is an object but has no hasOwnProperty method\");\n\n            assert(!object.hasOwnProperty(property_name),\n                   name, description,\n                   \"property ${p} found on object expected in prototype chain\",\n                   {p:property_name});\n\n            assert(property_name in object,\n                   name, description,\n                   \"property ${p} not found in prototype chain\",\n                   {p:property_name});\n        };\n    }\n\n    /**\n     * Assert that ``object`` does not have an own property with name\n     * ``property_name``, but inherits one through the prototype chain.\n     *\n     * @param {Object} object - Object that should have the given property in its prototype chain.\n     * @param {string} property_name - Expected property name.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_inherits(object, property_name, description) {\n        return _assert_inherits(\"assert_inherits\")(object, property_name, description);\n    }\n    expose_assert(assert_inherits, \"assert_inherits\");\n\n    /**\n     * Alias for :js:func:`insert_inherits`.\n     *\n     * @param {Object} object - Object that should have the given property in its prototype chain.\n     * @param {string} property_name - Expected property name.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_idl_attribute(object, property_name, description) {\n        return _assert_inherits(\"assert_idl_attribute\")(object, property_name, description);\n    }\n    expose_assert(assert_idl_attribute, \"assert_idl_attribute\");\n\n\n    /**\n     * Assert that ``object`` has a property named ``property_name`` and that the property is readonly.\n     *\n     * Note: The implementation tries to update the named property, so\n     * any side effects of updating will be triggered. Users are\n     * encouraged to instead inspect the property descriptor of ``property_name`` on ``object``.\n     *\n     * @param {Object} object - Object that should have the given property in its prototype chain.\n     * @param {string} property_name - Expected property name.\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_readonly(object, property_name, description)\n    {\n         var initial_value = object[property_name];\n         try {\n             //Note that this can have side effects in the case where\n             //the property has PutForwards\n             object[property_name] = initial_value + \"a\"; //XXX use some other value here?\n             assert(same_value(object[property_name], initial_value),\n                    \"assert_readonly\", description,\n                    \"changing property ${p} succeeded\",\n                    {p:property_name});\n         } finally {\n             object[property_name] = initial_value;\n         }\n    }\n    expose_assert(assert_readonly, \"assert_readonly\");\n\n    /**\n     * Assert a JS Error with the expected constructor is thrown.\n     *\n     * @param {object} constructor The expected exception constructor.\n     * @param {Function} func Function which should throw.\n     * @param {string} [description] Error description for the case that the error is not thrown.\n     */\n    function assert_throws_js(constructor, func, description)\n    {\n        assert_throws_js_impl(constructor, func, description,\n                              \"assert_throws_js\");\n    }\n    expose_assert(assert_throws_js, \"assert_throws_js\");\n\n    /**\n     * Like assert_throws_js but allows specifying the assertion type\n     * (assert_throws_js or promise_rejects_js, in practice).\n     */\n    function assert_throws_js_impl(constructor, func, description,\n                                   assertion_type)\n    {\n        try {\n            func.call(this);\n            assert(false, assertion_type, description,\n                   \"${func} did not throw\", {func:func});\n        } catch (e) {\n            if (e instanceof AssertionError) {\n                throw e;\n            }\n\n            // Basic sanity-checks on the thrown exception.\n            assert(typeof e === \"object\",\n                   assertion_type, description,\n                   \"${func} threw ${e} with type ${type}, not an object\",\n                   {func:func, e:e, type:typeof e});\n\n            assert(e !== null,\n                   assertion_type, description,\n                   \"${func} threw null, not an object\",\n                   {func:func});\n\n            // Basic sanity-check on the passed-in constructor\n            assert(typeof constructor == \"function\",\n                   assertion_type, description,\n                   \"${constructor} is not a constructor\",\n                   {constructor:constructor});\n            var obj = constructor;\n            while (obj) {\n                if (typeof obj === \"function\" &&\n                    obj.name === \"Error\") {\n                    break;\n                }\n                obj = Object.getPrototypeOf(obj);\n            }\n            assert(obj != null,\n                   assertion_type, description,\n                   \"${constructor} is not an Error subtype\",\n                   {constructor:constructor});\n\n            // And checking that our exception is reasonable\n            assert(e.constructor === constructor &&\n                   e.name === constructor.name,\n                   assertion_type, description,\n                   \"${func} threw ${actual} (${actual_name}) expected instance of ${expected} (${expected_name})\",\n                   {func:func, actual:e, actual_name:e.name,\n                    expected:constructor,\n                    expected_name:constructor.name});\n        }\n    }\n\n    // TODO: Figure out how to document the overloads better.\n    // sphinx-js doesn't seem to handle @variation correctly,\n    // and only expects a single JSDoc entry per function.\n    /**\n     * Assert a DOMException with the expected type is thrown.\n     *\n     * There are two ways of calling assert_throws_dom:\n     *\n     * 1) If the DOMException is expected to come from the current global, the\n     * second argument should be the function expected to throw and a third,\n     * optional, argument is the assertion description.\n     *\n     * 2) If the DOMException is expected to come from some other global, the\n     * second argument should be the DOMException constructor from that global,\n     * the third argument the function expected to throw, and the fourth, optional,\n     * argument the assertion description.\n     *\n     * @param {number|string} type - The expected exception name or\n     * code.  See the `table of names and codes\n     * <https://webidl.spec.whatwg.org/#dfn-error-names-table>`_. If a\n     * number is passed it should be one of the numeric code values in\n     * that table (e.g. 3, 4, etc).  If a string is passed it can\n     * either be an exception name (e.g. \"HierarchyRequestError\",\n     * \"WrongDocumentError\") or the name of the corresponding error\n     * code (e.g. \"``HIERARCHY_REQUEST_ERR``\", \"``WRONG_DOCUMENT_ERR``\").\n     * @param {Function} descriptionOrFunc - The function expected to\n     * throw (if the exception comes from another global), or the\n     * optional description of the condition being tested (if the\n     * exception comes from the current global).\n     * @param {string} [description] - Description of the condition\n     * being tested (if the exception comes from another global).\n     *\n     */\n    function assert_throws_dom(type, funcOrConstructor, descriptionOrFunc, maybeDescription)\n    {\n        let constructor, func, description;\n        if (funcOrConstructor.name === \"DOMException\") {\n            constructor = funcOrConstructor;\n            func = descriptionOrFunc;\n            description = maybeDescription;\n        } else {\n            constructor = self.DOMException;\n            func = funcOrConstructor;\n            description = descriptionOrFunc;\n            assert(maybeDescription === undefined,\n                   \"Too many args pased to no-constructor version of assert_throws_dom\");\n        }\n        assert_throws_dom_impl(type, func, description, \"assert_throws_dom\", constructor)\n    }\n    expose_assert(assert_throws_dom, \"assert_throws_dom\");\n\n    /**\n     * Similar to assert_throws_dom but allows specifying the assertion type\n     * (assert_throws_dom or promise_rejects_dom, in practice).  The\n     * \"constructor\" argument must be the DOMException constructor from the\n     * global we expect the exception to come from.\n     */\n    function assert_throws_dom_impl(type, func, description, assertion_type, constructor)\n    {\n        try {\n            func.call(this);\n            assert(false, assertion_type, description,\n                   \"${func} did not throw\", {func:func});\n        } catch (e) {\n            if (e instanceof AssertionError) {\n                throw e;\n            }\n\n            // Basic sanity-checks on the thrown exception.\n            assert(typeof e === \"object\",\n                   assertion_type, description,\n                   \"${func} threw ${e} with type ${type}, not an object\",\n                   {func:func, e:e, type:typeof e});\n\n            assert(e !== null,\n                   assertion_type, description,\n                   \"${func} threw null, not an object\",\n                   {func:func});\n\n            // Sanity-check our type\n            assert(typeof type == \"number\" ||\n                   typeof type == \"string\",\n                   assertion_type, description,\n                   \"${type} is not a number or string\",\n                   {type:type});\n\n            var codename_name_map = {\n                INDEX_SIZE_ERR: 'IndexSizeError',\n                HIERARCHY_REQUEST_ERR: 'HierarchyRequestError',\n                WRONG_DOCUMENT_ERR: 'WrongDocumentError',\n                INVALID_CHARACTER_ERR: 'InvalidCharacterError',\n                NO_MODIFICATION_ALLOWED_ERR: 'NoModificationAllowedError',\n                NOT_FOUND_ERR: 'NotFoundError',\n                NOT_SUPPORTED_ERR: 'NotSupportedError',\n                INUSE_ATTRIBUTE_ERR: 'InUseAttributeError',\n                INVALID_STATE_ERR: 'InvalidStateError',\n                SYNTAX_ERR: 'SyntaxError',\n                INVALID_MODIFICATION_ERR: 'InvalidModificationError',\n                NAMESPACE_ERR: 'NamespaceError',\n                INVALID_ACCESS_ERR: 'InvalidAccessError',\n                TYPE_MISMATCH_ERR: 'TypeMismatchError',\n                SECURITY_ERR: 'SecurityError',\n                NETWORK_ERR: 'NetworkError',\n                ABORT_ERR: 'AbortError',\n                URL_MISMATCH_ERR: 'URLMismatchError',\n                QUOTA_EXCEEDED_ERR: 'QuotaExceededError',\n                TIMEOUT_ERR: 'TimeoutError',\n                INVALID_NODE_TYPE_ERR: 'InvalidNodeTypeError',\n                DATA_CLONE_ERR: 'DataCloneError'\n            };\n\n            var name_code_map = {\n                IndexSizeError: 1,\n                HierarchyRequestError: 3,\n                WrongDocumentError: 4,\n                InvalidCharacterError: 5,\n                NoModificationAllowedError: 7,\n                NotFoundError: 8,\n                NotSupportedError: 9,\n                InUseAttributeError: 10,\n                InvalidStateError: 11,\n                SyntaxError: 12,\n                InvalidModificationError: 13,\n                NamespaceError: 14,\n                InvalidAccessError: 15,\n                TypeMismatchError: 17,\n                SecurityError: 18,\n                NetworkError: 19,\n                AbortError: 20,\n                URLMismatchError: 21,\n                QuotaExceededError: 22,\n                TimeoutError: 23,\n                InvalidNodeTypeError: 24,\n                DataCloneError: 25,\n\n                EncodingError: 0,\n                NotReadableError: 0,\n                UnknownError: 0,\n                ConstraintError: 0,\n                DataError: 0,\n                TransactionInactiveError: 0,\n                ReadOnlyError: 0,\n                VersionError: 0,\n                OperationError: 0,\n                NotAllowedError: 0,\n                OptOutError: 0\n            };\n\n            var code_name_map = {};\n            for (var key in name_code_map) {\n                if (name_code_map[key] > 0) {\n                    code_name_map[name_code_map[key]] = key;\n                }\n            }\n\n            var required_props = {};\n            var name;\n\n            if (typeof type === \"number\") {\n                if (type === 0) {\n                    throw new AssertionError('Test bug: ambiguous DOMException code 0 passed to assert_throws_dom()');\n                } else if (!(type in code_name_map)) {\n                    throw new AssertionError('Test bug: unrecognized DOMException code \"' + type + '\" passed to assert_throws_dom()');\n                }\n                name = code_name_map[type];\n                required_props.code = type;\n            } else if (typeof type === \"string\") {\n                name = type in codename_name_map ? codename_name_map[type] : type;\n                if (!(name in name_code_map)) {\n                    throw new AssertionError('Test bug: unrecognized DOMException code name or name \"' + type + '\" passed to assert_throws_dom()');\n                }\n\n                required_props.code = name_code_map[name];\n            }\n\n            if (required_props.code === 0 ||\n               (\"name\" in e &&\n                e.name !== e.name.toUpperCase() &&\n                e.name !== \"DOMException\")) {\n                // New style exception: also test the name property.\n                required_props.name = name;\n            }\n\n            for (var prop in required_props) {\n                assert(prop in e && e[prop] == required_props[prop],\n                       assertion_type, description,\n                       \"${func} threw ${e} that is not a DOMException \" + type + \": property ${prop} is equal to ${actual}, expected ${expected}\",\n                       {func:func, e:e, prop:prop, actual:e[prop], expected:required_props[prop]});\n            }\n\n            // Check that the exception is from the right global.  This check is last\n            // so more specific, and more informative, checks on the properties can\n            // happen in case a totally incorrect exception is thrown.\n            assert(e.constructor === constructor,\n                   assertion_type, description,\n                   \"${func} threw an exception from the wrong global\",\n                   {func});\n\n        }\n    }\n\n    /**\n     * Assert the provided value is thrown.\n     *\n     * @param {value} exception The expected exception.\n     * @param {Function} func Function which should throw.\n     * @param {string} [description] Error description for the case that the error is not thrown.\n     */\n    function assert_throws_exactly(exception, func, description)\n    {\n        assert_throws_exactly_impl(exception, func, description,\n                                   \"assert_throws_exactly\");\n    }\n    expose_assert(assert_throws_exactly, \"assert_throws_exactly\");\n\n    /**\n     * Like assert_throws_exactly but allows specifying the assertion type\n     * (assert_throws_exactly or promise_rejects_exactly, in practice).\n     */\n    function assert_throws_exactly_impl(exception, func, description,\n                                        assertion_type)\n    {\n        try {\n            func.call(this);\n            assert(false, assertion_type, description,\n                   \"${func} did not throw\", {func:func});\n        } catch (e) {\n            if (e instanceof AssertionError) {\n                throw e;\n            }\n\n            assert(same_value(e, exception), assertion_type, description,\n                   \"${func} threw ${e} but we expected it to throw ${exception}\",\n                   {func:func, e:e, exception:exception});\n        }\n    }\n\n    /**\n     * Asserts if called. Used to ensure that a specific codepath is\n     * not taken e.g. that an error event isn't fired.\n     *\n     * @param {string} [description] - Description of the condition being tested.\n     */\n    function assert_unreached(description) {\n         assert(false, \"assert_unreached\", description,\n                \"Reached unreachable code\");\n    }\n    expose_assert(assert_unreached, \"assert_unreached\");\n\n    /**\n     * @callback AssertFunc\n     * @param {Any} actual\n     * @param {Any} expected\n     * @param {Any[]} args\n     */\n\n    /**\n     * Asserts that ``actual`` matches at least one value of ``expected``\n     * according to a comparison defined by ``assert_func``.\n     *\n     * Note that tests with multiple allowed pass conditions are bad\n     * practice unless the spec specifically allows multiple\n     * behaviours. Test authors should not use this method simply to\n     * hide UA bugs.\n     *\n     * @param {AssertFunc} assert_func - Function to compare actual\n     * and expected. It must throw when the comparison fails and\n     * return when the comparison passes.\n     * @param {Any} actual - Test value.\n     * @param {Array} expected_array - Array of possible expected values.\n     * @param {Any[]} args - Additional arguments to pass to ``assert_func``.\n     */\n    function assert_any(assert_func, actual, expected_array, ...args)\n    {\n        var errors = [];\n        var passed = false;\n        forEach(expected_array,\n                function(expected)\n                {\n                    try {\n                        assert_func.apply(this, [actual, expected].concat(args));\n                        passed = true;\n                    } catch (e) {\n                        errors.push(e.message);\n                    }\n                });\n        if (!passed) {\n            throw new AssertionError(errors.join(\"\\n\\n\"));\n        }\n    }\n    // FIXME: assert_any cannot use expose_assert, because assert_wrapper does\n    // not support nested assert calls (e.g. to assert_func). We need to\n    // support bypassing assert_wrapper for the inner asserts here.\n    expose(assert_any, \"assert_any\");\n\n    /**\n     * Assert that a feature is implemented, based on a 'truthy' condition.\n     *\n     * This function should be used to early-exit from tests in which there is\n     * no point continuing without support for a non-optional spec or spec\n     * feature. For example:\n     *\n     *     assert_implements(window.Foo, 'Foo is not supported');\n     *\n     * @param {object} condition The truthy value to test\n     * @param {string} [description] Error description for the case that the condition is not truthy.\n     */\n    function assert_implements(condition, description) {\n        assert(!!condition, \"assert_implements\", description);\n    }\n    expose_assert(assert_implements, \"assert_implements\")\n\n    /**\n     * Assert that an optional feature is implemented, based on a 'truthy' condition.\n     *\n     * This function should be used to early-exit from tests in which there is\n     * no point continuing without support for an explicitly optional spec or\n     * spec feature. For example:\n     *\n     *     assert_implements_optional(video.canPlayType(\"video/webm\"),\n     *                                \"webm video playback not supported\");\n     *\n     * @param {object} condition The truthy value to test\n     * @param {string} [description] Error description for the case that the condition is not truthy.\n     */\n    function assert_implements_optional(condition, description) {\n        if (!condition) {\n            throw new OptionalFeatureUnsupportedError(description);\n        }\n    }\n    expose_assert(assert_implements_optional, \"assert_implements_optional\");\n\n    /**\n     * @class\n     *\n     * A single subtest. A Test is not constructed directly but via the\n     * :js:func:`test`, :js:func:`async_test` or :js:func:`promise_test` functions.\n     *\n     * @param {string} name - This must be unique in a given file and must be\n     * invariant between runs.\n     *\n     */\n    function Test(name, properties)\n    {\n        if (tests.file_is_test && tests.tests.length) {\n            throw new Error(\"Tried to create a test with file_is_test\");\n        }\n        /** The test name. */\n        this.name = name;\n\n        this.phase = (tests.is_aborted || tests.phase === tests.phases.COMPLETE) ?\n            this.phases.COMPLETE : this.phases.INITIAL;\n\n        /** The test status code.*/\n        this.status = this.NOTRUN;\n        this.timeout_id = null;\n        this.index = null;\n\n        this.properties = properties || {};\n        this.timeout_length = settings.test_timeout;\n        if (this.timeout_length !== null) {\n            this.timeout_length *= tests.timeout_multiplier;\n        }\n\n        /** A message indicating the reason for test failure. */\n        this.message = null;\n        /** Stack trace in case of failure. */\n        this.stack = null;\n\n        this.steps = [];\n        this._is_promise_test = false;\n\n        this.cleanup_callbacks = [];\n        this._user_defined_cleanup_count = 0;\n        this._done_callbacks = [];\n\n        if (typeof AbortController === \"function\") {\n            this._abortController = new AbortController();\n        }\n\n        // Tests declared following harness completion are likely an indication\n        // of a programming error, but they cannot be reported\n        // deterministically.\n        if (tests.phase === tests.phases.COMPLETE) {\n            return;\n        }\n\n        tests.push(this);\n    }\n\n    /**\n     * Enum of possible test statuses.\n     *\n     * :values:\n     *   - ``PASS``\n     *   - ``FAIL``\n     *   - ``TIMEOUT``\n     *   - ``NOTRUN``\n     *   - ``PRECONDITION_FAILED``\n     */\n    Test.statuses = {\n        PASS:0,\n        FAIL:1,\n        TIMEOUT:2,\n        NOTRUN:3,\n        PRECONDITION_FAILED:4\n    };\n\n    Test.prototype = merge({}, Test.statuses);\n\n    Test.prototype.phases = {\n        INITIAL:0,\n        STARTED:1,\n        HAS_RESULT:2,\n        CLEANING:3,\n        COMPLETE:4\n    };\n\n    Test.prototype.status_formats = {\n        0: \"Pass\",\n        1: \"Fail\",\n        2: \"Timeout\",\n        3: \"Not Run\",\n        4: \"Optional Feature Unsupported\",\n    }\n\n    Test.prototype.format_status = function() {\n        return this.status_formats[this.status];\n    }\n\n    Test.prototype.structured_clone = function()\n    {\n        if (!this._structured_clone) {\n            var msg = this.message;\n            msg = msg ? String(msg) : msg;\n            this._structured_clone = merge({\n                name:String(this.name),\n                properties:merge({}, this.properties),\n                phases:merge({}, this.phases)\n            }, Test.statuses);\n        }\n        this._structured_clone.status = this.status;\n        this._structured_clone.message = this.message;\n        this._structured_clone.stack = this.stack;\n        this._structured_clone.index = this.index;\n        this._structured_clone.phase = this.phase;\n        return this._structured_clone;\n    };\n\n    /**\n     * Run a single step of an ongoing test.\n     *\n     * @param {string} func - Callback function to run as a step. If\n     * this throws an :js:func:`AssertionError`, or any other\n     * exception, the :js:class:`Test` status is set to ``FAIL``.\n     * @param {Object} [this_obj] - The object to use as the this\n     * value when calling ``func``. Defaults to the  :js:class:`Test` object.\n     */\n    Test.prototype.step = function(func, this_obj)\n    {\n        if (this.phase > this.phases.STARTED) {\n            return;\n        }\n\n        if (this.phase !== this.phases.STARTED) {\n            console.log(`[${Date.now()}] prototype.step START`)\n            window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"START\", content: {'isSecure': window.isSecureContext, 'wid': window.__id__, 'name': this.name}, ts: Date.now()}}))\n            console.log(\"LOG\", window)\n        }\n\n        if (settings.debug && this.phase !== this.phases.STARTED) {\n            console.log(\"TEST START\", this.name);\n        }\n        this.phase = this.phases.STARTED;\n        //If we don't get a result before the harness times out that will be a test timeout\n        this.set_status(this.TIMEOUT, \"Test timed out\");\n\n        tests.started = true;\n        tests.current_test = this;\n        tests.notify_test_state(this);\n\n        if (this.timeout_id === null) {\n            this.set_timeout();\n        }\n\n        this.steps.push(func);\n\n        if (arguments.length === 1) {\n            this_obj = this;\n        }\n\n        if (settings.debug) {\n            console.debug(\"TEST STEP\", this.name);\n        }\n\n        try {\n            return func.apply(this_obj, Array.prototype.slice.call(arguments, 2));\n        } catch (e) {\n            if (this.phase >= this.phases.HAS_RESULT) {\n                return;\n            }\n            var status = e instanceof OptionalFeatureUnsupportedError ? this.PRECONDITION_FAILED : this.FAIL;\n            var message = String((typeof e === \"object\" && e !== null) ? e.message : e);\n            var stack = e.stack ? e.stack : null;\n\n            this.set_status(status, message, stack);\n            this.phase = this.phases.HAS_RESULT;\n            this.done();\n        } finally {\n            this.current_test = null;\n        }\n    };\n\n    /**\n     * Wrap a function so that it runs as a step of the current test.\n     *\n     * This allows creating a callback function that will run as a\n     * test step.\n     *\n     * @example\n     * let t = async_test(\"Example\");\n     * onload = t.step_func(e => {\n     *   assert_equals(e.name, \"load\");\n     *   // Mark the test as complete.\n     *   t.done();\n     * })\n     *\n     * @param {string} func - Function to run as a step. If this\n     * throws an :js:func:`AssertionError`, or any other exception,\n     * the :js:class:`Test` status is set to ``FAIL``.\n     * @param {Object} [this_obj] - The object to use as the this\n     * value when calling ``func``. Defaults to the :js:class:`Test` object.\n     */\n    Test.prototype.step_func = function(func, this_obj)\n    {\n        var test_this = this;\n\n        if (arguments.length === 1) {\n            this_obj = test_this;\n        }\n\n        return function()\n        {\n            // console.log(\"ARGS\", arguments[0])Vjj\n            // console.log(\"ARGS2\", arguments)\n            // console.log(\"ARGS\", func.toString())\n            \n            var msg = {'isSecure': window.isSecureContext ,'orig': document.url, 'frame': frameElement, 'type': `Step`, 'args': [func.toString(), \"RESPONSE PLACEHOLDER\"]}\n            window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"EVENT\", content: msg, ts: Date.now()}}))\n\n            return test_this.step.apply(test_this, [func, this_obj].concat(\n                Array.prototype.slice.call(arguments)));\n        };\n    };\n\n    /**\n     * Wrap a function so that it runs as a step of the current test,\n     * and automatically marks the test as complete if the function\n     * returns without error.\n     *\n     * @param {string} func - Function to run as a step. If this\n     * throws an :js:func:`AssertionError`, or any other exception,\n     * the :js:class:`Test` status is set to ``FAIL``. If it returns\n     * without error the status is set to ``PASS``.\n     * @param {Object} [this_obj] - The object to use as the this\n     * value when calling `func`. Defaults to the :js:class:`Test` object.\n     */\n    Test.prototype.step_func_done = function(func, this_obj)\n    {\n        var test_this = this;\n\n        if (arguments.length === 1) {\n            this_obj = test_this;\n        }\n\n        return function()\n        {\n            if (func) {\n                test_this.step.apply(test_this, [func, this_obj].concat(\n                    Array.prototype.slice.call(arguments)));\n            }\n            test_this.done();\n        };\n    };\n\n    /**\n     * Return a function that automatically sets the current test to\n     * ``FAIL`` if it's called.\n     *\n     * @param {string} [description] - Error message to add to assert\n     * in case of failure.\n     *\n     */\n    Test.prototype.unreached_func = function(description)\n    {\n        return this.step_func(function() {\n            assert_unreached(description);\n        });\n    };\n\n    /**\n     * Run a function as a step of the test after a given timeout.\n     *\n     * This multiplies the timeout by the global timeout multiplier to\n     * account for the expected execution speed of the current test\n     * environment. For example ``test.step_timeout(f, 2000)`` with a\n     * timeout multiplier of 2 will wait for 4000ms before calling ``f``.\n     *\n     * In general it's encouraged to use :js:func:`Test.step_wait` or\n     * :js:func:`step_wait_func` in preference to this function where possible,\n     * as they provide better test performance.\n     *\n     * @param {Function} func - Function to run as a test\n     * step.\n     * @param {number} timeout - Time in ms to wait before running the\n     * test step. The actual wait time is ``timeout`` x\n     * ``timeout_multiplier``.\n     *\n     */\n    Test.prototype.step_timeout = function(func, timeout) {\n        var test_this = this;\n        var args = Array.prototype.slice.call(arguments, 2);\n        return setTimeout(this.step_func(function() {\n            return func.apply(test_this, args);\n        }), timeout * tests.timeout_multiplier);\n    };\n\n    /**\n     * Poll for a function to return true, and call a callback\n     * function once it does, or assert if a timeout is\n     * reached. This is preferred over a simple step_timeout\n     * whenever possible since it allows the timeout to be longer\n     * to reduce intermittents without compromising test execution\n     * speed when the condition is quickly met.\n     *\n     * @param {Function} cond A function taking no arguments and\n     *                        returning a boolean. The callback is called\n     *                        when this function returns true.\n     * @param {Function} func A function taking no arguments to call once\n     *                        the condition is met.\n     * @param {string} [description] Error message to add to assert in case of\n     *                               failure.\n     * @param {number} timeout Timeout in ms. This is multiplied by the global\n     *                         timeout_multiplier\n     * @param {number} interval Polling interval in ms\n     *\n     */\n    Test.prototype.step_wait_func = function(cond, func, description,\n                                             timeout=3000, interval=100) {\n        var timeout_full = timeout * tests.timeout_multiplier;\n        var remaining = Math.ceil(timeout_full / interval);\n        var test_this = this;\n\n        var wait_for_inner = test_this.step_func(() => {\n            if (cond()) {\n                func();\n            } else {\n                if(remaining === 0) {\n                    assert(false, \"step_wait_func\", description,\n                           \"Timed out waiting on condition\");\n                }\n                remaining--;\n                setTimeout(wait_for_inner, interval);\n            }\n        });\n\n        wait_for_inner();\n    };\n\n    /**\n     * Poll for a function to return true, and invoke a callback\n     * followed by this.done() once it does, or assert if a timeout\n     * is reached. This is preferred over a simple step_timeout\n     * whenever possible since it allows the timeout to be longer\n     * to reduce intermittents without compromising test execution speed\n     * when the condition is quickly met.\n     *\n     * @example\n     * async_test(t => {\n     *  const popup = window.open(\"resources/coop-coep.py?coop=same-origin&coep=&navigate=about:blank\");\n     *  t.add_cleanup(() => popup.close());\n     *  assert_equals(window, popup.opener);\n     *\n     *  popup.onload = t.step_func(() => {\n     *    assert_true(popup.location.href.endsWith(\"&navigate=about:blank\"));\n     *    // Use step_wait_func_done as about:blank cannot message back.\n     *    t.step_wait_func_done(() => popup.location.href === \"about:blank\");\n     *  });\n     * }, \"Navigating a popup to about:blank\");\n     *\n     * @param {Function} cond A function taking no arguments and\n     *                        returning a boolean. The callback is called\n     *                        when this function returns true.\n     * @param {Function} func A function taking no arguments to call once\n     *                        the condition is met.\n     * @param {string} [description] Error message to add to assert in case of\n     *                               failure.\n     * @param {number} timeout Timeout in ms. This is multiplied by the global\n     *                         timeout_multiplier\n     * @param {number} interval Polling interval in ms\n     *\n     */\n    Test.prototype.step_wait_func_done = function(cond, func, description,\n                                                  timeout=3000, interval=100) {\n         this.step_wait_func(cond, () => {\n            if (func) {\n                func();\n            }\n            this.done();\n         }, description, timeout, interval);\n    };\n\n    /**\n     * Poll for a function to return true, and resolve a promise\n     * once it does, or assert if a timeout is reached. This is\n     * preferred over a simple step_timeout whenever possible\n     * since it allows the timeout to be longer to reduce\n     * intermittents without compromising test execution speed\n     * when the condition is quickly met.\n     *\n     * @example\n     * promise_test(async t => {\n     *  // â¦\n     * await t.step_wait(() => frame.contentDocument === null, \"Frame navigated to a cross-origin document\");\n     * // â¦\n     * }, \"\");\n     *\n     * @param {Function} cond A function taking no arguments and\n     *                        returning a boolean.\n     * @param {string} [description] Error message to add to assert in case of\n     *                              failure.\n     * @param {number} timeout Timeout in ms. This is multiplied by the global\n     *                         timeout_multiplier\n     * @param {number} interval Polling interval in ms\n     * @returns {Promise} Promise resolved once cond is met.\n     *\n     */\n    Test.prototype.step_wait = function(cond, description, timeout=3000, interval=100) {\n        return new Promise(resolve => {\n            this.step_wait_func(cond, resolve, description, timeout, interval);\n        });\n    }\n\n    /*\n     * Private method for registering cleanup functions. `testharness.js`\n     * internals should use this method instead of the public `add_cleanup`\n     * method in order to hide implementation details from the harness status\n     * message in the case errors.\n     */\n    Test.prototype._add_cleanup = function(callback) {\n        this.cleanup_callbacks.push(callback);\n    };\n\n    /**\n     * Schedule a function to be run after the test result is known, regardless\n     * of passing or failing state.\n     *\n     * The behavior of this function will not\n     * influence the result of the test, but if an exception is thrown, the\n     * test harness will report an error.\n     *\n     * @param {Function} callback - The cleanup function to run. This\n     * is called with no arguments.\n     */\n    Test.prototype.add_cleanup = function(callback) {\n        this._user_defined_cleanup_count += 1;\n        this._add_cleanup(callback);\n    };\n\n    Test.prototype.set_timeout = function()\n    {\n        if (this.timeout_length !== null) {\n            var this_obj = this;\n            this.timeout_id = setTimeout(function()\n                                         {\n                                             this_obj.timeout();\n                                         }, this.timeout_length);\n        }\n    };\n\n    Test.prototype.set_status = function(status, message, stack)\n    {\n        this.status = status;\n        this.message = message;\n        this.stack = stack ? stack : null;\n    };\n\n    /**\n     * Manually set the test status to ``TIMEOUT``.\n     */\n    Test.prototype.timeout = function()\n    {\n        this.timeout_id = null;\n        this.set_status(this.TIMEOUT, \"Test timed out\");\n        this.phase = this.phases.HAS_RESULT;\n        this.done();\n    };\n\n    /**\n     * Manually set the test status to ``TIMEOUT``.\n     *\n     * Alias for `Test.timeout <#Test.timeout>`_.\n     */\n    Test.prototype.force_timeout = function() {\n        return this.timeout();\n    };\n\n    /**\n     * Mark the test as complete.\n     *\n     * This sets the test status to ``PASS`` if no other status was\n     * already recorded. Any subsequent attempts to run additional\n     * test steps will be ignored.\n     *\n     * After setting the test status any test cleanup functions will\n     * be run.\n     */\n    Test.prototype.done = function()\n    {\n        if (this.phase >= this.phases.CLEANING) {\n            return;\n        }\n\n        if (this.phase <= this.phases.STARTED) {\n            this.set_status(this.PASS, null);\n        }\n\n        if (global_scope.clearTimeout) {\n            clearTimeout(this.timeout_id);\n        }\n\n        if (settings.debug) {\n            console.log(\"TEST DONE\",\n                        this.status,\n                        this.name);\n        }\n\n        this.cleanup();\n    };\n\n    function add_test_done_callback(test, callback)\n    {\n        if (test.phase === test.phases.COMPLETE) {\n            callback();\n            return;\n        }\n\n        test._done_callbacks.push(callback);\n    }\n\n    /*\n     * Invoke all specified cleanup functions. If one or more produce an error,\n     * the context is in an unpredictable state, so all further testing should\n     * be cancelled.\n     */\n    Test.prototype.cleanup = function() {\n        for(let i = 0; i < 1000000; i++);\n        window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"END\", content: {'isSecure': window.isSecureContext, 'wid': window.__id__, 'name': this.name, 'status': !this.status}, ts: Date.now()}}))\n        var errors = [];\n        var bad_value_count = 0;\n        function on_error(e) {\n            errors.push(e);\n            // Abort tests immediately so that tests declared within subsequent\n            // cleanup functions are not run.\n            tests.abort();\n        }\n        var this_obj = this;\n        var results = [];\n\n        this.phase = this.phases.CLEANING;\n\n        if (this._abortController) {\n            this._abortController.abort(\"Test cleanup\");\n        }\n\n        forEach(this.cleanup_callbacks,\n                function(cleanup_callback) {\n                    var result;\n\n                    try {\n                        result = cleanup_callback();\n                    } catch (e) {\n                        on_error(e);\n                        return;\n                    }\n\n                    if (!is_valid_cleanup_result(this_obj, result)) {\n                        bad_value_count += 1;\n                        // Abort tests immediately so that tests declared\n                        // within subsequent cleanup functions are not run.\n                        tests.abort();\n                    }\n\n                    results.push(result);\n                });\n\n        if (!this._is_promise_test) {\n            cleanup_done(this_obj, errors, bad_value_count);\n        } else {\n            all_async(results,\n                      function(result, done) {\n                          if (result && typeof result.then === \"function\") {\n                              result\n                                  .then(null, on_error)\n                                  .then(done);\n                          } else {\n                              done();\n                          }\n                      },\n                      function() {\n                          cleanup_done(this_obj, errors, bad_value_count);\n                      });\n        }\n    };\n\n    /*\n     * Determine if the return value of a cleanup function is valid for a given\n     * test. Any test may return the value `undefined`. Tests created with\n     * `promise_test` may alternatively return \"thenable\" object values.\n     */\n    function is_valid_cleanup_result(test, result) {\n        if (result === undefined) {\n            return true;\n        }\n\n        if (test._is_promise_test) {\n            return result && typeof result.then === \"function\";\n        }\n\n        return false;\n    }\n\n    function cleanup_done(test, errors, bad_value_count) {\n        if (errors.length || bad_value_count) {\n            var total = test._user_defined_cleanup_count;\n\n            tests.status.status = tests.status.ERROR;\n            tests.status.stack = null;\n            tests.status.message = \"Test named '\" + test.name +\n                \"' specified \" + total +\n                \" 'cleanup' function\" + (total > 1 ? \"s\" : \"\");\n\n            if (errors.length) {\n                tests.status.message += \", and \" + errors.length + \" failed\";\n                tests.status.stack = ((typeof errors[0] === \"object\" &&\n                                       errors[0].hasOwnProperty(\"stack\")) ?\n                                      errors[0].stack : null);\n            }\n\n            if (bad_value_count) {\n                var type = test._is_promise_test ?\n                   \"non-thenable\" : \"non-undefined\";\n                tests.status.message += \", and \" + bad_value_count +\n                    \" returned a \" + type + \" value\";\n            }\n\n            tests.status.message += \".\";\n        }\n\n        test.phase = test.phases.COMPLETE;\n        tests.result(test);\n        forEach(test._done_callbacks,\n                function(callback) {\n                    callback();\n                });\n        test._done_callbacks.length = 0;\n    }\n\n    /**\n     * Gives an AbortSignal that will be aborted when the test finishes.\n     */\n    Test.prototype.get_signal = function() {\n        if (!this._abortController) {\n            throw new Error(\"AbortController is not supported in this browser\");\n        }\n        return this._abortController.signal;\n    }\n\n    /**\n     * A RemoteTest object mirrors a Test object on a remote worker. The\n     * associated RemoteWorker updates the RemoteTest object in response to\n     * received events. In turn, the RemoteTest object replicates these events\n     * on the local document. This allows listeners (test result reporting\n     * etc..) to transparently handle local and remote events.\n     */\n    function RemoteTest(clone) {\n        var this_obj = this;\n        Object.keys(clone).forEach(\n                function(key) {\n                    this_obj[key] = clone[key];\n                });\n        this.index = null;\n        this.phase = this.phases.INITIAL;\n        this.update_state_from(clone);\n        this._done_callbacks = [];\n        tests.push(this);\n    }\n\n    RemoteTest.prototype.structured_clone = function() {\n        var clone = {};\n        Object.keys(this).forEach(\n                (function(key) {\n                    var value = this[key];\n                    // `RemoteTest` instances are responsible for managing\n                    // their own \"done\" callback functions, so those functions\n                    // are not relevant in other execution contexts. Because of\n                    // this (and because Function values cannot be serialized\n                    // for cross-realm transmittance), the property should not\n                    // be considered when cloning instances.\n                    if (key === '_done_callbacks' ) {\n                        return;\n                    }\n\n                    if (typeof value === \"object\" && value !== null) {\n                        clone[key] = merge({}, value);\n                    } else {\n                        clone[key] = value;\n                    }\n                }).bind(this));\n        clone.phases = merge({}, this.phases);\n        return clone;\n    };\n\n    /**\n     * `RemoteTest` instances are objects which represent tests running in\n     * another realm. They do not define \"cleanup\" functions (if necessary,\n     * such functions are defined on the associated `Test` instance within the\n     * external realm). However, `RemoteTests` may have \"done\" callbacks (e.g.\n     * as attached by the `Tests` instance responsible for tracking the overall\n     * test status in the parent realm). The `cleanup` method delegates to\n     * `done` in order to ensure that such callbacks are invoked following the\n     * completion of the `RemoteTest`.\n     */\n    RemoteTest.prototype.cleanup = function() {\n        this.done();\n    };\n    RemoteTest.prototype.phases = Test.prototype.phases;\n    RemoteTest.prototype.update_state_from = function(clone) {\n        this.status = clone.status;\n        this.message = clone.message;\n        this.stack = clone.stack;\n        if (this.phase === this.phases.INITIAL) {\n            this.phase = this.phases.STARTED;\n        }\n    };\n    RemoteTest.prototype.done = function() {\n        this.phase = this.phases.COMPLETE;\n\n        forEach(this._done_callbacks,\n                function(callback) {\n                    callback();\n                });\n    }\n\n    RemoteTest.prototype.format_status = function() {\n        return Test.prototype.status_formats[this.status];\n    }\n\n    /*\n     * A RemoteContext listens for test events from a remote test context, such\n     * as another window or a worker. These events are then used to construct\n     * and maintain RemoteTest objects that mirror the tests running in the\n     * remote context.\n     *\n     * An optional third parameter can be used as a predicate to filter incoming\n     * MessageEvents.\n     */\n    function RemoteContext(remote, message_target, message_filter) {\n        this.running = true;\n        this.started = false;\n        this.tests = new Array();\n        this.early_exception = null;\n\n        var this_obj = this;\n        // If remote context is cross origin assigning to onerror is not\n        // possible, so silently catch those errors.\n        try {\n          remote.onerror = function(error) { this_obj.remote_error(error); };\n        } catch (e) {\n          // Ignore.\n        }\n\n        // Keeping a reference to the remote object and the message handler until\n        // remote_done() is seen prevents the remote object and its message channel\n        // from going away before all the messages are dispatched.\n        this.remote = remote;\n        this.message_target = message_target;\n        this.message_handler = function(message) {\n            var passesFilter = !message_filter || message_filter(message);\n            // The reference to the `running` property in the following\n            // condition is unnecessary because that value is only set to\n            // `false` after the `message_handler` function has been\n            // unsubscribed.\n            // TODO: Simplify the condition by removing the reference.\n            if (this_obj.running && message.data && passesFilter &&\n                (message.data.type in this_obj.message_handlers)) {\n                this_obj.message_handlers[message.data.type].call(this_obj, message.data);\n            }\n        };\n\n        if (self.Promise) {\n            this.done = new Promise(function(resolve) {\n                this_obj.doneResolve = resolve;\n            });\n        }\n\n        this.message_target.addEventListener(\"message\", this.message_handler);\n    }\n\n    RemoteContext.prototype.remote_error = function(error) {\n        if (error.preventDefault) {\n            error.preventDefault();\n        }\n\n        // Defer interpretation of errors until the testing protocol has\n        // started and the remote test's `allow_uncaught_exception` property\n        // is available.\n        if (!this.started) {\n            this.early_exception = error;\n        } else if (!this.allow_uncaught_exception) {\n            this.report_uncaught(error);\n        }\n    };\n\n    RemoteContext.prototype.report_uncaught = function(error) {\n        var message = error.message || String(error);\n        var filename = (error.filename ? \" \" + error.filename: \"\");\n        // FIXME: Display remote error states separately from main document\n        // error state.\n        tests.set_status(tests.status.ERROR,\n                         \"Error in remote\" + filename + \": \" + message,\n                         error.stack);\n    };\n\n    RemoteContext.prototype.start = function(data) {\n        this.started = true;\n        this.allow_uncaught_exception = data.properties.allow_uncaught_exception;\n\n        if (this.early_exception && !this.allow_uncaught_exception) {\n            this.report_uncaught(this.early_exception);\n        }\n    };\n\n    RemoteContext.prototype.test_state = function(data) {\n        var remote_test = this.tests[data.test.index];\n        if (!remote_test) {\n            remote_test = new RemoteTest(data.test);\n            this.tests[data.test.index] = remote_test;\n        }\n        remote_test.update_state_from(data.test);\n        tests.notify_test_state(remote_test);\n    };\n\n    RemoteContext.prototype.test_done = function(data) {\n        var remote_test = this.tests[data.test.index];\n        remote_test.update_state_from(data.test);\n        remote_test.done();\n        tests.result(remote_test);\n    };\n\n    RemoteContext.prototype.remote_done = function(data) {\n        if (tests.status.status === null &&\n            data.status.status !== data.status.OK) {\n            tests.set_status(data.status.status, data.status.message, data.status.stack);\n        }\n\n        for (let assert of data.asserts) {\n            var record = new AssertRecord();\n            record.assert_name = assert.assert_name;\n            record.args = assert.args;\n            record.test = assert.test != null ? this.tests[assert.test.index] : null;\n            record.status = assert.status;\n            record.stack = assert.stack;\n            tests.asserts_run.push(record);\n        }\n\n        this.message_target.removeEventListener(\"message\", this.message_handler);\n        this.running = false;\n\n        // If remote context is cross origin assigning to onerror is not\n        // possible, so silently catch those errors.\n        try {\n          this.remote.onerror = null;\n        } catch (e) {\n          // Ignore.\n        }\n\n        this.remote = null;\n        this.message_target = null;\n        if (this.doneResolve) {\n            this.doneResolve();\n        }\n\n        if (tests.all_done()) {\n            tests.complete();\n        }\n    };\n\n    RemoteContext.prototype.message_handlers = {\n        start: RemoteContext.prototype.start,\n        test_state: RemoteContext.prototype.test_state,\n        result: RemoteContext.prototype.test_done,\n        complete: RemoteContext.prototype.remote_done\n    };\n\n    /**\n     * @class\n     * Status of the overall harness\n     */\n    function TestsStatus()\n    {\n        /** The status code */\n        this.status = null;\n        /** Message in case of failure */\n        this.message = null;\n        /** Stack trace in case of an exception. */\n        this.stack = null;\n    }\n\n    /**\n     * Enum of possible harness statuses.\n     *\n     * :values:\n     *   - ``OK``\n     *   - ``ERROR``\n     *   - ``TIMEOUT``\n     *   - ``PRECONDITION_FAILED``\n     */\n    TestsStatus.statuses = {\n        OK:0,\n        ERROR:1,\n        TIMEOUT:2,\n        PRECONDITION_FAILED:3\n    };\n\n    TestsStatus.prototype = merge({}, TestsStatus.statuses);\n\n    TestsStatus.prototype.formats = {\n        0: \"OK\",\n        1: \"Error\",\n        2: \"Timeout\",\n        3: \"Optional Feature Unsupported\"\n    };\n\n    TestsStatus.prototype.structured_clone = function()\n    {\n        if (!this._structured_clone) {\n            var msg = this.message;\n            msg = msg ? String(msg) : msg;\n            this._structured_clone = merge({\n                status:this.status,\n                message:msg,\n                stack:this.stack\n            }, TestsStatus.statuses);\n        }\n        return this._structured_clone;\n    };\n\n    TestsStatus.prototype.format_status = function() {\n        return this.formats[this.status];\n    };\n\n    /**\n     * @class\n     * Record of an assert that ran.\n     *\n     * @param {Test} test - The test which ran the assert.\n     * @param {string} assert_name - The function name of the assert.\n     * @param {Any} args - The arguments passed to the assert function.\n     */\n    function AssertRecord(test, assert_name, args = []) {\n        /** Name of the assert that ran */\n        this.assert_name = assert_name;\n        /** Test that ran the assert */\n        this.test = test;\n        // Avoid keeping complex objects alive\n        /** Stringification of the arguments that were passed to the assert function */\n        this.args = args.map(x => format_value(x).replace(/\\n/g, \" \"));\n        /** Status of the assert */\n        this.status = null;\n    }\n\n    AssertRecord.prototype.structured_clone = function() {\n        return {\n            assert_name: this.assert_name,\n            test: this.test ? this.test.structured_clone() : null,\n            args: this.args,\n            status: this.status,\n        };\n    };\n\n    function Tests()\n    {\n        this.tests = [];\n        this.num_pending = 0;\n\n        this.phases = {\n            INITIAL:0,\n            SETUP:1,\n            HAVE_TESTS:2,\n            HAVE_RESULTS:3,\n            COMPLETE:4\n        };\n        this.phase = this.phases.INITIAL;\n\n        this.properties = {};\n\n        this.wait_for_finish = false;\n        this.processing_callbacks = false;\n\n        this.allow_uncaught_exception = false;\n\n        this.file_is_test = false;\n        // This value is lazily initialized in order to avoid introducing a\n        // dependency on ECMAScript 2015 Promises to all tests.\n        this.promise_tests = null;\n        this.promise_setup_called = false;\n\n        this.timeout_multiplier = 1;\n        this.timeout_length = test_environment.test_timeout();\n        this.timeout_id = null;\n\n        this.start_callbacks = [];\n        this.test_state_callbacks = [];\n        this.test_done_callbacks = [];\n        this.all_done_callbacks = [];\n\n        this.hide_test_state = false;\n        this.pending_remotes = [];\n\n        this.current_test = null;\n        this.asserts_run = [];\n\n        // Track whether output is enabled, and thus whether or not we should\n        // track asserts.\n        //\n        // On workers we don't get properties set from testharnessreport.js, so\n        // we don't know whether or not to track asserts. To avoid the\n        // resulting performance hit, we assume we are not meant to. This means\n        // that assert tracking does not function on workers.\n        this.output = settings.output && 'document' in global_scope;\n\n        this.status = new TestsStatus();\n\n        var this_obj = this;\n\n        test_environment.add_on_loaded_callback(function() {\n            if (this_obj.all_done()) {\n                this_obj.complete();\n            }\n        });\n\n        this.set_timeout();\n    }\n\n    Tests.prototype.setup = function(func, properties)\n    {\n        if (this.phase >= this.phases.HAVE_RESULTS) {\n            return;\n        }\n\n        if (this.phase < this.phases.SETUP) {\n            this.phase = this.phases.SETUP;\n        }\n\n        this.properties = properties;\n\n        for (var p in properties) {\n            if (properties.hasOwnProperty(p)) {\n                var value = properties[p];\n                if (p == \"allow_uncaught_exception\") {\n                    this.allow_uncaught_exception = value;\n                } else if (p == \"explicit_done\" && value) {\n                    this.wait_for_finish = true;\n                } else if (p == \"explicit_timeout\" && value) {\n                    this.timeout_length = null;\n                    if (this.timeout_id)\n                    {\n                        clearTimeout(this.timeout_id);\n                    }\n                } else if (p == \"single_test\" && value) {\n                    this.set_file_is_test();\n                } else if (p == \"timeout_multiplier\") {\n                    this.timeout_multiplier = value;\n                    if (this.timeout_length) {\n                         this.timeout_length *= this.timeout_multiplier;\n                    }\n                } else if (p == \"hide_test_state\") {\n                    this.hide_test_state = value;\n                } else if (p == \"output\") {\n                    this.output = value;\n                } else if (p === \"debug\") {\n                    settings.debug = value;\n                }\n            }\n        }\n\n        if (func) {\n            try {\n                func();\n            } catch (e) {\n                this.status.status = e instanceof OptionalFeatureUnsupportedError ? this.status.PRECONDITION_FAILED : this.status.ERROR;\n                this.status.message = String(e);\n                this.status.stack = e.stack ? e.stack : null;\n                this.complete();\n            }\n        }\n        this.set_timeout();\n    };\n\n    Tests.prototype.set_file_is_test = function() {\n        if (this.tests.length > 0) {\n            throw new Error(\"Tried to set file as test after creating a test\");\n        }\n        this.wait_for_finish = true;\n        this.file_is_test = true;\n        // Create the test, which will add it to the list of tests\n        tests.current_test = async_test();\n    };\n\n    Tests.prototype.set_status = function(status, message, stack)\n    {\n        this.status.status = status;\n        this.status.message = message;\n        this.status.stack = stack ? stack : null;\n    };\n\n    Tests.prototype.set_timeout = function() {\n        if (global_scope.clearTimeout) {\n            var this_obj = this;\n            clearTimeout(this.timeout_id);\n            if (this.timeout_length !== null) {\n                this.timeout_id = setTimeout(function() {\n                                                 this_obj.timeout();\n                                             }, this.timeout_length);\n            }\n        }\n    };\n\n    Tests.prototype.timeout = function() {\n        var test_in_cleanup = null;\n\n        if (this.status.status === null) {\n            forEach(this.tests,\n                    function(test) {\n                        // No more than one test is expected to be in the\n                        // \"CLEANUP\" phase at any time\n                        if (test.phase === test.phases.CLEANING) {\n                            test_in_cleanup = test;\n                        }\n\n                        test.phase = test.phases.COMPLETE;\n                    });\n\n            // Timeouts that occur while a test is in the \"cleanup\" phase\n            // indicate that some global state was not properly reverted. This\n            // invalidates the overall test execution, so the timeout should be\n            // reported as an error and cancel the execution of any remaining\n            // tests.\n            if (test_in_cleanup) {\n                this.status.status = this.status.ERROR;\n                this.status.message = \"Timeout while running cleanup for \" +\n                    \"test named \\\"\" + test_in_cleanup.name + \"\\\".\";\n                tests.status.stack = null;\n            } else {\n                this.status.status = this.status.TIMEOUT;\n            }\n        }\n\n        this.complete();\n    };\n\n    Tests.prototype.end_wait = function()\n    {\n        this.wait_for_finish = false;\n        if (this.all_done()) {\n            this.complete();\n        }\n    };\n\n    Tests.prototype.push = function(test)\n    {\n        if (this.phase < this.phases.HAVE_TESTS) {\n            this.start();\n        }\n        this.num_pending++;\n        test.index = this.tests.push(test);\n        this.notify_test_state(test);\n    };\n\n    Tests.prototype.notify_test_state = function(test) {\n        var this_obj = this;\n        forEach(this.test_state_callbacks,\n                function(callback) {\n                    callback(test, this_obj);\n                });\n    };\n\n    Tests.prototype.all_done = function() {\n        return (this.tests.length > 0 || this.pending_remotes.length > 0) &&\n                test_environment.all_loaded &&\n                (this.num_pending === 0 || this.is_aborted) && !this.wait_for_finish &&\n                !this.processing_callbacks &&\n                !this.pending_remotes.some(function(w) { return w.running; });\n    };\n\n    Tests.prototype.start = function() {\n        this.phase = this.phases.HAVE_TESTS;\n        this.notify_start();\n    };\n\n    Tests.prototype.notify_start = function() {\n        var this_obj = this;\n        forEach (this.start_callbacks,\n                 function(callback)\n                 {\n                     callback(this_obj.properties);\n                 });\n    };\n\n    Tests.prototype.result = function(test)\n    {\n        // If the harness has already transitioned beyond the `HAVE_RESULTS`\n        // phase, subsequent tests should not cause it to revert.\n        if (this.phase <= this.phases.HAVE_RESULTS) {\n            this.phase = this.phases.HAVE_RESULTS;\n        }\n        this.num_pending--;\n        this.notify_result(test);\n    };\n\n    Tests.prototype.notify_result = function(test) {\n        var this_obj = this;\n        this.processing_callbacks = true;\n        forEach(this.test_done_callbacks,\n                function(callback)\n                {\n                    callback(test, this_obj);\n                });\n        this.processing_callbacks = false;\n        if (this_obj.all_done()) {\n            this_obj.complete();\n        }\n    };\n\n    Tests.prototype.complete = function() {\n        if (this.phase === this.phases.COMPLETE) {\n            return;\n        }\n        var this_obj = this;\n        var all_complete = function() {\n            this_obj.phase = this_obj.phases.COMPLETE;\n            this_obj.notify_complete();\n        };\n        var incomplete = filter(this.tests,\n                                function(test) {\n                                    return test.phase < test.phases.COMPLETE;\n                                });\n\n        /**\n         * To preserve legacy behavior, overall test completion must be\n         * signaled synchronously.\n         */\n        if (incomplete.length === 0) {\n            all_complete();\n            return;\n        }\n\n        all_async(incomplete,\n                  function(test, testDone)\n                  {\n                      if (test.phase === test.phases.INITIAL) {\n                          test.phase = test.phases.COMPLETE;\n                          testDone();\n                      } else {\n                          add_test_done_callback(test, testDone);\n                          test.cleanup();\n                      }\n                  },\n                  all_complete);\n    };\n\n    Tests.prototype.set_assert = function(assert_name, args) {\n        this.asserts_run.push(new AssertRecord(this.current_test, assert_name, args))\n    }\n\n    Tests.prototype.set_assert_status = function(status, stack) {\n        let assert_record = this.asserts_run[this.asserts_run.length - 1];\n        assert_record.status = status;\n        assert_record.stack = stack;\n    }\n\n    /**\n     * Update the harness status to reflect an unrecoverable harness error that\n     * should cancel all further testing. Update all previously-defined tests\n     * which have not yet started to indicate that they will not be executed.\n     */\n    Tests.prototype.abort = function() {\n        this.status.status = this.status.ERROR;\n        this.is_aborted = true;\n\n        forEach(this.tests,\n                function(test) {\n                    if (test.phase === test.phases.INITIAL) {\n                        test.phase = test.phases.COMPLETE;\n                    }\n                });\n    };\n\n    /*\n     * Determine if any tests share the same `name` property. Return an array\n     * containing the names of any such duplicates.\n     */\n    Tests.prototype.find_duplicates = function() {\n        var names = Object.create(null);\n        var duplicates = [];\n\n        forEach (this.tests,\n                 function(test)\n                 {\n                     if (test.name in names && duplicates.indexOf(test.name) === -1) {\n                        duplicates.push(test.name);\n                     }\n                     names[test.name] = true;\n                 });\n\n        return duplicates;\n    };\n\n    function code_unit_str(char) {\n        return 'U+' + char.charCodeAt(0).toString(16);\n    }\n\n    function sanitize_unpaired_surrogates(str) {\n        return str.replace(\n            /([\\ud800-\\udbff]+)(?![\\udc00-\\udfff])|(^|[^\\ud800-\\udbff])([\\udc00-\\udfff]+)/g,\n            function(_, low, prefix, high) {\n                var output = prefix || \"\";  // prefix may be undefined\n                var string = low || high;  // only one of these alternates can match\n                for (var i = 0; i < string.length; i++) {\n                    output += code_unit_str(string[i]);\n                }\n                return output;\n            });\n    }\n\n    function sanitize_all_unpaired_surrogates(tests) {\n        forEach (tests,\n                 function (test)\n                 {\n                     var sanitized = sanitize_unpaired_surrogates(test.name);\n\n                     if (test.name !== sanitized) {\n                         test.name = sanitized;\n                         delete test._structured_clone;\n                     }\n                 });\n    }\n\n    Tests.prototype.notify_complete = function() {\n        var this_obj = this;\n        var duplicates;\n\n        if (this.status.status === null) {\n            duplicates = this.find_duplicates();\n\n            // Some transports adhere to UTF-8's restriction on unpaired\n            // surrogates. Sanitize the titles so that the results can be\n            // consistently sent via all transports.\n            sanitize_all_unpaired_surrogates(this.tests);\n\n            // Test names are presumed to be unique within test files--this\n            // allows consumers to use them for identification purposes.\n            // Duplicated names violate this expectation and should therefore\n            // be reported as an error.\n            if (duplicates.length) {\n                this.status.status = this.status.ERROR;\n                this.status.message =\n                   duplicates.length + ' duplicate test name' +\n                   (duplicates.length > 1 ? 's' : '') + ': \"' +\n                   duplicates.join('\", \"') + '\"';\n            } else {\n                this.status.status = this.status.OK;\n            }\n        }\n\n        forEach (this.all_done_callbacks,\n                 function(callback)\n                 {\n                     callback(this_obj.tests, this_obj.status, this_obj.asserts_run);\n                 });\n    };\n\n    /*\n     * Constructs a RemoteContext that tracks tests from a specific worker.\n     */\n    Tests.prototype.create_remote_worker = function(worker) {\n        var message_port;\n\n        if (is_service_worker(worker)) {\n            message_port = navigator.serviceWorker;\n            worker.postMessage({type: \"connect\"});\n        } else if (is_shared_worker(worker)) {\n            message_port = worker.port;\n            message_port.start();\n        } else {\n            message_port = worker;\n        }\n\n        return new RemoteContext(worker, message_port);\n    };\n\n    /*\n     * Constructs a RemoteContext that tracks tests from a specific window.\n     */\n    Tests.prototype.create_remote_window = function(remote) {\n        remote.postMessage({type: \"getmessages\"}, \"*\");\n        return new RemoteContext(\n            remote,\n            window,\n            function(msg) {\n                return msg.source === remote;\n            }\n        );\n    };\n\n    Tests.prototype.fetch_tests_from_worker = function(worker) {\n        if (this.phase >= this.phases.COMPLETE) {\n            return;\n        }\n\n        var remoteContext = this.create_remote_worker(worker);\n        this.pending_remotes.push(remoteContext);\n        return remoteContext.done;\n    };\n\n    /**\n     * Get test results from a worker and include them in the current test.\n     *\n     * @param {Worker|SharedWorker|ServiceWorker|MessagePort} port -\n     * Either a worker object or a port connected to a worker which is\n     * running tests..\n     * @returns {Promise} - A promise that's resolved once all the remote tests are complete.\n     */\n    function fetch_tests_from_worker(port) {\n        return tests.fetch_tests_from_worker(port);\n    }\n    expose(fetch_tests_from_worker, 'fetch_tests_from_worker');\n\n    Tests.prototype.fetch_tests_from_window = function(remote) {\n        if (this.phase >= this.phases.COMPLETE) {\n            return;\n        }\n\n        var remoteContext = this.create_remote_window(remote);\n        this.pending_remotes.push(remoteContext);\n        return remoteContext.done;\n    };\n\n    /**\n     * Aggregate tests from separate windows or iframes\n     * into the current document as if they were all part of the same test file.\n     *\n     * The document of the second window (or iframe) should include\n     * ``testharness.js``, but not ``testharnessreport.js``, and use\n     * :js:func:`test`, :js:func:`async_test`, and :js:func:`promise_test` in\n     * the usual manner.\n     *\n     * @param {Window} window - The window to fetch tests from.\n     */\n    function fetch_tests_from_window(window) {\n        return tests.fetch_tests_from_window(window);\n    }\n    expose(fetch_tests_from_window, 'fetch_tests_from_window');\n\n    /**\n     * Get test results from a shadow realm and include them in the current test.\n     *\n     * @param {ShadowRealm} realm - A shadow realm also running the test harness\n     * @returns {Promise} - A promise that's resolved once all the remote tests are complete.\n     */\n    function fetch_tests_from_shadow_realm(realm) {\n        var chan = new MessageChannel();\n        function receiveMessage(msg_json) {\n            chan.port1.postMessage(JSON.parse(msg_json));\n        }\n        var done = tests.fetch_tests_from_worker(chan.port2);\n        realm.evaluate(\"begin_shadow_realm_tests\")(receiveMessage);\n        chan.port2.start();\n        return done;\n    }\n    expose(fetch_tests_from_shadow_realm, 'fetch_tests_from_shadow_realm');\n\n    /**\n     * Begin running tests in this shadow realm test harness.\n     *\n     * To be called after all tests have been loaded; it is an error to call\n     * this more than once or in a non-Shadow Realm environment\n     *\n     * @param {Function} postMessage - A function to send test updates to the\n     * incubating realm-- accepts JSON-encoded messages in the format used by\n     * RemoteContext\n     */\n    function begin_shadow_realm_tests(postMessage) {\n        if (!(test_environment instanceof ShadowRealmTestEnvironment)) {\n            throw new Error(\"begin_shadow_realm_tests called in non-Shadow Realm environment\");\n        }\n\n        test_environment.begin(function (msg) {\n            postMessage(JSON.stringify(msg));\n        });\n    }\n    expose(begin_shadow_realm_tests, 'begin_shadow_realm_tests');\n\n    /**\n     * Timeout the tests.\n     *\n     * This only has an effect when ``explicit_timeout`` has been set\n     * in :js:func:`setup`. In other cases any call is a no-op.\n     *\n     */\n    function timeout() {\n        if (tests.timeout_length === null) {\n            tests.timeout();\n        }\n    }\n    expose(timeout, 'timeout');\n\n    /**\n     * Add a callback that's triggered when the first :js:class:`Test` is created.\n     *\n     * @param {Function} callback - Callback function. This is called\n     * without arguments.\n     */\n    function add_start_callback(callback) {\n        tests.start_callbacks.push(callback);\n    }\n\n    /**\n     * Add a callback that's triggered when a test state changes.\n     *\n     * @param {Function} callback - Callback function, called with the\n     * :js:class:`Test` as the only argument.\n     */\n    function add_test_state_callback(callback) {\n        tests.test_state_callbacks.push(callback);\n    }\n\n    /**\n     * Add a callback that's triggered when a test result is received.\n     *\n     * @param {Function} callback - Callback function, called with the\n     * :js:class:`Test` as the only argument.\n     */\n    function add_result_callback(callback) {\n        tests.test_done_callbacks.push(callback);\n    }\n\n    /**\n     * Add a callback that's triggered when all tests are complete.\n     *\n     * @param {Function} callback - Callback function, called with an\n     * array of :js:class:`Test` objects, a :js:class:`TestsStatus`\n     * object and an array of :js:class:`AssertRecord` objects. If the\n     * debug setting is ``false`` the final argument will be an empty\n     * array.\n     *\n     * For performance reasons asserts are only tracked when the debug\n     * setting is ``true``. In other cases the array of asserts will be\n     * empty.\n     */\n    function add_completion_callback(callback) {\n        tests.all_done_callbacks.push(callback);\n    }\n\n    expose(add_start_callback, 'add_start_callback');\n    expose(add_test_state_callback, 'add_test_state_callback');\n    expose(add_result_callback, 'add_result_callback');\n    expose(add_completion_callback, 'add_completion_callback');\n\n    function remove(array, item) {\n        var index = array.indexOf(item);\n        if (index > -1) {\n            array.splice(index, 1);\n        }\n    }\n\n    function remove_start_callback(callback) {\n        remove(tests.start_callbacks, callback);\n    }\n\n    function remove_test_state_callback(callback) {\n        remove(tests.test_state_callbacks, callback);\n    }\n\n    function remove_result_callback(callback) {\n        remove(tests.test_done_callbacks, callback);\n    }\n\n    function remove_completion_callback(callback) {\n       remove(tests.all_done_callbacks, callback);\n    }\n\n    /*\n     * Output listener\n    */\n\n    function Output() {\n        this.output_document = document;\n        this.output_node = null;\n        this.enabled = settings.output;\n        this.phase = this.INITIAL;\n    }\n\n    Output.prototype.INITIAL = 0;\n    Output.prototype.STARTED = 1;\n    Output.prototype.HAVE_RESULTS = 2;\n    Output.prototype.COMPLETE = 3;\n\n    Output.prototype.setup = function(properties) {\n        if (this.phase > this.INITIAL) {\n            return;\n        }\n\n        //If output is disabled in testharnessreport.js the test shouldn't be\n        //able to override that\n        this.enabled = this.enabled && (properties.hasOwnProperty(\"output\") ?\n                                        properties.output : settings.output);\n    };\n\n    Output.prototype.init = function(properties) {\n        if (this.phase >= this.STARTED) {\n            return;\n        }\n        if (properties.output_document) {\n            this.output_document = properties.output_document;\n        } else {\n            this.output_document = document;\n        }\n        this.phase = this.STARTED;\n    };\n\n    Output.prototype.resolve_log = function() {\n        var output_document;\n        if (this.output_node) {\n            return;\n        }\n        if (typeof this.output_document === \"function\") {\n            output_document = this.output_document.apply(undefined);\n        } else {\n            output_document = this.output_document;\n        }\n        if (!output_document) {\n            return;\n        }\n        var node = output_document.getElementById(\"log\");\n        if (!node) {\n            if (output_document.readyState === \"loading\") {\n                return;\n            }\n            node = output_document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"div\");\n            node.id = \"log\";\n            if (output_document.body) {\n                output_document.body.appendChild(node);\n            } else {\n                var root = output_document.documentElement;\n                var is_html = (root &&\n                               root.namespaceURI == \"http://www.w3.org/1999/xhtml\" &&\n                               root.localName == \"html\");\n                var is_svg = (output_document.defaultView &&\n                              \"SVGSVGElement\" in output_document.defaultView &&\n                              root instanceof output_document.defaultView.SVGSVGElement);\n                if (is_svg) {\n                    var foreignObject = output_document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\n                    foreignObject.setAttribute(\"width\", \"100%\");\n                    foreignObject.setAttribute(\"height\", \"100%\");\n                    root.appendChild(foreignObject);\n                    foreignObject.appendChild(node);\n                } else if (is_html) {\n                    root.appendChild(output_document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"body\"))\n                        .appendChild(node);\n                } else {\n                    root.appendChild(node);\n                }\n            }\n        }\n        this.output_document = output_document;\n        this.output_node = node;\n    };\n\n    Output.prototype.show_status = function() {\n        if (this.phase < this.STARTED) {\n            this.init({});\n        }\n        if (!this.enabled || this.phase === this.COMPLETE) {\n            return;\n        }\n        this.resolve_log();\n        if (this.phase < this.HAVE_RESULTS) {\n            this.phase = this.HAVE_RESULTS;\n        }\n        var done_count = tests.tests.length - tests.num_pending;\n        if (this.output_node && !tests.hide_test_state) {\n            if (done_count < 100 ||\n                (done_count < 1000 && done_count % 100 === 0) ||\n                done_count % 1000 === 0) {\n                this.output_node.textContent = \"Running, \" +\n                    done_count + \" complete, \" +\n                    tests.num_pending + \" remain\";\n            }\n        }\n    };\n\n    Output.prototype.show_results = function (tests, harness_status, asserts_run) {\n        if (this.phase >= this.COMPLETE) {\n            return;\n        }\n        if (!this.enabled) {\n            return;\n        }\n        if (!this.output_node) {\n            this.resolve_log();\n        }\n        this.phase = this.COMPLETE;\n\n        var log = this.output_node;\n        if (!log) {\n            return;\n        }\n        var output_document = this.output_document;\n\n        while (log.lastChild) {\n            log.removeChild(log.lastChild);\n        }\n\n        var stylesheet = output_document.createElementNS(xhtml_ns, \"style\");\n        stylesheet.textContent = stylesheetContent;\n        var heads = output_document.getElementsByTagName(\"head\");\n        if (heads.length) {\n            heads[0].appendChild(stylesheet);\n        }\n\n        var status_number = {};\n        forEach(tests,\n                function(test) {\n                    var status = test.format_status();\n                    if (status_number.hasOwnProperty(status)) {\n                        status_number[status] += 1;\n                    } else {\n                        status_number[status] = 1;\n                    }\n                });\n\n        function status_class(status)\n        {\n            return status.replace(/\\s/g, '').toLowerCase();\n        }\n\n        var summary_template = [\"section\", {\"id\":\"summary\"},\n                                [\"h2\", {}, \"Summary\"],\n                                function()\n                                {\n                                    var status = harness_status.format_status();\n                                    var rv = [[\"section\", {},\n                                               [\"p\", {},\n                                                \"Harness status: \",\n                                                [\"span\", {\"class\":status_class(status)},\n                                                 status\n                                                ],\n                                               ],\n                                               [\"button\",\n                                                {\"onclick\": \"let evt = new Event('__test_restart'); \" +\n                                                 \"let canceled = !window.dispatchEvent(evt);\" +\n                                                 \"if (!canceled) { location.reload() }\"},\n                                                \"Rerun\"]\n                                              ]];\n\n                                    if (harness_status.status === harness_status.ERROR) {\n                                        rv[0].push([\"pre\", {}, harness_status.message]);\n                                        if (harness_status.stack) {\n                                            rv[0].push([\"pre\", {}, harness_status.stack]);\n                                        }\n                                    }\n                                    return rv;\n                                },\n                                [\"p\", {}, \"Found ${num_tests} tests\"],\n                                function() {\n                                    var rv = [[\"div\", {}]];\n                                    var i = 0;\n                                    while (Test.prototype.status_formats.hasOwnProperty(i)) {\n                                        if (status_number.hasOwnProperty(Test.prototype.status_formats[i])) {\n                                            var status = Test.prototype.status_formats[i];\n                                            rv[0].push([\"div\", {},\n                                                        [\"label\", {},\n                                                         [\"input\", {type:\"checkbox\", checked:\"checked\"}],\n                                                         status_number[status] + \" \",\n                                                         [\"span\", {\"class\":status_class(status)}, status]]]);\n                                        }\n                                        i++;\n                                    }\n                                    return rv;\n                                },\n                               ];\n\n        log.appendChild(render(summary_template, {num_tests:tests.length}, output_document));\n\n        forEach(output_document.querySelectorAll(\"section#summary label\"),\n                function(element)\n                {\n                    on_event(element, \"click\",\n                             function(e)\n                             {\n                                 if (output_document.getElementById(\"results\") === null) {\n                                     e.preventDefault();\n                                     return;\n                                 }\n                                 var result_class = element.querySelector(\"span[class]\").getAttribute(\"class\");\n                                 var style_element = output_document.querySelector(\"style#hide-\" + result_class);\n                                 var input_element = element.querySelector(\"input\");\n                                 if (!style_element && !input_element.checked) {\n                                     style_element = output_document.createElementNS(xhtml_ns, \"style\");\n                                     style_element.id = \"hide-\" + result_class;\n                                     style_element.textContent = \"table#results > tbody > tr.overall-\"+result_class+\"{display:none}\";\n                                     output_document.body.appendChild(style_element);\n                                 } else if (style_element && input_element.checked) {\n                                     style_element.parentNode.removeChild(style_element);\n                                 }\n                             });\n                });\n\n        // This use of innerHTML plus manual escaping is not recommended in\n        // general, but is necessary here for performance.  Using textContent\n        // on each individual <td> adds tens of seconds of execution time for\n        // large test suites (tens of thousands of tests).\n        function escape_html(s)\n        {\n            return s.replace(/\\&/g, \"&amp;\")\n                .replace(/</g, \"&lt;\")\n                .replace(/\"/g, \"&quot;\")\n                .replace(/'/g, \"&#39;\");\n        }\n\n        function has_assertions()\n        {\n            for (var i = 0; i < tests.length; i++) {\n                if (tests[i].properties.hasOwnProperty(\"assert\")) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function get_assertion(test)\n        {\n            if (test.properties.hasOwnProperty(\"assert\")) {\n                if (Array.isArray(test.properties.assert)) {\n                    return test.properties.assert.join(' ');\n                }\n                return test.properties.assert;\n            }\n            return '';\n        }\n\n        var asserts_run_by_test = new Map();\n        asserts_run.forEach(assert => {\n            if (!asserts_run_by_test.has(assert.test)) {\n                asserts_run_by_test.set(assert.test, []);\n            }\n            asserts_run_by_test.get(assert.test).push(assert);\n        });\n\n        function get_asserts_output(test) {\n            var asserts = asserts_run_by_test.get(test);\n            if (!asserts) {\n                return \"No asserts ran\";\n            }\n            rv = \"<table>\";\n            rv += asserts.map(assert => {\n                var output_fn = \"<strong>\" + escape_html(assert.assert_name) + \"</strong>(\";\n                var prefix_len = output_fn.length;\n                var output_args = assert.args;\n                var output_len = output_args.reduce((prev, current) => prev+current, prefix_len);\n                if (output_len[output_len.length - 1] > 50) {\n                    output_args = output_args.map((x, i) =>\n                    (i > 0 ? \"  \".repeat(prefix_len) : \"\" )+ x + (i < output_args.length - 1 ? \",\\n\" : \"\"));\n                } else {\n                    output_args = output_args.map((x, i) => x + (i < output_args.length - 1 ? \", \" : \"\"));\n                }\n                output_fn += escape_html(output_args.join(\"\"));\n                output_fn += ')';\n                var output_location;\n                if (assert.stack) {\n                    output_location = assert.stack.split(\"\\n\", 1)[0].replace(/@?\\w+:\\/\\/[^ \"\\/]+(?::\\d+)?/g, \" \");\n                }\n                return \"<tr class='overall-\" +\n                    status_class(Test.prototype.status_formats[assert.status]) + \"'>\" +\n                    \"<td class='\" +\n                    status_class(Test.prototype.status_formats[assert.status]) + \"'>\" +\n                    Test.prototype.status_formats[assert.status] + \"</td>\" +\n                    \"<td><pre>\" +\n                    output_fn +\n                    (output_location ? \"\\n\" + escape_html(output_location) : \"\") +\n                    \"</pre></td></tr>\";\n            }\n            ).join(\"\\n\");\n            rv += \"</table>\";\n            return rv;\n        }\n\n        log.appendChild(document.createElementNS(xhtml_ns, \"section\"));\n        var assertions = has_assertions();\n        var html = \"<h2>Details</h2><table id='results' \" + (assertions ? \"class='assertions'\" : \"\" ) + \">\" +\n            \"<thead><tr><th>Result</th><th>Test Name</th>\" +\n            (assertions ? \"<th>Assertion</th>\" : \"\") +\n            \"<th>Message</th></tr></thead>\" +\n            \"<tbody>\";\n        for (var i = 0; i < tests.length; i++) {\n            var test = tests[i];\n            html += '<tr class=\"overall-' +\n                status_class(test.format_status()) +\n                '\">' +\n                '<td class=\"' +\n                status_class(test.format_status()) +\n                '\">' +\n                test.format_status() +\n                \"</td><td>\" +\n                escape_html(test.name) +\n                \"</td><td>\" +\n                (assertions ? escape_html(get_assertion(test)) + \"</td><td>\" : \"\") +\n                escape_html(test.message ? tests[i].message : \" \") +\n                (tests[i].stack ? \"<pre>\" +\n                 escape_html(tests[i].stack) +\n                 \"</pre>\": \"\");\n            if (!(test instanceof RemoteTest)) {\n                 html += \"<details><summary>Asserts run</summary>\" + get_asserts_output(test) + \"</details>\"\n            }\n            html += \"</td></tr>\";\n        }\n        html += \"</tbody></table>\";\n        try {\n            log.lastChild.innerHTML = html;\n        } catch (e) {\n            log.appendChild(document.createElementNS(xhtml_ns, \"p\"))\n               .textContent = \"Setting innerHTML for the log threw an exception.\";\n            log.appendChild(document.createElementNS(xhtml_ns, \"pre\"))\n               .textContent = html;\n        }\n\n        window.dispatchEvent(new CustomEvent('extension_log', {detail: {type: \"DOWNLOAD\", content: \"\", ts: Date.now()}}))\n    };\n\n    /*\n     * Template code\n     *\n     * A template is just a JavaScript structure. An element is represented as:\n     *\n     * [tag_name, {attr_name:attr_value}, child1, child2]\n     *\n     * the children can either be strings (which act like text nodes), other templates or\n     * functions (see below)\n     *\n     * A text node is represented as\n     *\n     * [\"{text}\", value]\n     *\n     * String values have a simple substitution syntax; ${foo} represents a variable foo.\n     *\n     * It is possible to embed logic in templates by using a function in a place where a\n     * node would usually go. The function must either return part of a template or null.\n     *\n     * In cases where a set of nodes are required as output rather than a single node\n     * with children it is possible to just use a list\n     * [node1, node2, node3]\n     *\n     * Usage:\n     *\n     * render(template, substitutions) - take a template and an object mapping\n     * variable names to parameters and return either a DOM node or a list of DOM nodes\n     *\n     * substitute(template, substitutions) - take a template and variable mapping object,\n     * make the variable substitutions and return the substituted template\n     *\n     */\n\n    function is_single_node(template)\n    {\n        return typeof template[0] === \"string\";\n    }\n\n    function substitute(template, substitutions)\n    {\n        if (typeof template === \"function\") {\n            var replacement = template(substitutions);\n            if (!replacement) {\n                return null;\n            }\n\n            return substitute(replacement, substitutions);\n        }\n\n        if (is_single_node(template)) {\n            return substitute_single(template, substitutions);\n        }\n\n        return filter(map(template, function(x) {\n                              return substitute(x, substitutions);\n                          }), function(x) {return x !== null;});\n    }\n\n    function substitute_single(template, substitutions)\n    {\n        var substitution_re = /\\$\\{([^ }]*)\\}/g;\n\n        function do_substitution(input) {\n            var components = input.split(substitution_re);\n            var rv = [];\n            for (var i = 0; i < components.length; i += 2) {\n                rv.push(components[i]);\n                if (components[i + 1]) {\n                    rv.push(String(substitutions[components[i + 1]]));\n                }\n            }\n            return rv;\n        }\n\n        function substitute_attrs(attrs, rv)\n        {\n            rv[1] = {};\n            for (var name in template[1]) {\n                if (attrs.hasOwnProperty(name)) {\n                    var new_name = do_substitution(name).join(\"\");\n                    var new_value = do_substitution(attrs[name]).join(\"\");\n                    rv[1][new_name] = new_value;\n                }\n            }\n        }\n\n        function substitute_children(children, rv)\n        {\n            for (var i = 0; i < children.length; i++) {\n                if (children[i] instanceof Object) {\n                    var replacement = substitute(children[i], substitutions);\n                    if (replacement !== null) {\n                        if (is_single_node(replacement)) {\n                            rv.push(replacement);\n                        } else {\n                            extend(rv, replacement);\n                        }\n                    }\n                } else {\n                    extend(rv, do_substitution(String(children[i])));\n                }\n            }\n            return rv;\n        }\n\n        var rv = [];\n        rv.push(do_substitution(String(template[0])).join(\"\"));\n\n        if (template[0] === \"{text}\") {\n            substitute_children(template.slice(1), rv);\n        } else {\n            substitute_attrs(template[1], rv);\n            substitute_children(template.slice(2), rv);\n        }\n\n        return rv;\n    }\n\n    function make_dom_single(template, doc)\n    {\n        var output_document = doc || document;\n        var element;\n        if (template[0] === \"{text}\") {\n            element = output_document.createTextNode(\"\");\n            for (var i = 1; i < template.length; i++) {\n                element.data += template[i];\n            }\n        } else {\n            element = output_document.createElementNS(xhtml_ns, template[0]);\n            for (var name in template[1]) {\n                if (template[1].hasOwnProperty(name)) {\n                    element.setAttribute(name, template[1][name]);\n                }\n            }\n            for (var i = 2; i < template.length; i++) {\n                if (template[i] instanceof Object) {\n                    var sub_element = make_dom(template[i]);\n                    element.appendChild(sub_element);\n                } else {\n                    var text_node = output_document.createTextNode(template[i]);\n                    element.appendChild(text_node);\n                }\n            }\n        }\n\n        return element;\n    }\n\n    function make_dom(template, substitutions, output_document)\n    {\n        if (is_single_node(template)) {\n            return make_dom_single(template, output_document);\n        }\n\n        return map(template, function(x) {\n                       return make_dom_single(x, output_document);\n                   });\n    }\n\n    function render(template, substitutions, output_document)\n    {\n        return make_dom(substitute(template, substitutions), output_document);\n    }\n\n    /*\n     * Utility functions\n     */\n    function assert(expected_true, function_name, description, error, substitutions)\n    {\n        if (expected_true !== true && false) {\n            var msg = make_message(function_name, description,\n                                   error, substitutions);\n            throw new AssertionError(msg);\n        }\n    }\n\n    /**\n     * @class\n     * Exception type that represents a failing assert.\n     *\n     * @param {string} message - Error message.\n     */\n    function AssertionError(message)\n    {\n        if (typeof message == \"string\") {\n            message = sanitize_unpaired_surrogates(message);\n        }\n        this.message = message;\n        this.stack = get_stack();\n    }\n    expose(AssertionError, \"AssertionError\");\n\n    AssertionError.prototype = Object.create(Error.prototype);\n\n    const get_stack = function() {\n        var stack = new Error().stack;\n\n        // 'Error.stack' is not supported in all browsers/versions\n        if (!stack) {\n            return \"(Stack trace unavailable)\";\n        }\n\n        var lines = stack.split(\"\\n\");\n\n        // Create a pattern to match stack frames originating within testharness.js.  These include the\n        // script URL, followed by the line/col (e.g., '/resources/testharness.js:120:21').\n        // Escape the URL per http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n        // in case it contains RegExp characters.\n        var script_url = get_script_url();\n        var re_text = script_url ? script_url.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') : \"\\\\btestharness.js\";\n        var re = new RegExp(re_text + \":\\\\d+:\\\\d+\");\n\n        // Some browsers include a preamble that specifies the type of the error object.  Skip this by\n        // advancing until we find the first stack frame originating from testharness.js.\n        var i = 0;\n        while (!re.test(lines[i]) && i < lines.length) {\n            i++;\n        }\n\n        // Then skip the top frames originating from testharness.js to begin the stack at the test code.\n        while (re.test(lines[i]) && i < lines.length) {\n            i++;\n        }\n\n        // Paranoid check that we didn't skip all frames.  If so, return the original stack unmodified.\n        if (i >= lines.length) {\n            return stack;\n        }\n\n        return lines.slice(i).join(\"\\n\");\n    }\n\n    function OptionalFeatureUnsupportedError(message)\n    {\n        AssertionError.call(this, message);\n    }\n    OptionalFeatureUnsupportedError.prototype = Object.create(AssertionError.prototype);\n    expose(OptionalFeatureUnsupportedError, \"OptionalFeatureUnsupportedError\");\n\n    function make_message(function_name, description, error, substitutions)\n    {\n        for (var p in substitutions) {\n            if (substitutions.hasOwnProperty(p)) {\n                substitutions[p] = format_value(substitutions[p]);\n            }\n        }\n        var node_form = substitute([\"{text}\", \"${function_name}: ${description}\" + error],\n                                   merge({function_name:function_name,\n                                          description:(description?description + \" \":\"\")},\n                                          substitutions));\n        return node_form.slice(1).join(\"\");\n    }\n\n    function filter(array, callable, thisObj) {\n        var rv = [];\n        for (var i = 0; i < array.length; i++) {\n            if (array.hasOwnProperty(i)) {\n                var pass = callable.call(thisObj, array[i], i, array);\n                if (pass) {\n                    rv.push(array[i]);\n                }\n            }\n        }\n        return rv;\n    }\n\n    function map(array, callable, thisObj)\n    {\n        var rv = [];\n        rv.length = array.length;\n        for (var i = 0; i < array.length; i++) {\n            if (array.hasOwnProperty(i)) {\n                rv[i] = callable.call(thisObj, array[i], i, array);\n            }\n        }\n        return rv;\n    }\n\n    function extend(array, items)\n    {\n        Array.prototype.push.apply(array, items);\n    }\n\n    function forEach(array, callback, thisObj)\n    {\n        for (var i = 0; i < array.length; i++) {\n            if (array.hasOwnProperty(i)) {\n                callback.call(thisObj, array[i], i, array);\n            }\n        }\n    }\n\n    /**\n     * Immediately invoke a \"iteratee\" function with a series of values in\n     * parallel and invoke a final \"done\" function when all of the \"iteratee\"\n     * invocations have signaled completion.\n     *\n     * If all callbacks complete synchronously (or if no callbacks are\n     * specified), the ``done_callback`` will be invoked synchronously. It is the\n     * responsibility of the caller to ensure asynchronicity in cases where\n     * that is desired.\n     *\n     * @param {array} value Zero or more values to use in the invocation of\n     *                      ``iter_callback``\n     * @param {function} iter_callback A function that will be invoked\n     *                                 once for each of the values min\n     *                                 ``value``. Two arguments will\n     *                                 be available in each\n     *                                 invocation: the value from\n     *                                 ``value`` and a function that\n     *                                 must be invoked to signal\n     *                                 completion\n     * @param {function} done_callback A function that will be invoked after\n     *                                 all operations initiated by the\n     *                                 ``iter_callback`` function have signaled\n     *                                 completion\n     */\n    function all_async(values, iter_callback, done_callback)\n    {\n        var remaining = values.length;\n\n        if (remaining === 0) {\n            done_callback();\n        }\n\n        forEach(values,\n                function(element) {\n                    var invoked = false;\n                    var elDone = function() {\n                        if (invoked) {\n                            return;\n                        }\n\n                        invoked = true;\n                        remaining -= 1;\n\n                        if (remaining === 0) {\n                            done_callback();\n                        }\n                    };\n\n                    iter_callback(element, elDone);\n                });\n    }\n\n    function merge(a,b)\n    {\n        var rv = {};\n        var p;\n        for (p in a) {\n            rv[p] = a[p];\n        }\n        for (p in b) {\n            rv[p] = b[p];\n        }\n        return rv;\n    }\n\n    function expose(object, name)\n    {\n        var components = name.split(\".\");\n        var target = global_scope;\n        for (var i = 0; i < components.length - 1; i++) {\n            if (!(components[i] in target)) {\n                target[components[i]] = {};\n            }\n            target = target[components[i]];\n        }\n        target[components[components.length - 1]] = object;\n    }\n\n    function is_same_origin(w) {\n        try {\n            'random_prop' in w;\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /** Returns the 'src' URL of the first <script> tag in the page to include the file 'testharness.js'. */\n    function get_script_url()\n    {\n        if (!('document' in global_scope)) {\n            return undefined;\n        }\n\n        var scripts = document.getElementsByTagName(\"script\");\n        for (var i = 0; i < scripts.length; i++) {\n            var src;\n            if (scripts[i].src) {\n                src = scripts[i].src;\n            } else if (scripts[i].href) {\n                //SVG case\n                src = scripts[i].href.baseVal;\n            }\n\n            var matches = src && src.match(/^(.*\\/|)testharness\\.js$/);\n            if (matches) {\n                return src;\n            }\n        }\n        return undefined;\n    }\n\n    /** Returns the <title> or filename or \"Untitled\" */\n    function get_title()\n    {\n        if ('document' in global_scope) {\n            //Don't use document.title to work around an Opera/Presto bug in XHTML documents\n            var title = document.getElementsByTagName(\"title\")[0];\n            if (title && title.firstChild && title.firstChild.data) {\n                return title.firstChild.data;\n            }\n        }\n        if ('META_TITLE' in global_scope && META_TITLE) {\n            return META_TITLE;\n        }\n        if ('location' in global_scope && 'pathname' in location) {\n            return location.pathname.substring(location.pathname.lastIndexOf('/') + 1, location.pathname.indexOf('.'));\n        }\n        return \"Untitled\";\n    }\n\n    /**\n     * Setup globals\n     */\n\n    var tests = new Tests();\n\n    if (global_scope.addEventListener) {\n        var error_handler = function(error, message, stack) {\n            var optional_unsupported = error instanceof OptionalFeatureUnsupportedError;\n            if (tests.file_is_test) {\n                var test = tests.tests[0];\n                if (test.phase >= test.phases.HAS_RESULT) {\n                    return;\n                }\n                var status = optional_unsupported ? test.PRECONDITION_FAILED : test.FAIL;\n                test.set_status(status, message, stack);\n                test.phase = test.phases.HAS_RESULT;\n            } else if (!tests.allow_uncaught_exception) {\n                var status = optional_unsupported ? tests.status.PRECONDITION_FAILED : tests.status.ERROR;\n                tests.status.status = status;\n                tests.status.message = message;\n                tests.status.stack = stack;\n            }\n\n            // Do not transition to the \"complete\" phase if the test has been\n            // configured to allow uncaught exceptions. This gives the test an\n            // opportunity to define subtests based on the exception reporting\n            // behavior.\n            if (!tests.allow_uncaught_exception) {\n                done();\n            }\n        };\n\n        addEventListener(\"error\", function(e) {\n            var message = e.message;\n            var stack;\n            if (e.error && e.error.stack) {\n                stack = e.error.stack;\n            } else {\n                stack = e.filename + \":\" + e.lineno + \":\" + e.colno;\n            }\n            error_handler(e.error, message, stack);\n        }, false);\n\n        addEventListener(\"unhandledrejection\", function(e) {\n            var message;\n            if (e.reason && e.reason.message) {\n                message = \"Unhandled rejection: \" + e.reason.message;\n            } else {\n                message = \"Unhandled rejection\";\n            }\n            var stack;\n            if (e.reason && e.reason.stack) {\n                stack = e.reason.stack;\n            }\n            error_handler(e.reason, message, stack);\n        }, false);\n    }\n\n    test_environment.on_tests_ready();\n\n    /**\n     * Stylesheet\n     */\n     var stylesheetContent = \"\\\nhtml {\\\n    font-family:DejaVu Sans, Bitstream Vera Sans, Arial, Sans;\\\n}\\\n\\\n#log .warning,\\\n#log .warning a {\\\n  color: black;\\\n  background: yellow;\\\n}\\\n\\\n#log .error,\\\n#log .error a {\\\n  color: white;\\\n  background: red;\\\n}\\\n\\\nsection#summary {\\\n    margin-bottom:1em;\\\n}\\\n\\\ntable#results {\\\n    border-collapse:collapse;\\\n    table-layout:fixed;\\\n    width:100%;\\\n}\\\n\\\ntable#results > thead > tr > th:first-child,\\\ntable#results > tbody > tr > td:first-child {\\\n    width:8em;\\\n}\\\n\\\ntable#results > thead > tr > th:last-child,\\\ntable#results > thead > tr > td:last-child {\\\n    width:50%;\\\n}\\\n\\\ntable#results.assertions > thead > tr > th:last-child,\\\ntable#results.assertions > tbody > tr > td:last-child {\\\n    width:35%;\\\n}\\\n\\\ntable#results > thead > > tr > th {\\\n    padding:0;\\\n    padding-bottom:0.5em;\\\n    border-bottom:medium solid black;\\\n}\\\n\\\ntable#results > tbody > tr> td {\\\n    padding:1em;\\\n    padding-bottom:0.5em;\\\n    border-bottom:thin solid black;\\\n}\\\n\\\n.pass {\\\n    color:green;\\\n}\\\n\\\n.fail {\\\n    color:red;\\\n}\\\n\\\ntr.timeout {\\\n    color:red;\\\n}\\\n\\\ntr.notrun {\\\n    color:blue;\\\n}\\\n\\\ntr.optionalunsupported {\\\n    color:blue;\\\n}\\\n\\\n.ok {\\\n    color:green;\\\n}\\\n\\\n.error {\\\n    color:red;\\\n}\\\n\\\n.pass, .fail, .timeout, .notrun, .optionalunsupported .ok, .timeout, .error {\\\n    font-variant:small-caps;\\\n}\\\n\\\ntable#results span {\\\n    display:block;\\\n}\\\n\\\ntable#results span.expected {\\\n    font-family:DejaVu Sans Mono, Bitstream Vera Sans Mono, Monospace;\\\n    white-space:pre;\\\n}\\\n\\\ntable#results span.actual {\\\n    font-family:DejaVu Sans Mono, Bitstream Vera Sans Mono, Monospace;\\\n    white-space:pre;\\\n}\\\n\";\n\n})(self);\n// vim: set expandtab shiftwidth=4 tabstop=4:\n"}]}}
